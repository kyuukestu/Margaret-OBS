/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// src/utils/regex.ts
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
var init_regex = __esm({
  "src/utils/regex.ts"() {
  }
});

// src/constants/aiDefaults.ts
var DEFAULT_GEMINI_MODEL_ID, DEFAULT_OPENAI_MODEL_ID, DEFAULT_ANTHROPIC_MODEL_ID;
var init_aiDefaults = __esm({
  "src/constants/aiDefaults.ts"() {
    DEFAULT_GEMINI_MODEL_ID = "gemini-pro-latest";
    DEFAULT_OPENAI_MODEL_ID = "gpt-5.2-chat-latest";
    DEFAULT_ANTHROPIC_MODEL_ID = "claude-sonnet-4-5-20250929";
  }
});

// src/utils/rangeValidation.ts
function parseRange(rangeStr) {
  if (!rangeStr || typeof rangeStr !== "string") return null;
  const cleaned = rangeStr.trim();
  if (/^\d+$/.test(cleaned)) {
    const value = parseInt(cleaned, 10);
    if (!isNaN(value) && value >= 0 && value <= 100) {
      return { min: value, max: value };
    }
    return null;
  }
  const match = cleaned.match(/^(\d+)\s*-\s*(\d+)$/);
  if (match) {
    const min = parseInt(match[1], 10);
    const max = parseInt(match[2], 10);
    if (!isNaN(min) && !isNaN(max) && min >= 0 && max <= 100 && min <= max) {
      return { min, max };
    }
  }
  return null;
}
function isScoreInRange(score, range) {
  return score >= range.min && score <= range.max;
}
var init_rangeValidation = __esm({
  "src/utils/rangeValidation.ts"() {
  }
});

// src/utils/gossamer.ts
var gossamer_exports = {};
__export(gossamer_exports, {
  DefaultGossamerMomentum: () => DefaultGossamerMomentum,
  appendGossamerScore: () => appendGossamerScore,
  buildAllGossamerRuns: () => buildAllGossamerRuns,
  buildRunFromDefault: () => buildRunFromDefault,
  buildRunFromGossamerField: () => buildRunFromGossamerField,
  extractBeatOrder: () => extractBeatOrder,
  extractPresentBeatScores: () => extractPresentBeatScores,
  filterBeatsBySystem: () => filterBeatsBySystem,
  normalizeBeatName: () => normalizeBeatName,
  normalizeGossamerHistory: () => normalizeGossamerHistory,
  shiftGossamerHistory: () => shiftGossamerHistory,
  zeroOffsetRun: () => zeroOffsetRun
});
function filterBeatsBySystem(beats, selectedBeatSystem, customBeatSystemName) {
  if (!selectedBeatSystem || selectedBeatSystem.trim() === "") {
    return beats;
  }
  const system = selectedBeatSystem.trim();
  if (system === "Custom") {
    if (customBeatSystemName && customBeatSystemName.trim() !== "") {
      const customName = customBeatSystemName.trim();
      const builtInSystems2 = ["save the cat", "savethecat", "hero's journey", "herosjourney", "story grid", "storygrid"];
      return beats.filter((b) => {
        const beatModel = b["Beat Model"];
        if (!beatModel || typeof beatModel !== "string") return true;
        const normalizedModel = beatModel.toLowerCase().replace(/\s+/g, "").replace(/'/g, "");
        if (beatModel === customName) return true;
        return !builtInSystems2.includes(normalizedModel);
      });
    }
    const builtInSystems = ["save the cat", "savethecat", "hero's journey", "herosjourney", "story grid", "storygrid"];
    return beats.filter((b) => {
      const beatModel = b["Beat Model"];
      if (!beatModel || typeof beatModel !== "string") return true;
      const normalizedModel = beatModel.toLowerCase().replace(/\s+/g, "").replace(/'/g, "");
      return !builtInSystems.includes(normalizedModel);
    });
  } else {
    const normalizedSelected = selectedBeatSystem.toLowerCase().replace(/\s+/g, "").replace(/'/g, "");
    return beats.filter((b) => {
      const beatModel = b["Beat Model"];
      if (!beatModel || typeof beatModel !== "string") return false;
      const normalizedModel = beatModel.toLowerCase().replace(/\s+/g, "").replace(/'/g, "");
      return normalizedModel === normalizedSelected;
    });
  }
}
function normalizeBeatName(name) {
  return (name || "").replace(/\s*\d+(?:\s*-\s*\d+)?\s*%?\s*$/i, "").trim().toLowerCase().replace(/[-\s]/g, "");
}
function buildRunFromGossamerField(scenes, fieldName, selectedBeatModel, includeZeroScores = true) {
  let beats;
  if (!scenes || scenes.length === 0) {
    return {
      beats: [],
      overall: {
        summary: "No scenes provided.",
        refinements: [],
        incompleteBeats: []
      },
      meta: { label: fieldName, date: (/* @__PURE__ */ new Date()).toISOString() }
    };
  }
  let actualField = fieldName;
  if (fieldName === "Gossamer1") {
    let maxIndex = 1;
    scenes.forEach((s) => {
      for (let i = 30; i >= 1; i--) {
        if (s[`Gossamer${i}`] !== void 0) {
          maxIndex = Math.max(maxIndex, i);
          break;
        }
      }
    });
  }
  let plotNotes = scenes.filter((s) => s.itemType === "Beat" || s.itemType === "Plot");
  if (selectedBeatModel && selectedBeatModel.trim() !== "" && plotNotes.some((p) => p["Beat Model"])) {
    plotNotes = filterBeatsBySystem(plotNotes, selectedBeatModel);
  }
  if (plotNotes.length === 0) {
    return {
      beats: [],
      overall: {
        summary: selectedBeatModel ? `No Beat notes found with Beat Model: ${selectedBeatModel}` : "No Beat notes found. Create notes with Class: Beat.",
        refinements: [],
        incompleteBeats: []
      },
      meta: { label: fieldName, date: (/* @__PURE__ */ new Date()).toISOString() }
    };
  }
  plotNotes.sort((a, b) => {
    const aMatch = (a.title || "").match(/^(\d+(?:\.\d+)?)/);
    const bMatch = (b.title || "").match(/^(\d+(?:\.\d+)?)/);
    const aNum = aMatch ? parseFloat(aMatch[1]) : 0;
    const bNum = bMatch ? parseFloat(bMatch[1]) : 0;
    return aNum - bNum;
  });
  const incompleteBeats = [];
  beats = plotNotes.map((plotNote) => {
    const beatTitle = (plotNote.title || "").replace(/^\s*\d+(?:\.\d+)?\s+/, "").trim();
    let parsedScore = void 0;
    const fieldValue = plotNote[fieldName];
    if (fieldValue !== void 0 && fieldValue !== null) {
      const raw = fieldValue;
      if (typeof raw === "number") {
        parsedScore = raw;
      } else if (typeof raw === "string") {
        const match = raw.match(/\d+/);
        if (match) {
          const num = parseInt(match[0], 10);
          if (!isNaN(num) && num >= 0 && num <= 100) {
            parsedScore = num;
          }
        }
      }
    }
    let range = void 0;
    let isOutOfRange = false;
    const rangeValue = plotNote.Range;
    if (typeof rangeValue === "string") {
      const parsed = parseRange(rangeValue);
      if (parsed) {
        range = parsed;
        if (parsedScore !== void 0) {
          isOutOfRange = !isScoreInRange(parsedScore, range);
        }
      }
    }
    if (parsedScore !== void 0) {
      return {
        beat: beatTitle,
        score: parsedScore,
        notes: `Score from Beat note frontmatter (${fieldName}).`,
        status: "present",
        range,
        isOutOfRange
      };
    } else if (includeZeroScores) {
      incompleteBeats.push(beatTitle);
      return {
        beat: beatTitle,
        score: 0,
        notes: `No ${fieldName} score in frontmatter - defaulting to 0.`,
        status: "outlineOnly",
        range,
        isOutOfRange: false
      };
    } else {
      return {
        beat: beatTitle,
        score: 0,
        notes: `No ${fieldName} score in frontmatter.`,
        status: "missing"
      };
    }
  }).filter((beat) => beat.status !== "missing");
  const presentCount = beats.filter((b) => b.status === "present").length;
  return {
    beats,
    overall: {
      summary: presentCount > 0 ? `${fieldName} scores loaded from ${presentCount} of ${plotNotes.length} Beat notes.` : `No ${fieldName} scores found in Beat notes.`,
      refinements: [],
      incompleteBeats
    },
    meta: {
      label: fieldName.startsWith("Gossamer") ? `Run ${fieldName.replace("Gossamer", "")}` : fieldName,
      date: (/* @__PURE__ */ new Date()).toISOString(),
      model: selectedBeatModel
    }
  };
}
function buildRunFromDefault(scenes, selectedBeatModel) {
  if (!scenes) return buildRunFromGossamerField(scenes, "Gossamer1", selectedBeatModel, true);
  let plotNotes = scenes.filter((s) => s.itemType === "Beat" || s.itemType === "Plot");
  if (selectedBeatModel && selectedBeatModel.trim() !== "" && plotNotes.some((p) => p["Beat Model"])) {
    plotNotes = filterBeatsBySystem(plotNotes, selectedBeatModel);
  }
  plotNotes.sort((a, b) => {
    const aMatch = (a.title || "").match(/^(\d+(?:\.\d+)?)/);
    const bMatch = (b.title || "").match(/^(\d+(?:\.\d+)?)/);
    const aNum = aMatch ? parseFloat(aMatch[1]) : 0;
    const bNum = bMatch ? parseFloat(bMatch[1]) : 0;
    return aNum - bNum;
  });
  const beats = plotNotes.map((note) => {
    const beatTitle = (note.title || "").replace(/^\s*\d+(?:\.\d+)?\s+/, "").trim();
    let latestScore = void 0;
    let latestRunIndex = 0;
    for (let i = 30; i >= 1; i--) {
      const val = note[`Gossamer${i}`];
      if (val !== void 0 && val !== null && typeof val === "number") {
        latestScore = val;
        latestRunIndex = i;
        break;
      }
    }
    let range = void 0;
    let isOutOfRange = false;
    const rangeValue = note.Range;
    if (typeof rangeValue === "string") {
      const parsed = parseRange(rangeValue);
      if (parsed) {
        range = parsed;
        if (latestScore !== void 0) {
          isOutOfRange = !isScoreInRange(latestScore, range);
        }
      }
    }
    if (latestScore !== void 0) {
      return {
        beat: beatTitle,
        score: latestScore,
        notes: `Latest score from Gossamer${latestRunIndex}`,
        status: "present",
        range,
        isOutOfRange
      };
    } else {
      return {
        beat: beatTitle,
        score: 0,
        notes: "No scores found",
        status: "outlineOnly",
        range,
        isOutOfRange: false
      };
    }
  });
  return {
    beats,
    overall: {
      summary: `Current View: Showing latest scores (up to Gossamer30).`,
      refinements: [],
      incompleteBeats: []
    },
    meta: {
      label: "Latest Run",
      date: (/* @__PURE__ */ new Date()).toISOString(),
      model: selectedBeatModel
    }
  };
}
function buildAllGossamerRuns(scenes, selectedBeatModel) {
  if (!scenes || scenes.length === 0) {
    return {
      current: buildRunFromGossamerField(scenes, "Gossamer1", selectedBeatModel, true),
      historical: [],
      minMax: null,
      hasAnyScores: false
    };
  }
  const current = buildRunFromGossamerField(scenes, "Gossamer1", selectedBeatModel, true);
  const historicalColor = "#c0c0c0";
  const historical = [];
  for (let i = 2; i <= 30; i++) {
    const fieldName = `Gossamer${i}`;
    const hasAnyValue = scenes.some((s) => (s.itemType === "Beat" || s.itemType === "Plot") && s[fieldName] !== void 0 && s[fieldName] !== null);
    if (hasAnyValue) {
      const run = buildRunFromGossamerField(scenes, fieldName, selectedBeatModel, true);
      historical.push({
        label: fieldName,
        points: run.beats.map((b) => ({ beat: b.beat, score: b.score })),
        color: historicalColor
      });
    }
  }
  let minMax = null;
  if (historical.length > 0) {
    const allRuns = [current, ...historical.map((h) => ({ beats: h.points.map((p) => ({ ...p, status: "present", notes: "" })) }))];
    const beatNames = current.beats.map((b) => b.beat);
    const minPoints = [];
    const maxPoints = [];
    beatNames.forEach((beatName) => {
      const scores = [];
      const currentBeat = current.beats.find((b) => b.beat === beatName);
      if (currentBeat && (currentBeat.status === "present" || currentBeat.status === "outlineOnly")) {
        scores.push(currentBeat.score);
      }
      historical.forEach((h) => {
        const point = h.points.find((p) => p.beat === beatName);
        if (point) {
          scores.push(point.score);
        }
      });
      if (scores.length >= 1) {
        const min = Math.min(...scores);
        const max = Math.max(...scores);
        minPoints.push({ beat: beatName, score: min });
        maxPoints.push({ beat: beatName, score: max });
      }
    });
    if (minPoints.length >= 3 && maxPoints.length >= 3) {
      minMax = { min: minPoints, max: maxPoints };
    }
  }
  const hasAnyCurrentScores = current.beats.some((b) => b.status === "present" && typeof b.score === "number");
  const hasHistoricalScores = historical.some((run) => run.points.some((point) => typeof point.score === "number" && !Number.isNaN(point.score)));
  const hasAnyScores = hasAnyCurrentScores || hasHistoricalScores;
  return { current, historical, minMax, hasAnyScores };
}
function zeroOffsetRun(run) {
  const firstBeat = run.beats[0];
  const base = typeof (firstBeat == null ? void 0 : firstBeat.score) === "number" ? firstBeat.score : 0;
  return {
    ...run,
    beats: run.beats.map((b) => ({
      ...b,
      score: typeof b.score === "number" ? Math.max(0, b.score - base) : b.score
    }))
  };
}
function extractPresentBeatScores(run) {
  return run.beats.filter((b) => b.status === "present" && typeof b.score === "number").map((b) => ({ beat: b.beat, score: b.score }));
}
function extractBeatOrder(scenes, selectedBeatModel) {
  let plotBeats = scenes.filter((s) => s.itemType === "Beat" || s.itemType === "Plot");
  if (selectedBeatModel && selectedBeatModel.trim() !== "" && plotBeats.some((p) => p["Beat Model"])) {
    plotBeats = filterBeatsBySystem(plotBeats, selectedBeatModel);
  }
  plotBeats.sort((a, b) => {
    const aMatch = (a.title || "").match(/^(\d+(?:\.\d+)?)/);
    const bMatch = (b.title || "").match(/^(\d+(?:\.\d+)?)/);
    const aNum = aMatch ? parseFloat(aMatch[1]) : 0;
    const bNum = bMatch ? parseFloat(bMatch[1]) : 0;
    return aNum - bNum;
  });
  const beatNames = plotBeats.map((p) => (p.title || "").replace(/^\s*\d+(?:\.\d+)?\s+/, "").trim()).filter(Boolean);
  return beatNames;
}
function shiftGossamerHistory(frontmatter) {
  const maxHistory = 30;
  const updated = { ...frontmatter };
  const existingScores = {};
  const existingJustifications = {};
  for (let i = 1; i <= maxHistory; i++) {
    const scoreKey = `Gossamer${i}`;
    const justKey = `Gossamer${i} Justification`;
    if (typeof updated[scoreKey] === "number") {
      existingScores[i] = updated[scoreKey];
    }
    if (typeof updated[justKey] === "string") {
      existingJustifications[i] = updated[justKey];
    }
  }
  for (let i = 1; i <= maxHistory + 10; i++) {
    delete updated[`Gossamer${i}`];
    delete updated[`Gossamer${i} Justification`];
  }
  Object.entries(existingScores).forEach(([oldIndex, score]) => {
    const newIndex = parseInt(oldIndex) + 1;
    if (newIndex <= maxHistory) {
      updated[`Gossamer${newIndex}`] = score;
    }
  });
  Object.entries(existingJustifications).forEach(([oldIndex, justification]) => {
    const newIndex = parseInt(oldIndex) + 1;
    if (newIndex <= maxHistory) {
      updated[`Gossamer${newIndex} Justification`] = justification;
    }
  });
  return updated;
}
function normalizeGossamerHistory(frontmatter) {
  const maxHistory = 30;
  const normalized = {};
  const entries = [];
  let hasOrphanJustification = false;
  for (let i = 1; i <= maxHistory; i++) {
    const scoreKey = `Gossamer${i}`;
    const justKey = `Gossamer${i} Justification`;
    const rawScore = frontmatter[scoreKey];
    let numeric;
    if (typeof rawScore === "number") {
      numeric = rawScore;
    } else if (typeof rawScore === "string") {
      const parsed = parseInt(rawScore);
      if (!Number.isNaN(parsed)) numeric = parsed;
    }
    if (numeric !== void 0) {
      const entry = { score: numeric, originalIndex: i };
      const justification = frontmatter[justKey];
      if (typeof justification === "string" && justification.trim().length > 0) {
        entry.justification = justification;
      }
      entries.push(entry);
    } else if (typeof frontmatter[justKey] === "string" && frontmatter[justKey].trim().length > 0) {
      hasOrphanJustification = true;
    }
  }
  const needsRenumber = entries.some((entry, idx) => entry.originalIndex !== idx + 1);
  const changed = needsRenumber || hasOrphanJustification;
  entries.forEach((entry, idx) => {
    const key = `Gossamer${idx + 1}`;
    normalized[key] = entry.score;
    if (entry.justification) {
      normalized[`${key} Justification`] = entry.justification;
    }
  });
  return { normalized, changed };
}
function appendGossamerScore(frontmatter, maxHistory = 30) {
  const updated = { ...frontmatter };
  const hasValue = (value) => {
    if (value === null || value === void 0) return false;
    if (typeof value === "number") return !Number.isNaN(value);
    if (typeof value === "string") return value.trim().length > 0;
    return false;
  };
  for (let i = 1; i <= maxHistory; i++) {
    const key = `Gossamer${i}`;
    if (!hasValue(updated[key])) {
      return { nextIndex: i, updated };
    }
  }
  for (let i = 2; i <= maxHistory; i++) {
    const currentKey = `Gossamer${i}`;
    const previousKey = `Gossamer${i - 1}`;
    const currentJustKey = `Gossamer${i} Justification`;
    const previousJustKey = `Gossamer${i - 1} Justification`;
    if (hasValue(updated[currentKey])) {
      updated[previousKey] = updated[currentKey];
    } else {
      delete updated[previousKey];
    }
    if (hasValue(updated[currentJustKey])) {
      updated[previousJustKey] = updated[currentJustKey];
    } else {
      delete updated[previousJustKey];
    }
  }
  delete updated[`Gossamer${maxHistory}`];
  delete updated[`Gossamer${maxHistory} Justification`];
  return { nextIndex: maxHistory, updated };
}
var DefaultGossamerMomentum;
var init_gossamer = __esm({
  "src/utils/gossamer.ts"() {
    init_rangeValidation();
    DefaultGossamerMomentum = [
      { beat: "Opening Image", score: 4, notes: "Quiet status quo before disturbance." },
      { beat: "Theme Stated", score: 8, notes: "Subtle tension; hints of deeper change." },
      { beat: "Set-Up", score: 14, notes: "World and protagonist established; mild friction." },
      { beat: "Catalyst", score: 26, notes: "Inciting incident jolts the protagonist\u2019s world." },
      { beat: "Debate", score: 22, notes: "Internal conflict; push\u2013pull before commitment." },
      { beat: "Break into Two", score: 35, notes: "Crossing threshold; tension climbs." },
      { beat: "B Story", score: 40, notes: "Secondary stakes introduced; emotional contrast." },
      { beat: "Fun and Games", score: 46, notes: "Momentum holds steady; stakes rising under surface." },
      { beat: "Midpoint", score: 64, notes: "Major reversal or revelation; visible peak forming." },
      { beat: "Bad Guys Close In", score: 72, notes: "Pressure intensifies; opposing forces gather." },
      { beat: "All Is Lost", score: 86, notes: "Crisis hits; near-peak emotional tension." },
      { beat: "Dark Night of the Soul", score: 78, notes: "Momentary drop before regrouping." },
      { beat: "Break into Three", score: 82, notes: "Decision to fight back; new synthesis." },
      { beat: "Finale", score: 94, notes: "Climactic confrontation; maximum momentum." },
      { beat: "Final Image", score: 42, notes: "Resolution; lingering emotional after-echo." }
    ];
  }
});

// src/utils/tooltip.ts
function tooltip(element, text, placement = "bottom") {
  if (element instanceof HTMLElement) {
    (0, import_obsidian.setTooltip)(element, text, { placement });
  } else if (element instanceof SVGElement) {
    addTooltipData(element, text, placement);
  }
}
function tooltipForComponent(component, text, placement = "bottom") {
  const buttonEl = component.buttonEl;
  if (buttonEl) {
    (0, import_obsidian.setTooltip)(buttonEl, text, { placement });
  } else {
    component.setTooltip(text);
  }
}
function addTooltipData(element, text, placement = "bottom") {
  element.classList.add("rt-tooltip-target");
  element.setAttribute("data-tooltip", text);
  element.setAttribute("data-tooltip-placement", placement);
}
function setupTooltipsFromDataAttributes(container, registerDomEvent) {
  const svgElement = container instanceof SVGElement ? container : container.querySelector("svg");
  if (!svgElement) return;
  const handleMouseOver = (e) => {
    const target = e.target.closest(".rt-tooltip-target[data-tooltip]");
    if (target && target !== currentTarget) {
      currentTarget = target;
      const text = target.getAttribute("data-tooltip") || "";
      const placement = target.getAttribute("data-tooltip-placement") || "bottom";
      if (text) {
        showCustomTooltip(target, text, placement);
      }
    }
  };
  const handleMouseOut = (e) => {
    const target = e.target.closest(".rt-tooltip-target[data-tooltip]");
    const relatedTarget = e.relatedTarget;
    const newTarget = relatedTarget == null ? void 0 : relatedTarget.closest(".rt-tooltip-target[data-tooltip]");
    if (target && target === currentTarget && newTarget !== target) {
      hideTimeout = window.setTimeout(hideCustomTooltip, 50);
    }
  };
  registerDomEvent(svgElement, "mouseover", handleMouseOver);
  registerDomEvent(svgElement, "mouseout", handleMouseOut);
}
function cleanupTooltipAnchors() {
  if (customTooltipEl) {
    customTooltipEl.remove();
    customTooltipEl = null;
  }
  currentTarget = null;
  if (hideTimeout) {
    window.clearTimeout(hideTimeout);
    hideTimeout = null;
  }
}
function ensureCustomTooltip() {
  if (customTooltipEl) return;
  customTooltipEl = document.createElement("div");
  customTooltipEl.classList.add("rt-tooltip");
  document.body.appendChild(customTooltipEl);
}
function showCustomTooltip(target, text, placement) {
  if (!customTooltipEl) ensureCustomTooltip();
  if (!customTooltipEl) return;
  if (hideTimeout) {
    window.clearTimeout(hideTimeout);
    hideTimeout = null;
  }
  customTooltipEl.setText(text);
  customTooltipEl.className = "rt-tooltip";
  customTooltipEl.classList.add(`rt-placement-${placement}`);
  const rect = target.getBoundingClientRect();
  const tooltipRect = customTooltipEl.getBoundingClientRect();
  let top = 0;
  let left = 0;
  switch (placement) {
    case "bottom":
      left = rect.left + rect.width / 2;
      top = rect.bottom;
      break;
    case "top":
      left = rect.left + rect.width / 2;
      top = rect.top - tooltipRect.height;
      break;
    case "left":
      left = rect.left - tooltipRect.width;
      top = rect.top + rect.height / 2;
      break;
    case "right":
      left = rect.right;
      top = rect.top + rect.height / 2;
      break;
  }
  customTooltipEl.style.top = `${top}px`;
  customTooltipEl.style.left = `${left}px`;
  customTooltipEl.classList.add("rt-visible");
}
function hideCustomTooltip() {
  if (customTooltipEl) {
    customTooltipEl.classList.remove("rt-visible");
    currentTarget = null;
  }
}
var import_obsidian, customTooltipEl, currentTarget, hideTimeout;
var init_tooltip = __esm({
  "src/utils/tooltip.ts"() {
    import_obsidian = require("obsidian");
    customTooltipEl = null;
    currentTarget = null;
    hideTimeout = null;
  }
});

// src/utils/beatsSystems.ts
function getPlotSystem(name) {
  return PLOT_SYSTEMS[name] || null;
}
function getCustomSystemFromSettings(settings) {
  const name = settings.customBeatSystemName || "Custom";
  const beatObjs = settings.customBeatSystemBeats || [];
  const beats = beatObjs.map((b) => b.name).filter((n) => n.trim().length > 0);
  const beatDetails = beatObjs.filter((b) => b.name.trim().length > 0).map((b) => ({
    name: b.name,
    description: "",
    range: "",
    act: b.act
  }));
  return {
    name,
    beats,
    beatDetails,
    beatCount: beats.length
  };
}
var PLOT_SYSTEMS, PLOT_SYSTEM_NAMES;
var init_beatsSystems = __esm({
  "src/utils/beatsSystems.ts"() {
    PLOT_SYSTEMS = {
      "Save The Cat": {
        name: "Save The Cat",
        beatCount: 15,
        beats: [
          "Opening Image",
          "Theme Stated",
          "Setup",
          "Catalyst",
          "Debate",
          "Break into 2",
          "B Story",
          "Fun and Games",
          "Midpoint",
          "Bad Guys Close In",
          "All Is Lost",
          "Dark Night of the Soul",
          "Break into 3",
          "Finale",
          "Final Image"
        ],
        beatDetails: [
          {
            name: "Opening Image",
            description: "The first impression of your story. A snapshot of the protagonist's life before the journey begins. This 'before' picture sets up the world and establishes what will change by the end. Show the protagonist in their everyday life, revealing the flaw or gap that will be addressed.",
            placement: "0-1%",
            range: "0-10"
          },
          {
            name: "Theme Stated",
            description: "Someone (often not the protagonist) poses a question or statement that hints at what the story is really about. This thematic truth will be challenged and explored throughout the narrative. It's usually subtle and might go unnoticed by the protagonist initially.",
            placement: "5%",
            range: "5-15"
          },
          {
            name: "Setup",
            description: "Introduction to the protagonist's world, their relationships, routines, and the stakes. Show what's missing in their life and what they think they want. Establish the status quo that will be disrupted. Every element introduced here should have meaning or relevance to the story ahead.",
            placement: "1-10%",
            range: "10-20"
          },
          {
            name: "Catalyst",
            description: "The inciting incident that disrupts the protagonist's world. Something happens that presents a problem, opportunity, or challenge that cannot be ignored. This is the moment that sets the story in motion and introduces the central dramatic question.",
            placement: "10%",
            range: "25-35"
          },
          {
            name: "Debate",
            description: "The protagonist hesitates, questions, or resists the call to action. Internal conflict emerges as they weigh their options and wonder if they're ready for the journey ahead. This section builds tension as the audience anticipates the inevitable leap into Act Two.",
            placement: "10-20%",
            range: "20-30"
          },
          {
            name: "Break into 2",
            description: "The protagonist makes a choice and crosses the threshold into a new world or situation. They commit to the journey, leaving the familiar behind. This decision propels them into Act Two and sets the main story in motion. There's no turning back.",
            placement: "20%",
            range: "30-40"
          },
          {
            name: "B Story",
            description: "Introduction of a secondary storyline, often a relationship that provides emotional depth and thematic counterpoint to the main plot. This subplot typically explores the internal journey and helps the protagonist learn what they truly need (versus what they initially wanted).",
            placement: "22%",
            range: "35-45"
          },
          {
            name: "Fun and Games",
            description: "The promise of the premise. This is where the story delivers what the audience came for\u2014the core concept in action. The protagonist explores the new world, enjoys initial successes, and we see the story's unique appeal. Tension exists but hasn't reached its peak yet.",
            placement: "20-50%",
            range: "40-55"
          },
          {
            name: "Midpoint",
            description: "A major turning point that raises the stakes and changes the direction of the story. Either a false victory (things seem great but complications loom) or a false defeat (things seem terrible but hope remains). Time clocks and deadlines often appear here, adding urgency.",
            placement: "50%",
            range: "60-70"
          },
          {
            name: "Bad Guys Close In",
            description: "The opponent's forces regroup and push back harder. Internal and external pressures mount. The protagonist's flaws or weaknesses are exposed. Relationships may fray. The easy wins from Fun and Games evaporate as real obstacles emerge and consequences become clear.",
            placement: "50-75%",
            range: "65-80"
          },
          {
            name: "All Is Lost",
            description: "The lowest point. The protagonist loses everything or believes they do. The goal seems impossible. This is often the moment of greatest despair, where hope appears lost. Something or someone important may be literally or figuratively lost. The 'whiff of death' moment.",
            placement: "75%",
            range: "75-85"
          },
          {
            name: "Dark Night of the Soul",
            description: "A moment of reflection and wallowing in defeat. The protagonist processes the loss, questions everything, and confronts their deepest fears. This quiet, internal moment allows both character and audience to feel the full weight of All Is Lost before the final push begins.",
            placement: "75-80%",
            range: "70-80"
          },
          {
            name: "Break into 3",
            description: "The protagonist has an epiphany or receives crucial information that provides a solution. They synthesize what they've learned from both the A Story and B Story. Armed with new understanding, they formulate a plan and commit to one final attempt. Hope returns with newfound wisdom.",
            placement: "80%",
            range: "75-85"
          },
          {
            name: "Finale",
            description: "The climactic confrontation where the protagonist applies everything they've learned. They must prove they've changed by using new skills, wisdom, or perspective gained through the journey. The A Story and B Story threads come together. The central question is answered, and the theme is proven.",
            placement: "80-99%",
            range: "85-100"
          },
          {
            name: "Final Image",
            description: "The 'after' snapshot that mirrors and contrasts with the Opening Image. Show how the protagonist and their world have transformed. This closing image should demonstrate that real change has occurred and reflect the thematic journey. The story comes full circle.",
            placement: "99-100%",
            range: "30-50"
          }
        ]
      },
      "Hero's Journey": {
        name: "Hero's Journey",
        beatCount: 12,
        beats: [
          "Ordinary World",
          "Call to Adventure",
          "Refusal of the Call",
          "Meeting the Mentor",
          "Crossing the Threshold",
          "Tests, Allies, Enemies",
          "Approach to the Inmost Cave",
          "Ordeal",
          "Reward (Seizing the Sword)",
          "The Road Back",
          "Resurrection",
          "Return with the Elixir"
        ],
        beatDetails: [
          {
            name: "Ordinary World",
            description: "The hero's normal life before the adventure begins. Establish who they are, what they believe, their relationships, and their routine. Show what's lacking or incomplete in their life. This familiar world will be contrasted with the Special World they're about to enter.",
            placement: "0-10%",
            range: "0-15"
          },
          {
            name: "Call to Adventure",
            description: "The hero is presented with a problem, challenge, or adventure. Something disrupts their Ordinary World and beckons them toward the unknown. This call may come from external events or internal yearning, but it demands a response and offers the possibility of change.",
            placement: "10%",
            range: "20-30"
          },
          {
            name: "Refusal of the Call",
            description: "The hero hesitates or declines the adventure, usually out of fear, obligation, or insecurity. They may feel unworthy, unprepared, or unwilling to leave their comfort zone. This reluctance makes them relatable and human, building anticipation for when they finally accept.",
            placement: "10-15%",
            range: "15-25"
          },
          {
            name: "Meeting the Mentor",
            description: "The hero encounters someone who provides guidance, training, gifts, or confidence needed for the journey. The mentor may be a person, a memory, or even an object that inspires. This meeting gives the hero what they need to overcome their fear and commit to the adventure.",
            placement: "15-20%",
            range: "25-35"
          },
          {
            name: "Crossing the Threshold",
            description: "The hero leaves the Ordinary World and enters the Special World of the adventure. This is the point of no return where they commit fully to the journey. The rules change, stakes rise, and the hero must adapt to this new and unfamiliar environment.",
            placement: "20-25%",
            range: "35-45"
          },
          {
            name: "Tests, Allies, Enemies",
            description: "The hero faces challenges, makes friends, identifies enemies, and learns the rules of the Special World. Through trials and encounters, they develop new skills and understanding. This section establishes the landscape of Act Two and builds toward greater challenges ahead.",
            placement: "25-50%",
            range: "40-60"
          },
          {
            name: "Approach to the Inmost Cave",
            description: "The hero prepares for the major challenge ahead, often literally or metaphorically approaching the place of greatest danger. Plans are made, final preparations completed, and the hero steels themselves for the Ordeal. Tension builds as the supreme test draws near.",
            placement: "50-60%",
            range: "55-70"
          },
          {
            name: "Ordeal",
            description: "The supreme test where the hero faces their greatest fear or most difficult challenge. This is a life-or-death moment (literally or symbolically) where everything hangs in the balance. The hero may appear to fail, die, or lose everything before emerging transformed.",
            placement: "60-70%",
            range: "75-90"
          },
          {
            name: "Reward (Seizing the Sword)",
            description: "Having survived the Ordeal, the hero claims their reward\u2014knowledge, power, treasure, reconciliation, or love. They take possession of what they came for, though often it's different from what they originally sought. Success brings new understanding and confidence.",
            placement: "70-75%",
            range: "60-75"
          },
          {
            name: "The Road Back",
            description: "The hero begins the journey home but faces consequences or pursuit from their actions in the Special World. New complications arise, and forces may try to prevent their return. The hero must choose to complete the journey and bring their reward back to the Ordinary World.",
            placement: "75-80%",
            range: "70-80"
          },
          {
            name: "Resurrection",
            description: "The climactic final test where the hero must use everything they've learned. This is a last purification or rebirth before returning home. The stakes are highest here\u2014often involving life and death for more than just the hero. They must prove their transformation is complete.",
            placement: "80-95%",
            range: "85-100"
          },
          {
            name: "Return with the Elixir",
            description: "The hero returns to the Ordinary World transformed and bearing something (knowledge, treasure, wisdom, or experience) that benefits their community. The journey is complete, the hero has grown, and life is better than before. The story comes full circle with meaningful change.",
            placement: "95-100%",
            range: "35-55"
          }
        ]
      },
      "Story Grid": {
        name: "Story Grid",
        beatCount: 5,
        beats: [
          "Inciting Incident",
          "Progressive Complications",
          "Crisis",
          "Climax",
          "Resolution"
        ],
        beatDetails: [
          {
            name: "Inciting Incident",
            description: "An external event disrupts the core value and creates a problem the protagonist cannot ignore.",
            placement: "0-10%",
            range: "10-25"
          },
          {
            name: "Progressive Complications",
            description: "Escalating obstacles that worsen the situation. Each complication raises stakes and limits options; no repetition\u2014pressure increases.",
            placement: "10-70%",
            range: "25-60"
          },
          {
            name: "Crisis",
            description: "Binary choice: best bad option vs worst bad option. Forces the protagonist to risk what they value most.",
            placement: "70-85%",
            range: "60-80"
          },
          {
            name: "Climax",
            description: "Action taken to answer the Crisis question. Irreversible, value-charged decision.",
            placement: "85-95%",
            range: "80-100"
          },
          {
            name: "Resolution",
            description: "The new value state after the Climax. Shows cost, gain, and thematic meaning.",
            placement: "95-100%",
            range: "50-80"
          }
        ]
      }
    };
    PLOT_SYSTEM_NAMES = Object.keys(PLOT_SYSTEMS);
  }
});

// src/modals/GossamerScoreModal.ts
var import_obsidian2, GossamerScoreModal, NormalizeConfirmationModal;
var init_GossamerScoreModal = __esm({
  "src/modals/GossamerScoreModal.ts"() {
    import_obsidian2 = require("obsidian");
    init_tooltip();
    init_gossamer();
    init_GossamerCommands();
    init_beatsSystems();
    GossamerScoreModal = class _GossamerScoreModal extends import_obsidian2.Modal {
      constructor(app, plugin, plotBeats) {
        super(app);
        this.entries = [];
        this.includeBeatDescriptions = false;
        this.plugin = plugin;
        this.plotBeats = plotBeats;
      }
      analyzeNormalizationFrontmatter(frontmatter, beatTitle) {
        const maxHistory = 30;
        const missingSlots = [];
        const orphanJustifications = [];
        const indices = [];
        for (let i = 1; i <= maxHistory; i++) {
          const scoreKey = `Gossamer${i}`;
          const justKey = `Gossamer${i} Justification`;
          const rawScore = frontmatter[scoreKey];
          let numeric;
          if (typeof rawScore === "number") {
            numeric = rawScore;
          } else if (typeof rawScore === "string") {
            const parsed = parseInt(rawScore);
            if (!Number.isNaN(parsed)) numeric = parsed;
          }
          if (numeric !== void 0) {
            indices.push(i);
          } else if (typeof frontmatter[justKey] === "string" && frontmatter[justKey].trim().length > 0) {
            orphanJustifications.push(i);
          }
        }
        let hasRenumbering = false;
        let expectedIndex = 1;
        for (const idx of indices) {
          if (idx !== expectedIndex) {
            hasRenumbering = true;
            while (expectedIndex < idx) {
              missingSlots.push(expectedIndex);
              expectedIndex++;
            }
          }
          expectedIndex = idx + 1;
        }
        const changed = hasRenumbering || orphanJustifications.length > 0;
        return { beatTitle, missingSlots, orphanJustifications, hasRenumbering, changed };
      }
      async normalizeAllScores() {
        const beatsToNormalize = this.plotBeats.filter((beat) => beat.path);
        const normalizationIssues = [];
        for (const beat of beatsToNormalize) {
          if (!beat.path) continue;
          const file = this.plugin.app.vault.getAbstractFileByPath(beat.path);
          if (!file || !(file instanceof import_obsidian2.TFile)) continue;
          const cache = this.plugin.app.metadataCache.getFileCache(file);
          const fm = cache == null ? void 0 : cache.frontmatter;
          if (!fm) continue;
          const analysis = this.analyzeNormalizationFrontmatter(fm, beat.title || beat.path);
          if (analysis.changed) {
            normalizationIssues.push(analysis);
          }
        }
        const confirmMessage = normalizationIssues.length > 0 ? `Will renumber and clean ${normalizationIssues.length} beat${normalizationIssues.length === 1 ? "" : "s"} with gaps or orphaned justifications. Back up your vault before running cleanup as a safety measure.` : "No numbering gaps or orphaned Gossamer justifications were detected. Back up your vault before running cleanup.";
        new NormalizeConfirmationModal(
          this.app,
          confirmMessage,
          normalizationIssues,
          async () => {
            let changedCount = 0;
            for (const beat of beatsToNormalize) {
              if (!beat.path) continue;
              const file = this.plugin.app.vault.getAbstractFileByPath(beat.path);
              if (!file || !(file instanceof import_obsidian2.TFile)) continue;
              await this.plugin.app.fileManager.processFrontMatter(file, (yaml) => {
                const fm = yaml;
                const { normalized, changed } = normalizeGossamerHistory(fm);
                if (changed) {
                  changedCount++;
                  for (let i = 1; i <= 40; i++) {
                    delete fm[`Gossamer${i}`];
                    delete fm[`Gossamer${i} Justification`];
                  }
                  Object.assign(fm, normalized);
                }
              });
            }
            if (changedCount > 0) {
              new import_obsidian2.Notice(`Normalized Gossamer scores in ${changedCount} beat${changedCount === 1 ? "" : "s"}.`);
              this.close();
              const refreshed = new _GossamerScoreModal(this.app, this.plugin, this.plotBeats);
              refreshed.open();
            } else {
              new import_obsidian2.Notice("No fragmented scores detected.");
            }
          }
        ).open();
      }
      // Helper to create Lucide circle-x SVG icon
      createCircleXIcon() {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("width", "14");
        svg.setAttribute("height", "14");
        svg.setAttribute("viewBox", "0 0 24 24");
        svg.setAttribute("fill", "none");
        svg.setAttribute("stroke", "currentColor");
        svg.setAttribute("stroke-width", "2");
        svg.setAttribute("stroke-linecap", "round");
        svg.setAttribute("stroke-linejoin", "round");
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", "12");
        circle.setAttribute("cy", "12");
        circle.setAttribute("r", "10");
        circle.setAttribute("stroke-width", "2");
        svg.appendChild(circle);
        const line1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line1.setAttribute("x1", "15");
        line1.setAttribute("y1", "9");
        line1.setAttribute("x2", "9");
        line1.setAttribute("y2", "15");
        svg.appendChild(line1);
        const line2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line2.setAttribute("x1", "9");
        line2.setAttribute("y1", "9");
        line2.setAttribute("x2", "15");
        line2.setAttribute("y2", "15");
        svg.appendChild(line2);
        return svg;
      }
      onOpen() {
        var _a;
        const { contentEl, modalEl } = this;
        contentEl.empty();
        if (modalEl) {
          modalEl.style.width = "980px";
          modalEl.style.maxWidth = "98vw";
          modalEl.style.maxHeight = "92vh";
          modalEl.classList.add("rt-modal-shell");
        }
        contentEl.addClass("rt-modal-container", "rt-gossamer-score-modal");
        const settingsSystem = this.plugin.settings.beatSystem || "Save The Cat";
        const filteredBeats = this.plotBeats.filter((beat) => {
          if (!beat.path) return false;
          const file = this.plugin.app.vault.getAbstractFileByPath(beat.path);
          if (!file) return false;
          const cache = this.plugin.app.metadataCache.getFileCache(file);
          const fm = cache == null ? void 0 : cache.frontmatter;
          const beatModel = fm == null ? void 0 : fm["Beat Model"];
          if (settingsSystem === "Custom") {
            const customName = this.plugin.settings.customBeatSystemName;
            if (customName && beatModel === customName) {
              return true;
            }
            const recognizedSystems = ["Save The Cat", "Hero's Journey", "Story Grid"];
            return !beatModel || !recognizedSystems.includes(beatModel);
          } else {
            return beatModel === settingsSystem;
          }
        });
        this.plotBeats = filteredBeats;
        let plotSystemTemplate = getPlotSystem(settingsSystem);
        if (settingsSystem === "Custom" && this.plugin.settings.customBeatSystemName && ((_a = this.plugin.settings.customBeatSystemBeats) == null ? void 0 : _a.length)) {
          plotSystemTemplate = {
            name: this.plugin.settings.customBeatSystemName,
            // Persisted beats are objects ({ name, act }); template expects names
            beats: this.plugin.settings.customBeatSystemBeats.map((b) => b.name),
            beatDetails: this.plugin.settings.customBeatSystemBeats.map((b) => ({ name: b.name, description: "", range: "" })),
            beatCount: this.plugin.settings.customBeatSystemBeats.length
          };
        }
        const actualCount = filteredBeats.length;
        const countMismatch = plotSystemTemplate ? actualCount !== (plotSystemTemplate.beatCount || plotSystemTemplate.beats.length) : false;
        const headerEl = contentEl.createDiv({ cls: "rt-modal-header" });
        headerEl.createSpan({ text: "Gossamer momentum", cls: "rt-modal-badge" });
        headerEl.createDiv({ text: `${settingsSystem} beat system`, cls: "rt-modal-title" });
        const heroSubtitle = headerEl.createDiv({ cls: "rt-modal-subtitle" });
        heroSubtitle.setText("Enter momentum scores (0-100) for each beat. Previous scores will be saved as history.");
        const heroMeta = headerEl.createDiv({ cls: "rt-modal-meta" });
        heroMeta.createSpan({ text: `Beats detected: ${actualCount}`, cls: "rt-modal-meta-item" });
        if (actualCount === 0) {
          const noBeatsWarning = contentEl.createEl("div", {
            text: settingsSystem === "Custom" ? `\u26A0\uFE0F No custom story beats found. Create notes with "Class: Beat" without "Beat Model" field, or change beat system in Settings.` : `\u26A0\uFE0F No story beats found with "Beat Model: ${settingsSystem}". Check your beat notes have the correct Beat Model field, or change beat system in Settings.`
          });
          noBeatsWarning.addClass("rt-gossamer-warning");
        } else if (countMismatch && plotSystemTemplate) {
          const warningEl = contentEl.createEl("div", {
            text: `\u26A0\uFE0F Expected ${plotSystemTemplate.beatCount} beats for ${settingsSystem}, but found ${actualCount} story beats with matching Beat Model. Check your vault.`
          });
          warningEl.addClass("rt-gossamer-warning");
        }
        const scoresContainer = contentEl.createDiv("rt-container");
        this.buildEntries();
        this.entries.forEach((entry, index) => {
          const entryDiv = scoresContainer.createDiv("rt-gossamer-score-entry");
          const firstRow = entryDiv.createDiv("rt-gossamer-score-row");
          const titleContainer = firstRow.createDiv("rt-gossamer-beat-title-container");
          const beatTitleEl = titleContainer.createEl("span", { text: entry.beatTitle });
          beatTitleEl.addClass("rt-gossamer-beat-title");
          if (entry.range) {
            const rangeEl = titleContainer.createEl("span", { text: ` (${entry.range})` });
            rangeEl.addClass("rt-gossamer-beat-range");
          }
          const justificationContainer = firstRow.createDiv("rt-gossamer-justification-container");
          if (entry.currentJustification) {
            const currentNote = justificationContainer.createDiv("rt-gossamer-current-justification");
            currentNote.setText(`${entry.currentJustification}`);
          }
          const inputContainer = firstRow.createDiv("rt-gossamer-input-container");
          const inputLabel = inputContainer.createSpan({ text: "Enter score" });
          inputLabel.addClass("rt-gossamer-input-label");
          entry.inputEl = new import_obsidian2.TextComponent(inputContainer);
          entry.inputEl.inputEl.addClass("rt-gossamer-score-input");
          entry.inputEl.setPlaceholder("0-100");
          entry.inputEl.onChange((value) => {
            var _a2, _b, _c;
            const num = parseInt(value);
            if (!isNaN(num) && num >= 0 && num <= 100) {
              entry.newScore = num;
              (_a2 = entry.inputEl) == null ? void 0 : _a2.inputEl.removeClass("rt-input-error");
            } else if (value.trim().length > 0) {
              (_b = entry.inputEl) == null ? void 0 : _b.inputEl.addClass("rt-input-error");
              entry.newScore = void 0;
            } else {
              (_c = entry.inputEl) == null ? void 0 : _c.inputEl.removeClass("rt-input-error");
              entry.newScore = void 0;
            }
          });
          const secondRow = entryDiv.createDiv("rt-gossamer-scores-history-row");
          const existingScoresEl = secondRow.createDiv("rt-gossamer-existing-scores-container");
          entry.scoreDisplayEl = existingScoresEl;
          const renderScores = () => {
            existingScoresEl.empty();
            const createScoreCard = (gossamerNum, score, justification) => {
              const scoreContainer = existingScoresEl.createDiv();
              scoreContainer.addClass("rt-gossamer-score-item-container");
              scoreContainer.setAttribute("data-gossamer-num", gossamerNum.toString());
              const headerRow = scoreContainer.createDiv("rt-gossamer-score-header");
              const iconColumn = headerRow.createDiv();
              iconColumn.addClass("rt-gossamer-icon-column");
              iconColumn.appendChild(this.createCircleXIcon());
              headerRow.createSpan({
                text: `G${gossamerNum}`,
                cls: "rt-gossamer-score-label"
              });
              headerRow.createSpan({
                text: `${score}`,
                cls: "rt-gossamer-score-value"
              });
              if (justification) {
                const justEl = scoreContainer.createDiv({
                  text: justification,
                  cls: "rt-gossamer-score-justification"
                });
                tooltip(justEl, justification, "bottom");
              }
              scoreContainer.addEventListener("click", () => {
                entry.scoresToDelete.add(gossamerNum);
                renderScores();
              });
            };
            const totalScores = (entry.currentScore !== void 0 && entry.currentIndex !== void 0 && !entry.scoresToDelete.has(entry.currentIndex) ? 1 : 0) + entry.history.filter((item) => !entry.scoresToDelete.has(item.index)).length;
            entry.history.forEach((item) => {
              if (entry.scoresToDelete.has(item.index)) return;
              createScoreCard(item.index, item.value, item.justification);
            });
            if (entry.currentScore !== void 0 && entry.currentIndex !== void 0 && !entry.scoresToDelete.has(entry.currentIndex)) {
              createScoreCard(entry.currentIndex, entry.currentScore, entry.currentJustification);
            }
            if (totalScores > 10) {
              const countSpan = existingScoresEl.createSpan({
                text: `(${totalScores} scores)`,
                cls: "rt-gossamer-score-count"
              });
            }
          };
          renderScores();
        });
        const buttonContainer = contentEl.createDiv("rt-modal-actions");
        const topActions = buttonContainer.createDiv("rt-gossamer-actions-top");
        const bottomActions = buttonContainer.createDiv("rt-gossamer-actions-bottom");
        const pasteBtn = new import_obsidian2.ButtonComponent(topActions).setButtonText("Paste scores").onClick(async () => {
          await this.pasteFromClipboard();
        });
        const copyBtn = new import_obsidian2.ButtonComponent(topActions).setButtonText("Copy template for AI").setTooltip("Copy beat names in AI-ready format").onClick(async () => {
          await this.copyTemplateForAI();
        });
        const toggleLabel = topActions.createEl("label", { cls: "rt-gossamer-copy-toggle" });
        const toggleInput = toggleLabel.createEl("input", { type: "checkbox" });
        toggleInput.checked = this.includeBeatDescriptions;
        toggleInput.addEventListener("change", () => {
          this.includeBeatDescriptions = toggleInput.checked;
        });
        toggleLabel.createSpan({ text: "Include beat descriptions when copying template" });
        const normalizeBtn = new import_obsidian2.ButtonComponent(bottomActions).setButtonText("Normalize history").setTooltip("Remove gaps and orphaned notes from Gossamer runs").onClick(async () => {
          await this.normalizeAllScores();
        });
        const saveBtn = new import_obsidian2.ButtonComponent(bottomActions).setButtonText("Save scores").setCta().onClick(async () => {
          await this.saveScores();
        });
        const deleteBtn = new import_obsidian2.ButtonComponent(bottomActions).setButtonText("Delete scores").setWarning().onClick(async () => {
          await this.deleteAllScores();
        });
        const cancelBtn = new import_obsidian2.ButtonComponent(bottomActions).setButtonText("Cancel").onClick(() => {
          this.close();
        });
        tooltipForComponent(pasteBtn, "Paste scores from clipboard", "bottom");
        tooltipForComponent(copyBtn, "Copy beat names for AI prompts", "bottom");
        tooltip(toggleLabel, "Include beat descriptions when copying template", "bottom");
        tooltipForComponent(normalizeBtn, "Cleanup score history gaps", "bottom");
        tooltipForComponent(saveBtn, "Save new scores and deletions", "bottom");
        tooltipForComponent(deleteBtn, "Delete all scores for these beats", "bottom");
        tooltipForComponent(cancelBtn, "Close without saving", "bottom");
      }
      buildEntries() {
        const sortedBeats = [...this.plotBeats].sort((a, b) => {
          const aMatch = (a.title || "").match(/^(\d+(?:\.\d+)?)/);
          const bMatch = (b.title || "").match(/^(\d+(?:\.\d+)?)/);
          const aNum = aMatch ? parseFloat(aMatch[1]) : 0;
          const bNum = bMatch ? parseFloat(bMatch[1]) : 0;
          return aNum - bNum;
        });
        for (const beat of sortedBeats) {
          if (!beat.title || !beat.path) continue;
          const file = this.plugin.app.vault.getAbstractFileByPath(beat.path);
          if (!file) continue;
          const cache = this.plugin.app.metadataCache.getFileCache(file);
          const fm = cache == null ? void 0 : cache.frontmatter;
          const entry = {
            beatTitle: beat.title,
            beatName: normalizeBeatName(beat.title),
            beatPath: beat.path,
            history: [],
            scoresToDelete: /* @__PURE__ */ new Set()
          };
          if (fm) {
            if (typeof fm.Range === "string") {
              entry.range = fm.Range;
            }
            if (typeof fm.Description === "string") {
              entry.description = fm.Description;
            } else if (typeof fm.description === "string") {
              entry.description = fm.description;
            }
            const scores = [];
            let hasAnyScores = false;
            for (let i = 1; i <= 30; i++) {
              const key = `Gossamer${i}`;
              const value = fm[key];
              let numeric;
              if (typeof value === "number") {
                numeric = value;
              } else if (typeof value === "string") {
                const parsed = parseInt(value);
                if (!isNaN(parsed)) numeric = parsed;
              }
              if (numeric !== void 0) {
                hasAnyScores = true;
                const justificationKey = `Gossamer${i} Justification`;
                const justificationValue = fm[justificationKey];
                scores.push({ index: i, value: numeric });
                if (typeof justificationValue === "string" && justificationValue.trim().length > 0) {
                  scores[scores.length - 1].justification = justificationValue;
                }
              } else {
                const orphanJustKey = `Gossamer${i} Justification`;
                if (typeof fm[orphanJustKey] === "string") {
                }
              }
            }
            if (hasAnyScores && scores.length > 0) {
              const latest = scores[scores.length - 1];
              entry.currentScore = latest.value;
              entry.currentIndex = latest.index;
              entry.currentJustification = latest.justification;
              entry.history = scores.slice(0, -1);
            }
          }
          this.entries.push(entry);
        }
      }
      async copyTemplateForAI() {
        try {
          const settingsSystem = this.plugin.settings.beatSystem || "Save The Cat";
          const { name: contextTemplateName, prompt: contextPrompt } = this.getActiveAiContextInfo();
          const lines = [];
          lines.push(`# Beat Momentum Scores (0-100) \u2014 ${settingsSystem}`);
          lines.push("");
          if (contextPrompt) {
            lines.push("## Role & Manuscript Context");
            if (contextTemplateName) {
              lines.push(`Template: ${contextTemplateName}`);
            }
            lines.push(contextPrompt.trim());
            lines.push("Consult the complete manuscript and knowledge base for this project before assigning momentum scores.");
            lines.push("");
          }
          if (this.entries.length === 0) {
            new import_obsidian2.Notice("No beats available to copy. Add Beat notes with the selected Beat Model first.");
            return;
          }
          lines.push("## Story Beats Template Guidance");
          lines.push(this.includeBeatDescriptions ? "Descriptions are pulled directly from each beat note's Description field." : "Update each beat note's Range and Description fields to customize this list. Toggle above to include descriptions.");
          lines.push("");
          const missingRangeBeats = [];
          const missingDescriptionBeats = [];
          this.entries.forEach((entry, index) => {
            const metadataParts = [];
            if (entry.range && entry.range.trim().length > 0) {
              metadataParts.push(`Ideal momentum: ${entry.range}`);
            } else {
              missingRangeBeats.push(entry.beatTitle);
            }
            const metadata = metadataParts.length > 0 ? ` (${metadataParts.join(" \u2022 ")})` : "";
            lines.push(`${index + 1}. ${entry.beatTitle}${metadata}`);
            if (this.includeBeatDescriptions) {
              if (entry.description && entry.description.trim().length > 0) {
                lines.push(`   ${entry.description.trim()}`);
              } else {
                missingDescriptionBeats.push(entry.beatTitle);
              }
            }
            lines.push("");
          });
          lines.push("## Momentum Scale:");
          lines.push("- 0-20: Quiet, establishing, low tension");
          lines.push("- 21-40: Building, complications emerging");
          lines.push("- 41-60: Rising stakes, conflict developing");
          lines.push("- 61-80: High tension, major conflicts");
          lines.push("- 81-100: Peak tension, climactic moments");
          lines.push("");
          lines.push("## Consider for each beat:");
          lines.push("- Tension and conflict level");
          lines.push("- Stakes for protagonist");
          lines.push("- Emotional intensity");
          lines.push("- Pacing and urgency");
          lines.push("");
          lines.push("## Output Instructions:");
          lines.push('- Respond with the block titled "## Completed Momentum Scores" exactly as shown below.');
          lines.push("- Replace the blank after each colon with a single integer from 0-100 (no percentage signs or trailing commentary).");
          lines.push("- Keep the beat order identical so the response can be copied directly into the Obsidian modal.");
          lines.push("- Favor the ideal range when it fits the manuscript context, but you may go outside the range if justified by the story.");
          lines.push("");
          lines.push("## Completed Momentum Scores");
          lines.push("");
          for (const entry of this.entries) {
            if (entry.range) {
              lines.push(`${entry.beatTitle} (ideal: ${entry.range}): `);
            } else {
              lines.push(`${entry.beatTitle}: `);
            }
          }
          lines.push("");
          lines.push('# Note: After filling in the numbers, return ONLY the "Completed Momentum Scores" block so it can be pasted back into Obsidian.');
          const template = lines.join("\n");
          await navigator.clipboard.writeText(template);
          new import_obsidian2.Notice("\u2713 Template copied! Paste into your AI and have it fill in the scores.");
          if (missingRangeBeats.length > 0) {
            this.showMetadataWarning("Range", missingRangeBeats);
          }
          if (this.includeBeatDescriptions && missingDescriptionBeats.length > 0) {
            this.showMetadataWarning("Description", missingDescriptionBeats);
          }
        } catch (error) {
          console.error("[Gossamer] Failed to copy template:", error);
          new import_obsidian2.Notice("Failed to copy template to clipboard.");
        }
      }
      async pasteFromClipboard() {
        var _a;
        try {
          const clipboard = await navigator.clipboard.readText();
          const parsedScores = parseScoresFromClipboard(clipboard);
          if (parsedScores.size === 0) {
            new import_obsidian2.Notice('No scores found in clipboard. Expected format: "1: 15, 2: 25" or "Beat Name: 42"');
            return;
          }
          const isPositionalFormat = (_a = Array.from(parsedScores.keys())[0]) == null ? void 0 : _a.startsWith("__position_");
          let matchCount = 0;
          if (isPositionalFormat) {
            for (let i = 0; i < this.entries.length; i++) {
              const entry = this.entries[i];
              const position = i + 1;
              const score = parsedScores.get(`__position_${position}`);
              if (score !== void 0 && entry.inputEl) {
                entry.inputEl.setValue(score.toString());
                entry.newScore = score;
                entry.inputEl.inputEl.removeClass("rt-input-error");
                matchCount++;
              }
            }
            const expectedCount = this.entries.length;
            if (matchCount < expectedCount) {
              new import_obsidian2.Notice(`\u26A0\uFE0F Warning: Pasted ${matchCount} scores but expected ${expectedCount}. Some beats may be missing scores.`);
            } else {
              new import_obsidian2.Notice(`\u2713 Populated all ${matchCount} scores from clipboard.`);
            }
          } else {
            for (const entry of this.entries) {
              const normalized = normalizeBeatName(entry.beatName);
              let score = parsedScores.get(normalized);
              if (score === void 0) {
                const normalizedLower = normalized.toLowerCase();
                for (const [key, value] of parsedScores.entries()) {
                  if (key.toLowerCase() === normalizedLower) {
                    score = value;
                    break;
                  }
                }
              }
              if (score !== void 0 && entry.inputEl) {
                entry.inputEl.setValue(score.toString());
                entry.newScore = score;
                entry.inputEl.inputEl.removeClass("rt-input-error");
                matchCount++;
              }
            }
            new import_obsidian2.Notice(`Populated ${matchCount} scores from clipboard.`);
          }
        } catch (error) {
          console.error("[Gossamer] Failed to paste from clipboard:", error);
          new import_obsidian2.Notice("Failed to read clipboard.");
        }
      }
      async saveScores() {
        const scores = /* @__PURE__ */ new Map();
        const deletions = /* @__PURE__ */ new Map();
        const errors = [];
        for (const entry of this.entries) {
          if (entry.newScore !== void 0) {
            scores.set(entry.beatTitle, entry.newScore);
          } else if (entry.inputEl && entry.inputEl.getValue().trim().length > 0) {
            errors.push(`Invalid score for "${entry.beatTitle}"`);
          }
          if (entry.scoresToDelete.size > 0) {
            deletions.set(entry.beatTitle, entry.scoresToDelete);
          }
        }
        if (errors.length > 0) {
          new import_obsidian2.Notice(`Errors: ${errors.join(", ")}`);
          return;
        }
        if (scores.size === 0 && deletions.size === 0) {
          new import_obsidian2.Notice("No changes to save.");
          return;
        }
        try {
          if (scores.size > 0) {
            await this.plugin.saveGossamerScores(scores);
          }
          if (deletions.size > 0) {
            await this.processDeletions(deletions);
          }
          const changeCount = scores.size + deletions.size;
          new import_obsidian2.Notice(`Updated ${changeCount} beat(s).`);
          this.close();
        } catch (error) {
          console.error("[Gossamer] Failed to save scores:", error);
          new import_obsidian2.Notice("Failed to save scores. Check console for details.");
        }
      }
      async processDeletions(deletions) {
        const sourcePath = this.plugin.settings.sourcePath || "";
        const allFiles = this.plugin.app.vault.getMarkdownFiles();
        const files = sourcePath ? allFiles.filter((f) => f.path.startsWith(sourcePath)) : allFiles;
        for (const [beatTitle, gossamerNums] of deletions) {
          let file = null;
          for (const f of files) {
            if (f.basename === beatTitle || f.basename === beatTitle.replace(/^\d+\s+/, "")) {
              const cache = this.plugin.app.metadataCache.getFileCache(f);
              const fm = cache == null ? void 0 : cache.frontmatter;
              if (fm && (fm.Class === "Beat" || fm.Class === "Plot")) {
                file = f;
                break;
              }
            }
          }
          if (!file) {
            continue;
          }
          try {
            await this.plugin.app.fileManager.processFrontMatter(file, (yaml) => {
              const fm = yaml;
              for (const num of gossamerNums) {
                delete fm[`Gossamer${num}`];
                delete fm[`Gossamer${num} Justification`];
              }
            });
          } catch (error) {
            console.error(`[Gossamer] Failed to delete scores for ${beatTitle}:`, error);
          }
        }
      }
      async deleteAllScores() {
        const sourcePath = this.plugin.settings.sourcePath || "";
        const allFiles = this.plugin.app.vault.getMarkdownFiles();
        const files = sourcePath ? allFiles.filter((f) => f.path.startsWith(sourcePath)) : allFiles;
        let hasAnyScores = false;
        for (const file of files) {
          const cache = this.plugin.app.metadataCache.getFileCache(file);
          const fm = cache == null ? void 0 : cache.frontmatter;
          if (fm && (fm.Class === "Beat" || fm.class === "Beat")) {
            for (let i = 1; i <= 30; i++) {
              if (fm[`Gossamer${i}`] !== void 0) {
                hasAnyScores = true;
                break;
              }
            }
            if (hasAnyScores) break;
          }
        }
        if (!hasAnyScores) {
          new import_obsidian2.Notice("No Gossamer scores found to delete.");
          return;
        }
        const confirmed = await new Promise((resolve) => {
          const modal = new import_obsidian2.Modal(this.app);
          const { modalEl, contentEl } = modal;
          modal.titleEl.setText("");
          contentEl.empty();
          modalEl.classList.add("rt-modal-shell");
          contentEl.addClass("rt-modal-container", "rt-gossamer-score-modal");
          const hero = contentEl.createDiv({ cls: "rt-modal-header" });
          hero.createSpan({ text: "Warning", cls: "rt-modal-badge" });
          hero.createDiv({ text: "Delete all Gossamer scores", cls: "rt-modal-title" });
          hero.createDiv({ cls: "rt-modal-subtitle", text: "This action cannot be undone." });
          const card = contentEl.createDiv({ cls: "rt-glass-card" });
          const warningEl = card.createDiv({
            text: "This will permanently delete ALL Gossamer scores (Gossamer1-30) and their justifications from ALL Beat notes.",
            cls: "rt-gossamer-confirm-warning"
          });
          const buttonContainer = contentEl.createDiv({
            cls: ["rt-modal-actions", "rt-inline-actions"]
          });
          new import_obsidian2.ButtonComponent(buttonContainer).setButtonText("Delete all scores").setWarning().onClick(async () => {
            modal.close();
            resolve(true);
          });
          new import_obsidian2.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => {
            modal.close();
            resolve(false);
          });
          modal.open();
        });
        if (!confirmed) return;
        try {
          let deletedCount = 0;
          for (const file of files) {
            const cache = this.plugin.app.metadataCache.getFileCache(file);
            const fm = cache == null ? void 0 : cache.frontmatter;
            if (fm && (fm.Class === "Beat" || fm.class === "Beat")) {
              let hasGossamerScores = false;
              for (let i = 1; i <= 30; i++) {
                if (fm[`Gossamer${i}`] !== void 0) {
                  hasGossamerScores = true;
                  break;
                }
              }
              if (hasGossamerScores) {
                await this.plugin.app.fileManager.processFrontMatter(file, (yaml) => {
                  const frontmatter = yaml;
                  for (let i = 1; i <= 30; i++) {
                    delete frontmatter[`Gossamer${i}`];
                    delete frontmatter[`Gossamer${i} Justification`];
                  }
                  delete frontmatter["Gossamer Last Updated"];
                });
                deletedCount++;
              }
            }
          }
          new import_obsidian2.Notice(`\u2713 Deleted all Gossamer scores and justifications from ${deletedCount} Beat note(s).`);
          this.close();
        } catch (error) {
          console.error("[Gossamer] Failed to delete all scores:", error);
          new import_obsidian2.Notice("Failed to delete all scores. Check console for details.");
        }
      }
      showMetadataWarning(field, beats) {
        const preview = beats.slice(0, 3).join(", ");
        const remainder = beats.length > 3 ? `, +${beats.length - 3} more` : "";
        new import_obsidian2.Notice(`Missing ${field} in Beat frontmatter for: ${preview}${remainder}. Update the beat notes to customize the AI template.`);
      }
      getActiveAiContextInfo() {
        const templates = this.plugin.settings.aiContextTemplates || [];
        const activeId = this.plugin.settings.activeAiContextTemplateId;
        const active = templates.find((t2) => t2.id === activeId) || templates[0];
        if (active) {
          return { name: active.name, prompt: active.prompt };
        }
        return {
          name: "Generic Editor",
          prompt: "Act as a developmental editor evaluating narrative momentum, emotional stakes, and pacing across the manuscript beats."
        };
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    NormalizeConfirmationModal = class extends import_obsidian2.Modal {
      constructor(app, message, issues, onConfirm) {
        super(app);
        this.message = message;
        this.issues = issues;
        this.onConfirm = onConfirm;
      }
      onOpen() {
        const { contentEl, modalEl, titleEl } = this;
        titleEl.setText("");
        contentEl.empty();
        if (modalEl) {
          modalEl.classList.add("rt-modal-shell");
        }
        contentEl.addClass("rt-modal-container", "rt-gossamer-score-modal");
        const hero = contentEl.createDiv({ cls: "rt-modal-header" });
        hero.createSpan({ text: "Warning", cls: "rt-modal-badge" });
        hero.createDiv({ text: "Normalize Gossamer history?", cls: "rt-modal-title" });
        hero.createDiv({ cls: "rt-modal-subtitle", text: "This action cannot be undone." });
        const card = contentEl.createDiv({ cls: "rt-glass-card" });
        card.createDiv({ cls: "rt-purge-message" }).setText(this.message);
        if (this.issues.length > 0) {
          const issuesEl = card.createDiv({ cls: "rt-purge-issues" });
          issuesEl.createEl("h3", { text: "Beats to normalize", cls: "rt-purge-issues-title" });
          const listEl = issuesEl.createEl("ul", { cls: "rt-purge-issues-list" });
          const preview = this.issues.slice(0, 6);
          preview.forEach((issue) => {
            const item = listEl.createEl("li", { cls: "rt-purge-issues-item" });
            item.createEl("strong", { text: issue.beatTitle });
            const details = [];
            if (issue.missingSlots.length > 0) {
              const gapLabel = issue.missingSlots.length === 1 ? "Gap" : "Gaps";
              const gapList = issue.missingSlots.map((slot) => `G${slot}`).join(", ");
              details.push(`${gapLabel}: ${gapList}`);
            } else if (issue.hasRenumbering) {
              details.push("Out-of-order numbering");
            }
            if (issue.orphanJustifications.length > 0) {
              const orphanList = issue.orphanJustifications.map((slot) => `G${slot}`).join(", ");
              details.push(`Orphaned justification${issue.orphanJustifications.length === 1 ? "" : "s"}: ${orphanList}`);
            }
            item.createSpan({ text: details.join(" \u2022 ") || "Will compact numbering" });
          });
          if (this.issues.length > preview.length) {
            issuesEl.createDiv({
              cls: "rt-purge-issues-footnote",
              text: `+${this.issues.length - preview.length} more beat${this.issues.length - preview.length === 1 ? "" : "s"} will be cleaned.`
            });
          }
        } else {
          card.createDiv({
            cls: "rt-purge-message rt-purge-message-secondary",
            text: "No gaps detected. Normalization will simply compact numbering and remove stray justification fields."
          });
        }
        const warningEl = card.createDiv({ cls: "rt-pulse-warning" });
        warningEl.createEl("strong", { text: "Are you sure you want to proceed?" });
        const buttonRow = contentEl.createDiv({ cls: ["rt-modal-actions", "rt-inline-actions"] });
        new import_obsidian2.ButtonComponent(buttonRow).setButtonText("Normalize").setWarning().onClick(() => {
          this.close();
          this.onConfirm();
        });
        new import_obsidian2.ButtonComponent(buttonRow).setButtonText("Cancel").onClick(() => this.close());
      }
    };
  }
});

// src/utils/modelResolver.ts
function getModelDisplayName(modelId) {
  if (!modelId) return "Unknown Model";
  const cached = resolvedModelCache.get(modelId);
  if (cached) {
    return cached.displayName;
  }
  if (LATEST_ALIAS_DISPLAY_NAMES[modelId]) {
    return LATEST_ALIAS_DISPLAY_NAMES[modelId];
  }
  return formatModelName(modelId);
}
function formatModelName(modelId) {
  var _a;
  if (modelId.startsWith("claude-")) {
    const match = modelId.match(/claude-(\w+)-(\d+)-(\d+)-\d+/);
    if (match) {
      const variant = match[1].charAt(0).toUpperCase() + match[1].slice(1);
      return `Claude ${variant} ${match[2]}.${match[3]}`;
    }
    const match2 = modelId.match(/claude-(\w+)-(\d+)-(\d+)/);
    if (match2) {
      const variant = match2[1].charAt(0).toUpperCase() + match2[1].slice(1);
      return `Claude ${variant} ${match2[2]}.${match2[3]}`;
    }
  }
  if (modelId.startsWith("gemini-")) {
    const parts = modelId.replace("gemini-", "").split("-");
    return "Gemini " + parts.map(
      (p) => p.charAt(0).toUpperCase() + p.slice(1)
    ).join(" ");
  }
  if (modelId.startsWith("gpt-")) {
    const version = (_a = modelId.match(/gpt-(\d+\.?\d*)/)) == null ? void 0 : _a[1];
    if (version) return `GPT-${version}`;
  }
  return modelId.replace(/-/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
}
function cacheResolvedModel(aliasId, resolvedModelId) {
  if (!aliasId || !resolvedModelId || aliasId === resolvedModelId) return;
  const displayName = `${formatModelName(resolvedModelId)} (via ${aliasId.includes("latest") ? "latest" : "alias"})`;
  resolvedModelCache.set(aliasId, {
    resolvedTo: resolvedModelId,
    displayName,
    updatedAt: Date.now()
  });
}
function isLatestAlias(modelId) {
  return modelId.includes("latest");
}
var LATEST_ALIAS_DISPLAY_NAMES, resolvedModelCache;
var init_modelResolver = __esm({
  "src/utils/modelResolver.ts"() {
    LATEST_ALIAS_DISPLAY_NAMES = {
      // Gemini
      "gemini-pro-latest": "Gemini Pro (Latest)",
      "gemini-flash-latest": "Gemini Flash (Latest)",
      "gemini-flash-lite-latest": "Gemini Flash Lite (Latest)",
      // OpenAI
      "gpt-5.2-chat-latest": "GPT-5.2 (Latest)",
      "gpt-5.1-chat-latest": "GPT-5.1 (Latest)",
      "gpt-5-chat-latest": "GPT-5 (Latest)",
      "chatgpt-4o-latest": "ChatGPT-4o (Latest)"
    };
    resolvedModelCache = /* @__PURE__ */ new Map();
  }
});

// src/modals/GossamerProcessingModal.ts
var import_obsidian3, GossamerProcessingModal;
var init_GossamerProcessingModal = __esm({
  "src/modals/GossamerProcessingModal.ts"() {
    import_obsidian3 = require("obsidian");
    init_modelResolver();
    GossamerProcessingModal = class extends import_obsidian3.Modal {
      constructor(app, plugin, onConfirm) {
        super(app);
        this.isProcessing = false;
        this.analysisOptions = {
          requestScores: true
        };
        this.currentStatus = "Initializing...";
        this.plugin = plugin;
        this.onConfirm = onConfirm;
      }
      onOpen() {
        const { contentEl, titleEl, modalEl } = this;
        titleEl.setText("");
        if (modalEl) {
          modalEl.classList.add("rt-modal-shell");
          modalEl.style.width = "800px";
          modalEl.style.maxWidth = "90vw";
          modalEl.style.maxHeight = "92vh";
        }
        contentEl.addClass("rt-modal-container", "rt-gossamer-processing-modal");
        this.showConfirmationView();
      }
      renderProcessingHero(parent, subtitle, modelName) {
        const hero = parent.createDiv({ cls: "rt-modal-header" });
        const badgeText = modelName ? `AI momentum analysis \xB7 ${modelName}` : "AI momentum analysis";
        hero.createSpan({ text: badgeText, cls: "rt-modal-badge" });
        hero.createDiv({ text: "Gossamer momentum analysis", cls: "rt-modal-title" });
        hero.createDiv({ text: subtitle, cls: "rt-modal-subtitle" });
      }
      onClose() {
        if (this.timerInterval) {
          window.clearInterval(this.timerInterval);
          this.timerInterval = void 0;
        }
      }
      /**
       * Override close() to allow minimizing while processing continues
       */
      close() {
        if (this.isProcessing) {
          new import_obsidian3.Notice("Analysis continues in background.");
        }
        super.close();
      }
      getActiveModelDisplayName() {
        const modelId = this.plugin.settings.geminiModelId || "gemini-pro-latest";
        return getModelDisplayName(modelId);
      }
      showConfirmationView() {
        const { contentEl } = this;
        contentEl.empty();
        const modelName = this.getActiveModelDisplayName();
        this.renderProcessingHero(contentEl, "Evaluate narrative momentum at each story beat. This will pass the entire manuscript to the AI, with instructions including the ideal beat ranges and context such as the previous score and justification. The AI will return a score and an updated justification for each beat.", modelName);
        this.confirmationView = contentEl;
        const card = contentEl.createDiv({ cls: "rt-glass-card" });
        const infoEl = card.createDiv();
        const beatSystemEl = infoEl.createDiv({ cls: "rt-gossamer-proc-beat-system-info" });
        beatSystemEl.setText("Gathering manuscript details...");
        const infoSection = card.createDiv({ cls: "rt-gossamer-proc-info-section" });
        infoSection.createEl("h3", { text: "Manuscript Information", cls: "rt-gossamer-proc-section-title" });
        this.manuscriptInfoEl = infoSection.createDiv({ cls: "rt-gossamer-proc-manuscript-info" });
        this.manuscriptInfoEl.setText("Gathering manuscript details...");
        if (!this.plugin.settings.geminiApiKey && this.plugin.settings.defaultAiProvider === "gemini") {
          const warningEl = card.createDiv({ cls: "rt-pulse-warning" });
          warningEl.setText("\u26A0\uFE0F Gemini API key not configured. Please set your API key in Settings \u2192 AI \u2192 Gemini API key.");
        }
        const buttonRow = contentEl.createDiv({ cls: "rt-modal-actions" });
        new import_obsidian3.ButtonComponent(buttonRow).setButtonText("Begin Analysis").setCta().onClick(async () => {
          await this.startProcessing();
        });
        new import_obsidian3.ButtonComponent(buttonRow).setButtonText("Cancel").onClick(() => this.close());
      }
      async startProcessing() {
        this.isProcessing = true;
        this.showProcessingView();
        try {
          await this.onConfirm(this.analysisOptions);
        } catch (error) {
          console.error("[Gossamer AI] Processing error:", error);
        }
      }
      showProcessingView() {
        const { contentEl } = this;
        contentEl.empty();
        const modelName = this.getActiveModelDisplayName();
        this.renderProcessingHero(contentEl, "Analyzing manuscript...", modelName);
        const bodyEl = contentEl.createDiv({ cls: "rt-pulse-progress-body" });
        const progressCard = bodyEl.createDiv({ cls: "rt-pulse-progress-card rt-glass-card" });
        const infoSection = progressCard.createDiv({ cls: "rt-gossamer-proc-info-section" });
        infoSection.createEl("h3", { text: "Manuscript Information", cls: "rt-gossamer-proc-section-title" });
        this.manuscriptInfoEl = infoSection.createDiv({ cls: "rt-gossamer-proc-manuscript-info" });
        this.manuscriptInfoEl.setText("Assembling manuscript...");
        const progressContainer = progressCard.createDiv({ cls: "rt-pulse-progress-container" });
        const progressBg = progressContainer.createDiv({ cls: "rt-pulse-progress-bg" });
        this.progressBarEl = progressBg.createDiv({ cls: "rt-pulse-progress-bar" });
        this.progressBarEl.style.setProperty("--progress-width", "0%");
        const statusSection = progressCard.createDiv({ cls: "rt-gossamer-proc-status-section" });
        statusSection.createEl("h3", { text: "Status", cls: "rt-gossamer-proc-section-title" });
        this.statusTextEl = statusSection.createDiv({ cls: "rt-gossamer-proc-status-text" });
        this.statusTextEl.setText(this.currentStatus);
        const apiSection = progressCard.createDiv({ cls: "rt-gossamer-proc-api-section" });
        apiSection.createEl("h3", { text: "API Activity", cls: "rt-gossamer-proc-section-title" });
        this.apiStatusEl = apiSection.createDiv({ cls: "rt-gossamer-proc-api-status" });
        this.apiStatusEl.setText("Waiting to send...");
        this.errorListEl = bodyEl.createDiv({ cls: "rt-pulse-error-list rt-glass-card rt-hidden" });
        const buttonContainer = contentEl.createDiv({ cls: "rt-modal-actions" });
        this.closeButtonEl = new import_obsidian3.ButtonComponent(buttonContainer).setButtonText("Close").setDisabled(true).onClick(() => this.close());
      }
      /**
       * Update manuscript assembly information
       */
      setManuscriptInfo(info) {
        var _a;
        this.manuscriptInfo = info;
        if (this.manuscriptInfoEl) {
          this.manuscriptInfoEl.empty();
          const stats = this.manuscriptInfoEl.createDiv({ cls: "rt-gossamer-proc-stats" });
          const createStat = (label, value) => {
            const item = stats.createDiv({ cls: "rt-gossamer-proc-stat-item" });
            item.createDiv({ cls: "rt-gossamer-proc-stat-label", text: label });
            item.createDiv({ cls: "rt-gossamer-proc-stat-value", text: value });
          };
          createStat("Scenes", info.totalScenes.toLocaleString());
          createStat("Words", info.totalWords.toLocaleString());
          createStat("Est. Tokens", `~${info.estimatedTokens.toLocaleString()}`);
          createStat("Story Beats", info.beatCount.toString());
          if (info.hasIterativeContext) {
            stats.createDiv({
              cls: "rt-gossamer-proc-stat-row rt-gossamer-proc-iterative-note",
              text: `Iterative refinement: Previous analysis will be sent for comparison`
            });
          }
        }
        const beatSystemInfoEl = (_a = this.confirmationView) == null ? void 0 : _a.querySelector(".rt-gossamer-proc-beat-system-info");
        if (beatSystemInfoEl) {
          beatSystemInfoEl.setText(`Beat System: ${info.beatSystem}`);
        }
      }
      /**
       * Update current status message
       */
      setStatus(status) {
        this.currentStatus = status;
        if (this.statusTextEl) {
          this.statusTextEl.setText(status);
        }
      }
      /**
       * Mark API call as started
       */
      apiCallStarted() {
        this.apiCallStartTime = Date.now();
        if (this.apiStatusEl) {
          this.apiStatusEl.empty();
          this.updateTimer();
          this.timerInterval = window.setInterval(() => {
            this.updateTimer();
          }, 1e3);
        }
        if (this.progressBarEl) {
          this.progressBarEl.addClass("rt-gossamer-progress-active");
          this.progressBarEl.style.setProperty("--progress-width", "50%");
        }
      }
      /**
       * Update elapsed time display
       */
      updateTimer() {
        if (!this.apiStatusEl || !this.apiCallStartTime) return;
        const elapsed = Math.floor((Date.now() - this.apiCallStartTime) / 1e3);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        const timeStr = minutes > 0 ? `${minutes}:${seconds.toString().padStart(2, "0")}` : `${seconds}s`;
        let message;
        if (elapsed < 30) {
          message = `Sending manuscript to AI... ${timeStr}`;
        } else if (elapsed < 60) {
          message = `Evaluating beats... ${timeStr}`;
        } else {
          message = `Preparing response... ${timeStr}`;
        }
        const estimate = elapsed < 90 ? " (typically 30-90 seconds)" : " (large manuscript)";
        this.apiStatusEl.setText(message + estimate);
      }
      /**
       * Mark API call as successful
       */
      apiCallSuccess() {
        if (this.timerInterval) {
          window.clearInterval(this.timerInterval);
          this.timerInterval = void 0;
        }
        const elapsed = this.apiCallStartTime ? ((Date.now() - this.apiCallStartTime) / 1e3).toFixed(1) : "?";
        if (this.apiStatusEl) {
          this.apiStatusEl.empty();
          this.apiStatusEl.setText(`\u2713 Response received (${elapsed}s)`);
        }
        if (this.progressBarEl) {
          this.progressBarEl.removeClass("rt-gossamer-progress-active");
          this.progressBarEl.addClass("rt-progress-complete");
          this.progressBarEl.style.setProperty("--progress-width", "100%");
        }
      }
      /**
       * Mark API call as failed with error
       */
      apiCallError(error) {
        if (this.timerInterval) {
          window.clearInterval(this.timerInterval);
          this.timerInterval = void 0;
        }
        if (this.apiStatusEl) {
          this.apiStatusEl.empty();
          this.apiStatusEl.setText(`\u2717 API call failed`);
        }
        if (this.progressBarEl) {
          this.progressBarEl.removeClass("rt-gossamer-progress-active");
          this.progressBarEl.addClass("rt-progress-complete");
          this.progressBarEl.style.setProperty("--progress-width", "0%");
        }
        this.addError(error);
      }
      /**
       * Add error message to error section (using Scene Analysis styling)
       */
      addError(message) {
        if (!this.errorListEl) return;
        if (this.errorListEl.hasClass("rt-hidden")) {
          this.errorListEl.removeClass("rt-hidden");
          const header = this.errorListEl.createDiv({ cls: "rt-gossamer-proc-error-header" });
          header.setText("Errors encountered:");
        }
        const errorItem = this.errorListEl.createDiv({ cls: "rt-gossamer-proc-error-item" });
        errorItem.setText(message);
      }
      /**
       * Mark processing as complete
       */
      completeProcessing(success, message) {
        this.isProcessing = false;
        if (this.statusTextEl) {
          this.statusTextEl.setText(message);
        }
        if (this.progressBarEl) {
          this.progressBarEl.removeClass("rt-gossamer-progress-active");
          this.progressBarEl.addClass("rt-progress-complete");
          if (success) {
            this.progressBarEl.style.setProperty("--progress-width", "100%");
          }
        }
        if (this.closeButtonEl) {
          this.closeButtonEl.setDisabled(false);
          if (success) {
            this.closeButtonEl.setCta();
          }
        }
      }
      /**
       * Show rate limit notification
       */
      showRateLimitWarning(retryAfter) {
        const message = retryAfter ? `Rate limit reached. Please try again in ${retryAfter} seconds.` : "Rate limit reached. Please try again later.";
        this.addError(message);
        if (this.apiStatusEl) {
          this.apiStatusEl.setText("\u26A0\uFE0F Rate limited");
        }
      }
    };
  }
});

// src/modes/ModeDefinition.ts
var ModeDefinition_exports = {};
__export(ModeDefinition_exports, {
  TimelineMode: () => TimelineMode,
  isTimelineMode: () => isTimelineMode
});
function isTimelineMode(value) {
  return Object.values(TimelineMode).includes(value);
}
var TimelineMode;
var init_ModeDefinition = __esm({
  "src/modes/ModeDefinition.ts"() {
    TimelineMode = /* @__PURE__ */ ((TimelineMode2) => {
      TimelineMode2["NARRATIVE"] = "narrative";
      TimelineMode2["SUBPLOT"] = "subplot";
      TimelineMode2["GOSSAMER"] = "gossamer";
      TimelineMode2["CHRONOLOGUE"] = "chronologue";
      return TimelineMode2;
    })(TimelineMode || {});
  }
});

// src/utils/svg.ts
function formatNumber(num) {
  if (Math.abs(num) < 1e-3) return "0";
  return num.toFixed(3).replace(/\.0+$/, "").replace(/\.$/, "");
}
function escapeXml(unsafe) {
  return unsafe.replace(/&(?!(amp;|lt;|gt;|quot;|apos;|#\d+;|#x[0-9a-fA-F]+;))/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
var init_svg = __esm({
  "src/utils/svg.ts"() {
  }
});

// src/renderer/layout/LayoutConstants.ts
var SVG_SIZE, VERSION_INDICATOR_POS_X, VERSION_INDICATOR_POS_Y, HELP_ICON_POS_X, HELP_ICON_POS_Y, INNER_RADIUS, SUBPLOT_OUTER_RADIUS_MAINPLOT, SUBPLOT_OUTER_RADIUS_STANDARD, DRAG_DROP_TICK_OUTER_RADIUS, DRAG_DROP_ARC_RADIUS, SUBPLOT_OUTER_RADIUS_CHRONOLOGUE, BACKDROP_RING_HEIGHT, BACKDROP_TITLE_RADIUS_OFFSET, MONTH_LABEL_RADIUS, CHRONOLOGUE_DATE_RADIUS, MONTH_TICK_END, MONTH_TICK_START, ACT_LABEL_RADIUS, CHRONOLOGUE_DURATION_ARC_RADIUS, ELAPSED_ARC_RADIUS, ELAPSED_TICK_LENGTH, SCENE_TITLE_INSET, SYNOPSIS_INSET, BEAT_TEXT_RADIUS, TEXTPATH_START_NUDGE_RAD, MAX_TEXT_WIDTH, PLOT_PIXEL_WIDTH, BEAT_FONT_PX, ESTIMATE_FUDGE_RENDER, PADDING_RENDER_PX, BEAT_LABEL_BREATHING_ROOM_PX, READABILITY_SCALES, NUMBER_SQUARE_FONT_SIZE_PX, NUMBER_SQUARE_HEIGHT_PX, NUMBER_SQUARE_PADDING_PX, NUMBER_SQUARE_LETTER_SPACING_EM, BEAT_LABEL_FONT_SIZE_PX, BEAT_LABEL_LETTER_SPACING_EM, BOOK_TITLE_POS_X, BOOK_TITLE_POS_Y, MODE_TITLE_POS_X, MODE_TITLE_POS_Y, MODE_SELECTOR_POS_X, MODE_SELECTOR_POS_Y, SHIFT_BUTTON_POS_X, SHIFT_BUTTON_POS_Y, GRID_CELL_BASE, GRID_CELL_WIDTH_EXTRA, GRID_CELL_GAP_X, GRID_CELL_GAP_Y, GRID_HEADER_OFFSET_Y, GRID_LINE_HEIGHT;
var init_LayoutConstants = __esm({
  "src/renderer/layout/LayoutConstants.ts"() {
    SVG_SIZE = 1600;
    VERSION_INDICATOR_POS_X = -780;
    VERSION_INDICATOR_POS_Y = 734;
    HELP_ICON_POS_X = 730;
    HELP_ICON_POS_Y = 734;
    INNER_RADIUS = 200;
    SUBPLOT_OUTER_RADIUS_MAINPLOT = 778;
    SUBPLOT_OUTER_RADIUS_STANDARD = {
      normal: 766,
      large: 762
    };
    DRAG_DROP_TICK_OUTER_RADIUS = 796;
    DRAG_DROP_ARC_RADIUS = 797;
    SUBPLOT_OUTER_RADIUS_CHRONOLOGUE = 750;
    BACKDROP_RING_HEIGHT = 20;
    BACKDROP_TITLE_RADIUS_OFFSET = -2;
    MONTH_LABEL_RADIUS = 790;
    CHRONOLOGUE_DATE_RADIUS = 792;
    MONTH_TICK_END = 799;
    MONTH_TICK_START = 764;
    ACT_LABEL_RADIUS = 790;
    CHRONOLOGUE_DURATION_ARC_RADIUS = 758;
    ELAPSED_ARC_RADIUS = 766;
    ELAPSED_TICK_LENGTH = 14;
    SCENE_TITLE_INSET = 22;
    SYNOPSIS_INSET = 0;
    BEAT_TEXT_RADIUS = {
      normal: 769,
      large: 765
    };
    TEXTPATH_START_NUDGE_RAD = 0.02;
    MAX_TEXT_WIDTH = 500;
    PLOT_PIXEL_WIDTH = 18;
    BEAT_FONT_PX = 9;
    ESTIMATE_FUDGE_RENDER = 1.35;
    PADDING_RENDER_PX = 24;
    BEAT_LABEL_BREATHING_ROOM_PX = 10;
    READABILITY_SCALES = {
      normal: 1,
      // 100% - baseline size
      large: 1.3
      // 140% - for low-res or low-vision viewing
    };
    NUMBER_SQUARE_FONT_SIZE_PX = 13;
    NUMBER_SQUARE_HEIGHT_PX = 18;
    NUMBER_SQUARE_PADDING_PX = 7;
    NUMBER_SQUARE_LETTER_SPACING_EM = 0.03;
    BEAT_LABEL_FONT_SIZE_PX = 12;
    BEAT_LABEL_LETTER_SPACING_EM = 0.07;
    BOOK_TITLE_POS_X = 568;
    BOOK_TITLE_POS_Y = -780;
    MODE_TITLE_POS_X = 567;
    MODE_TITLE_POS_Y = -755;
    MODE_SELECTOR_POS_X = 658;
    MODE_SELECTOR_POS_Y = -740;
    SHIFT_BUTTON_POS_X = -700;
    SHIFT_BUTTON_POS_Y = -740;
    GRID_CELL_BASE = 22;
    GRID_CELL_WIDTH_EXTRA = 9;
    GRID_CELL_GAP_X = 2;
    GRID_CELL_GAP_Y = 4;
    GRID_HEADER_OFFSET_Y = 12;
    GRID_LINE_HEIGHT = 26;
  }
});

// src/renderer/utils/FontMetricsCache.ts
function ensureBeatLabelCache(fontScale = 1) {
  if (beatLabelCache && currentFontScale === fontScale) {
    return;
  }
  currentFontScale = fontScale;
  const config = {
    fontFamily: "var(--font-interface)",
    fontSize: BEAT_LABEL_FONT_SIZE_PX * fontScale,
    fontWeight: 500,
    letterSpacing: `${BEAT_LABEL_LETTER_SPACING_EM}em`,
    textTransform: "uppercase"
  };
  beatLabelCache = measureWithTemporarySvg(config, MEASUREMENT_CHARS);
}
function ensureNumberSquareCache(fontScale = 1) {
  if (numberSquareCache) {
    return;
  }
  const config = {
    fontFamily: "var(--font-interface)",
    fontSize: NUMBER_SQUARE_FONT_SIZE_PX,
    fontWeight: "normal",
    letterSpacing: `${NUMBER_SQUARE_LETTER_SPACING_EM}em`
  };
  numberSquareCache = measureWithTemporarySvg(config, "0123456789.");
}
function measureWithTemporarySvg(config, chars) {
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.setAttribute("width", "0");
  svg.setAttribute("height", "0");
  svg.style.position = "absolute";
  svg.style.visibility = "hidden";
  svg.style.pointerEvents = "none";
  document.body.appendChild(svg);
  const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
  text.style.fontFamily = config.fontFamily;
  text.style.fontSize = `${config.fontSize}px`;
  text.style.fontWeight = String(config.fontWeight);
  text.style.letterSpacing = config.letterSpacing;
  if (config.textTransform) {
    text.style.textTransform = config.textTransform;
  }
  svg.appendChild(text);
  const charWidths = /* @__PURE__ */ new Map();
  let totalWidth = 0;
  let charCount = 0;
  for (const char of chars) {
    text.textContent = char;
    const width = text.getComputedTextLength();
    charWidths.set(char, width);
    if (char !== " ") {
      totalWidth += width;
      charCount++;
    }
  }
  if (!charWidths.has(" ")) {
    text.textContent = " ";
    const spaceWidth = text.getComputedTextLength();
    charWidths.set(" ", spaceWidth);
  }
  document.body.removeChild(svg);
  return {
    charWidths,
    avgCharWidth: charCount > 0 ? totalWidth / charCount : 8,
    spaceWidth: charWidths.get(" ") || 4,
    config
  };
}
function estimateBeatLabelWidth(title, fontPx, paddingPx) {
  const fontScale = fontPx / 12;
  ensureBeatLabelCache(fontScale);
  if (!beatLabelCache) {
    return title.length * 8 + paddingPx;
  }
  const upperTitle = title.toUpperCase();
  let width = 0;
  for (const char of upperTitle) {
    const charWidth = beatLabelCache.charWidths.get(char);
    if (charWidth !== void 0) {
      width += charWidth;
    } else {
      width += beatLabelCache.avgCharWidth;
    }
  }
  return Math.max(0, width + paddingPx);
}
function getNumberSquareWidthFromCache(num, scale = 1) {
  ensureNumberSquareCache(1);
  if (!numberSquareCache) {
    if (num.includes(".")) {
      if (num.length <= 3) return 30 * scale;
      if (num.length <= 4) return 36 * scale;
      return 40 * scale;
    }
    if (num.length === 1) return 20 * scale;
    if (num.length === 2) return 24 * scale;
    return 32 * scale;
  }
  let width = 0;
  for (const char of num) {
    const charWidth = numberSquareCache.charWidths.get(char);
    if (charWidth !== void 0) {
      width += charWidth;
    } else {
      width += numberSquareCache.avgCharWidth;
    }
  }
  return (width + NUMBER_SQUARE_PADDING_PX) * scale;
}
function clearFontMetricsCaches() {
  beatLabelCache = null;
  numberSquareCache = null;
  currentFontScale = 1;
}
var beatLabelCache, numberSquareCache, currentFontScale, MEASUREMENT_CHARS;
var init_FontMetricsCache = __esm({
  "src/renderer/utils/FontMetricsCache.ts"() {
    init_LayoutConstants();
    beatLabelCache = null;
    numberSquareCache = null;
    currentFontScale = 1;
    MEASUREMENT_CHARS = `ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 -\u2013\u2014'".,:;!?&()[]`;
  }
});

// src/utils/text.ts
function decodeHtmlEntities(text) {
  var _a, _b;
  if (!text) return "";
  if (text.includes("<tspan") || text.includes("&lt;tspan")) return text;
  try {
    const parser = new DOMParser();
    const doc = parser.parseFromString(`<!DOCTYPE html><body><span>${text}</span></body>`, "text/html");
    const span = doc.querySelector("span");
    return (_a = span == null ? void 0 : span.textContent) != null ? _a : "";
  } catch (e) {
    const span = document.createElement("span");
    span.textContent = text;
    return (_b = span.textContent) != null ? _b : "";
  }
}
function parseSceneTitleComponents(titleText, sceneNumber, date, duration) {
  const result = { sceneNumber: "", title: "", date: "", duration: "" };
  if (!titleText) return result;
  if (sceneNumber !== null && sceneNumber !== void 0) {
    result.sceneNumber = String(sceneNumber);
  }
  if (date) {
    result.date = date;
  }
  if (duration) {
    result.duration = duration;
  }
  const decodedText = decodeHtmlEntities(titleText);
  if (decodedText.includes("<tspan")) {
    result.title = decodedText;
    return result;
  }
  if (result.sceneNumber === "" || result.date === "") {
    const dateMatch = decodedText.match(/\s{3,}(.+?)$/);
    if (dateMatch && result.date === "") {
      result.date = dateMatch[1].trim();
      const titlePart = decodedText.substring(0, dateMatch.index).trim();
      const titleMatch = titlePart.match(/^(\d+(?:\.\d+)?)\s+(.+)$/);
      if (titleMatch) {
        if (result.sceneNumber === "") result.sceneNumber = titleMatch[1];
        result.title = titleMatch[2];
      } else {
        result.title = titlePart;
      }
    } else {
      const titleMatch = decodedText.match(/^(\d+(?:\.\d+)?)\s+(.+)$/);
      if (titleMatch) {
        if (result.sceneNumber === "") result.sceneNumber = titleMatch[1];
        result.title = titleMatch[2];
      } else {
        result.title = decodedText;
      }
    }
  } else {
    result.title = decodedText.replace(/^\d+(?:\.\d+)?\s+/, "").replace(/\s{3,}(.+?)$/, "").trim();
  }
  return result;
}
function splitIntoBalancedLines(text, maxWidth, fontScale = 1) {
  if (!text) return [""];
  if (text.includes("<tspan")) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(`<svg xmlns="http://www.w3.org/2000/svg"><text>${text}</text></svg>`, "image/svg+xml");
    if (doc.querySelector("parsererror")) return [text];
    const textElement = doc.querySelector("text");
    if (!textElement) return [text];
    const plainText = textElement.textContent || "";
    const plainLines = splitPlainTextIntoLines(plainText, maxWidth, fontScale);
    return plainLines.length <= 1 ? [text] : [text];
  }
  return splitPlainTextIntoLines(text, maxWidth, fontScale);
}
function splitPlainTextIntoLines(text, maxWidth, fontScale) {
  const words = text.split(/\s+/);
  const lines = [];
  let currentLine = "";
  let currentWidth = 0;
  const approxCharWidth = 8 * (fontScale || 1);
  const maxCharsPerLine = Math.max(10, Math.round((maxWidth || 400) / approxCharWidth)) || 50;
  for (const word of words) {
    const wordWidth = word.length;
    if (currentWidth + wordWidth > maxCharsPerLine && currentLine !== "") {
      lines.push(currentLine.trim());
      currentLine = word;
      currentWidth = wordWidth;
    } else {
      currentLine += (currentLine ? " " : "") + word;
      currentWidth += wordWidth + (currentLine ? 1 : 0);
    }
  }
  if (currentLine) lines.push(currentLine.trim());
  return lines;
}
function parseSceneTitle(title, sceneNumber) {
  if (!title) return { number: "0", text: "" };
  if (sceneNumber !== null && sceneNumber !== void 0) {
    const cleanTitle = title.replace(/^\d+(?:\.\d+)?\s+/, "");
    return { number: String(sceneNumber), text: escapeXml(cleanTitle) };
  }
  const match = title.match(/^(\d+(?:\.\d+)?)\s+(.+)/);
  if (match) {
    const number = match[1];
    const text = match[2];
    return { number, text: escapeXml(text) };
  }
  return { number: "", text: escapeXml(title) };
}
function normalizeStatus(raw) {
  var _a;
  if (raw == null) return "Todo";
  const v = Array.isArray(raw) ? String((_a = raw[0]) != null ? _a : "").trim().toLowerCase() : String(raw).trim().toLowerCase();
  if (!v) return "Todo";
  if (v === "complete" || v === "done" || v === "completed") return "Completed";
  if (v === "working" || v === "in progress" || v === "progress") return "Working";
  if (v === "todo" || v === "to do" || v === "tbd") return "Todo";
  return null;
}
function getScenePrefixNumber(title, sceneNumber) {
  if (!title) return null;
  if (sceneNumber !== null && sceneNumber !== void 0) {
    return String(sceneNumber);
  }
  const decoded = decodeHtmlEntities(title);
  const m = decoded.match(/^(\d+(?:\.\d+)?)\s+.+/);
  return m ? m[1] : null;
}
function getNumberSquareSize(num, scale = 1) {
  const height = NUMBER_SQUARE_HEIGHT_PX * scale;
  const width = getNumberSquareWidthFromCache(num, scale);
  return { width, height };
}
function stripObsidianComments(text) {
  if (!text) return text;
  return text.replace(/%%[\s\S]*?%%/g, "").trim();
}
function stripWikiLinks(text) {
  if (!text) return text;
  return text.replace(/\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g, (_, link, alias) => alias || link).trim();
}
var init_text = __esm({
  "src/utils/text.ts"() {
    init_regex();
    init_svg();
    init_FontMetricsCache();
    init_LayoutConstants();
  }
});

// src/utils/date.ts
function parseMonthName(value) {
  if (!value) return null;
  const key = value.toLowerCase().replace(".", "");
  return key in MONTH_NAME_MAP ? MONTH_NAME_MAP[key] : null;
}
function createLocalDate(year, monthIndex, day, hour = 12, minute = 0, second = 0) {
  const date = new Date(year, monthIndex, day, hour, minute, second, 0);
  return isNaN(date.getTime()) ? null : date;
}
function parseWhenField(when) {
  if (!when || typeof when !== "string") return null;
  const standardized = when.trim().replace(/\//g, "-");
  const trimmed = standardized;
  const dateOnlyMatch = /^(\d{4})-(\d{1,2})-(\d{1,2})$/.exec(trimmed);
  if (dateOnlyMatch) {
    const year = parseInt(dateOnlyMatch[1], 10);
    const month = parseInt(dateOnlyMatch[2], 10) - 1;
    const day = parseInt(dateOnlyMatch[3], 10);
    const date = new Date(year, month, day, 12, 0, 0, 0);
    return isNaN(date.getTime()) ? null : date;
  }
  const iso8601SecondsMatch = /^(\d{4})-(\d{1,2})-(\d{1,2})T(\d{1,2}):(\d{1,2}):(\d{1,2})$/.exec(trimmed);
  if (iso8601SecondsMatch) {
    const year = parseInt(iso8601SecondsMatch[1], 10);
    const month = parseInt(iso8601SecondsMatch[2], 10) - 1;
    const day = parseInt(iso8601SecondsMatch[3], 10);
    const hour = parseInt(iso8601SecondsMatch[4], 10);
    const minute = parseInt(iso8601SecondsMatch[5], 10);
    const second = parseInt(iso8601SecondsMatch[6], 10);
    const date = new Date(year, month, day, hour, minute, second, 0);
    return isNaN(date.getTime()) ? null : date;
  }
  const iso8601Match = /^(\d{4})-(\d{1,2})-(\d{1,2})T(\d{1,2}):(\d{1,2})$/.exec(trimmed);
  if (iso8601Match) {
    const year = parseInt(iso8601Match[1], 10);
    const month = parseInt(iso8601Match[2], 10) - 1;
    const day = parseInt(iso8601Match[3], 10);
    const hour = parseInt(iso8601Match[4], 10);
    const minute = parseInt(iso8601Match[5], 10);
    const date = new Date(year, month, day, hour, minute, 0, 0);
    return isNaN(date.getTime()) ? null : date;
  }
  const dateTimeSecondsMatch = /^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2})$/.exec(trimmed);
  if (dateTimeSecondsMatch) {
    const year = parseInt(dateTimeSecondsMatch[1], 10);
    const month = parseInt(dateTimeSecondsMatch[2], 10) - 1;
    const day = parseInt(dateTimeSecondsMatch[3], 10);
    const hour = parseInt(dateTimeSecondsMatch[4], 10);
    const minute = parseInt(dateTimeSecondsMatch[5], 10);
    const second = parseInt(dateTimeSecondsMatch[6], 10);
    const date = new Date(year, month, day, hour, minute, second, 0);
    return isNaN(date.getTime()) ? null : date;
  }
  const dateTimeMatch = /^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2})$/.exec(trimmed);
  if (dateTimeMatch) {
    const year = parseInt(dateTimeMatch[1], 10);
    const month = parseInt(dateTimeMatch[2], 10) - 1;
    const day = parseInt(dateTimeMatch[3], 10);
    const hour = parseInt(dateTimeMatch[4], 10);
    const minute = parseInt(dateTimeMatch[5], 10);
    const date = new Date(year, month, day, hour, minute, 0, 0);
    return isNaN(date.getTime()) ? null : date;
  }
  const ampmMatch = /^(\d{4})-(\d{1,2})-(\d{1,2})\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)$/i.exec(trimmed);
  if (ampmMatch) {
    const year = parseInt(ampmMatch[1], 10);
    const month = parseInt(ampmMatch[2], 10) - 1;
    const day = parseInt(ampmMatch[3], 10);
    let hour = parseInt(ampmMatch[4], 10);
    const minute = ampmMatch[5] ? parseInt(ampmMatch[5], 10) : 0;
    const ampm = ampmMatch[6].toLowerCase();
    if (ampm === "pm" && hour < 12) {
      hour += 12;
    } else if (ampm === "am" && hour === 12) {
      hour = 0;
    }
    const date = new Date(year, month, day, hour, minute, 0, 0);
    return isNaN(date.getTime()) ? null : date;
  }
  const yearMonthMatch = /^(\d{4})-(\d{1,2})$/.exec(trimmed);
  if (yearMonthMatch) {
    const year = parseInt(yearMonthMatch[1], 10);
    const month = parseInt(yearMonthMatch[2], 10) - 1;
    return createLocalDate(year, month, 1);
  }
  const yearOnlyMatch = /^(\d{4})$/.exec(trimmed);
  if (yearOnlyMatch) {
    const year = parseInt(yearOnlyMatch[1], 10);
    return createLocalDate(year, 0, 1);
  }
  const monthYearMatch = /^([A-Za-z]+)\s*,?\s*(\d{4})$/.exec(trimmed);
  if (monthYearMatch) {
    const month = parseMonthName(monthYearMatch[1]);
    const year = parseInt(monthYearMatch[2], 10);
    if (month !== null) {
      return createLocalDate(year, month, 1);
    }
  }
  const monthDayYearMatch = /^([A-Za-z]+)\s+(\d{1,2})(?:st|nd|rd|th)?(?:,)?\s+(\d{4})$/.exec(trimmed);
  if (monthDayYearMatch) {
    const month = parseMonthName(monthDayYearMatch[1]);
    const day = parseInt(monthDayYearMatch[2], 10);
    const year = parseInt(monthDayYearMatch[3], 10);
    if (month !== null) {
      return createLocalDate(year, month, day);
    }
  }
  const dayMonthYearMatch = /^(\d{1,2})(?:st|nd|rd|th)?\s+([A-Za-z]+)(?:,)?\s+(\d{4})$/.exec(trimmed);
  if (dayMonthYearMatch) {
    const day = parseInt(dayMonthYearMatch[1], 10);
    const month = parseMonthName(dayMonthYearMatch[2]);
    const year = parseInt(dayMonthYearMatch[3], 10);
    if (month !== null) {
      return createLocalDate(year, month, day);
    }
  }
  return null;
}
function calculateTimeSpan(dates) {
  if (dates.length === 0) {
    return {
      totalMs: 0,
      minutes: 0,
      hours: 0,
      days: 0,
      weeks: 0,
      months: 0,
      years: 0,
      recommendedUnit: "days"
    };
  }
  const sortedDates = dates.slice().sort((a, b) => a.getTime() - b.getTime());
  const earliest = sortedDates[0];
  const latest = sortedDates[sortedDates.length - 1];
  const totalMs = latest.getTime() - earliest.getTime();
  const minutes = totalMs / (1e3 * 60);
  const hours = minutes / 60;
  const days = hours / 24;
  const weeks = days / 7;
  const months = days / 30.44;
  const years = days / 365.25;
  let recommendedUnit;
  if (hours <= 3) {
    recommendedUnit = "minutes";
  } else if (hours <= 48) {
    recommendedUnit = "hours";
  } else if (days <= 14) {
    recommendedUnit = "days";
  } else if (weeks <= 8) {
    recommendedUnit = "weeks";
  } else if (months <= 24) {
    recommendedUnit = "months";
  } else {
    recommendedUnit = "years";
  }
  return {
    totalMs,
    minutes,
    hours,
    days,
    weeks,
    months,
    years,
    recommendedUnit
  };
}
function formatUnitLabel(value, unitKey) {
  var _a;
  const unit = (_a = ELAPSED_TIME_UNIT_LABELS[unitKey]) != null ? _a : {
    singular: unitKey,
    plural: `${unitKey}s`
  };
  const isSingular = Math.abs(Math.abs(value) - 1) < 1e-9;
  return isSingular ? unit.singular : unit.plural;
}
function buildPrimaryComponent(ms, requestedUnit) {
  const unitDef = ELAPSED_UNIT_SEQUENCE[requestedUnit];
  if (!unitDef || ms <= 0) {
    return {
      text: `0 ${formatUnitLabel(0, requestedUnit)}`,
      remainderMs: 0,
      usedUnit: requestedUnit
    };
  }
  const wholeValue = Math.floor(ms / unitDef.ms);
  if (wholeValue <= 0) {
    if (unitDef.next) {
      return buildPrimaryComponent(ms, unitDef.next);
    }
    const secondsValue = Math.max(1, Math.round(ms / MS_PER_SECOND));
    return {
      text: `${secondsValue} ${formatUnitLabel(secondsValue, "second")}`,
      remainderMs: 0,
      usedUnit: "second"
    };
  }
  const consumed = wholeValue * unitDef.ms;
  return {
    text: `${wholeValue} ${formatUnitLabel(wholeValue, requestedUnit)}`,
    remainderMs: Math.max(0, ms - consumed),
    usedUnit: requestedUnit
  };
}
function buildSecondaryComponent(remainderMs, startUnit) {
  if (!startUnit || remainderMs <= 0) return null;
  const unitDef = ELAPSED_UNIT_SEQUENCE[startUnit];
  if (!unitDef) return null;
  const wholeValue = Math.floor(remainderMs / unitDef.ms);
  if (wholeValue > 0) {
    return {
      text: `${wholeValue} ${formatUnitLabel(wholeValue, startUnit)}`,
      usedUnit: startUnit
    };
  }
  if (unitDef.next) {
    return buildSecondaryComponent(remainderMs, unitDef.next);
  }
  const secondsValue = Math.round(remainderMs / MS_PER_SECOND);
  if (secondsValue > 0) {
    return {
      text: `${secondsValue} ${formatUnitLabel(secondsValue, "second")}`,
      usedUnit: "second"
    };
  }
  return null;
}
function formatCompositeDuration(ms, primaryUnit) {
  var _a;
  const positiveMs = Math.max(0, ms);
  const primary = buildPrimaryComponent(positiveMs, primaryUnit);
  const parts = [primary.text];
  const nextUnit = (_a = ELAPSED_UNIT_SEQUENCE[primary.usedUnit]) == null ? void 0 : _a.next;
  const secondary = buildSecondaryComponent(primary.remainderMs, nextUnit);
  if (secondary) {
    parts.push(secondary.text);
  }
  return parts.join(" + ");
}
function pickAutoElapsedUnit(ms) {
  if (ms < MS_PER_MINUTE) {
    return "second";
  }
  if (ms < MS_PER_HOUR) {
    return "minute";
  }
  if (ms < MS_PER_DAY) {
    return "hour";
  }
  if (ms < MS_PER_WEEK) {
    return "day";
  }
  if (ms < MS_PER_WEEK * 8) {
    return "week";
  }
  if (ms < MS_PER_MONTH * 24) {
    return "month";
  }
  return "year";
}
function formatElapsedTime(ms, clickCount = 0) {
  if (!Number.isFinite(ms)) {
    return "0 minutes";
  }
  const safeMs = Math.max(0, Math.abs(ms));
  if (safeMs === 0) {
    return "0 minutes";
  }
  const unitIndex = (clickCount % 5 + 5) % 5;
  let unit;
  switch (unitIndex) {
    case 0:
      unit = pickAutoElapsedUnit(safeMs);
      break;
    case 1:
      unit = "hour";
      break;
    case 2:
      unit = "day";
      break;
    case 3:
      unit = "week";
      break;
    case 4:
    default:
      unit = "month";
      break;
  }
  return formatCompositeDuration(safeMs, unit);
}
function dateToAngle(date) {
  const startOfYear = new Date(date.getFullYear(), 0, 1);
  const dayOfYear = (date.getTime() - startOfYear.getTime()) / (1e3 * 60 * 60 * 24);
  const daysInYear = (new Date(date.getFullYear(), 11, 31).getTime() - startOfYear.getTime()) / (1e3 * 60 * 60 * 24) + 1;
  const progress = dayOfYear / daysInYear;
  return progress * 2 * Math.PI - Math.PI / 2;
}
function isOverdueDateString(dueString, today = /* @__PURE__ */ new Date()) {
  if (!dueString || typeof dueString !== "string") return false;
  const parts = dueString.split("-").map(Number);
  if (parts.length !== 3 || parts.some((n) => isNaN(n))) return false;
  const [dueYear, dueMonth1, dueDay] = parts;
  const dueMonth = dueMonth1 - 1;
  const todayY = today.getFullYear();
  const todayM = today.getMonth();
  const todayD = today.getDate();
  if (dueYear < todayY) return true;
  if (dueYear > todayY) return false;
  if (dueMonth < todayM) return true;
  if (dueMonth > todayM) return false;
  return dueDay < todayD;
}
function formatDurationValue(value) {
  if (Number.isNaN(value)) return "";
  if (Number.isInteger(value)) return value.toString();
  return value.toFixed(2).replace(/\.?0+$/, "");
}
function matchDurationDetail(duration) {
  if (!duration || typeof duration !== "string") return null;
  const trimmed = duration.trim().toLowerCase();
  if (!trimmed) return null;
  const match = trimmed.match(/^([\d.]+)\s*([a-z]+)$/);
  if (!match) return null;
  const numeric = parseFloat(match[1]);
  if (!Number.isFinite(numeric) || numeric < 0) return null;
  const unitAlias = match[2];
  const unitDef = DURATION_UNIT_ALIAS_MAP.get(unitAlias);
  if (!unitDef) return null;
  return { value: numeric, valueText: match[1], unit: unitDef };
}
function parseDuration(duration) {
  if (!duration || typeof duration !== "string") return null;
  const trimmed = duration.trim().toLowerCase();
  if (trimmed === "" || trimmed === "0") return 0;
  const match = matchDurationDetail(duration);
  if (!match) return null;
  if (match.value === 0) return 0;
  return match.value * match.unit.multiplier;
}
function parseDurationDetail(duration) {
  const match = matchDurationDetail(duration);
  if (!match) return null;
  if (match.value <= 0) return null;
  return {
    value: match.value,
    valueText: formatDurationValue(match.value),
    unitKey: match.unit.key,
    unitSingular: match.unit.singular,
    unitPlural: match.unit.plural,
    ms: match.value * match.unit.multiplier
  };
}
function durationSelectionToMs(selection) {
  if (!selection || selection === "auto") return null;
  const [valuePart, unitKey] = selection.split("|");
  if (!valuePart || !unitKey) return null;
  const value = parseFloat(valuePart);
  if (!Number.isFinite(value) || value <= 0) return null;
  const unitDef = DURATION_UNIT_DEFINITIONS.find((def) => def.key === unitKey);
  if (!unitDef) return null;
  return value * unitDef.multiplier;
}
function formatDurationSelectionLabel(selection) {
  if (!selection || selection === "auto") return null;
  const [valuePart, unitKey] = selection.split("|");
  if (!valuePart || !unitKey) return null;
  const value = parseFloat(valuePart);
  if (!Number.isFinite(value) || value <= 0) return null;
  const unitDef = DURATION_UNIT_DEFINITIONS.find((def) => def.key === unitKey);
  if (!unitDef) return null;
  const formattedValue = formatDurationValue(value);
  const unitLabel = value === 1 ? unitDef.singular : unitDef.plural;
  return `${formattedValue} ${unitLabel}`;
}
function prepareScenesForDiscontinuityDetection(scenes) {
  const uniqueScenesMap = /* @__PURE__ */ new Map();
  scenes.forEach((scene) => {
    if (scene.itemType !== "Scene") return;
    if (!(scene.when instanceof Date)) return;
    const key = scene.path || `title:${scene.title || ""}`;
    if (!uniqueScenesMap.has(key)) {
      uniqueScenesMap.set(key, { when: scene.when });
    }
  });
  const uniqueScenes = Array.from(uniqueScenesMap.values());
  return uniqueScenes.sort((a, b) => a.when.getTime() - b.when.getTime());
}
function calculateAutoDiscontinuityThreshold(scenes) {
  const preparedScenes = prepareScenesForDiscontinuityDetection(scenes);
  if (preparedScenes.length < 3) {
    return null;
  }
  const gaps = [];
  for (let i = 1; i < preparedScenes.length; i++) {
    const gap = preparedScenes[i].when.getTime() - preparedScenes[i - 1].when.getTime();
    if (gap >= 0) {
      gaps.push(gap);
    }
  }
  if (gaps.length === 0) {
    return null;
  }
  const sortedGaps = [...gaps].sort((a, b) => a - b);
  const medianIndex = Math.floor(sortedGaps.length / 2);
  const medianGap = sortedGaps[medianIndex];
  if (medianGap === 0) {
    const nonZeroGaps = sortedGaps.filter((g) => g > 0);
    if (nonZeroGaps.length === 0) {
      return null;
    }
    const nonZeroMedianIndex = Math.floor(nonZeroGaps.length / 2);
    const nonZeroMedian = nonZeroGaps[nonZeroMedianIndex];
    return nonZeroMedian * 3;
  }
  return medianGap * 3;
}
function detectDiscontinuities(scenes, thresholdMs) {
  if (scenes.length < 3) {
    return [];
  }
  if (!thresholdMs || thresholdMs <= 0) {
    return [];
  }
  const discontinuityIndices = [];
  for (let i = 1; i < scenes.length; i++) {
    const prev = scenes[i - 1].when;
    const curr = scenes[i].when;
    if (prev && curr) {
      const gap = curr.getTime() - prev.getTime();
      if (gap >= 0 && gap >= thresholdMs) {
        discontinuityIndices.push(i);
      }
    }
  }
  return discontinuityIndices;
}
function detectSceneOverlaps(scenes) {
  const overlaps = /* @__PURE__ */ new Set();
  for (let i = 0; i < scenes.length - 1; i++) {
    const current = scenes[i];
    const next = scenes[i + 1];
    if (!current.when || !next.when) continue;
    const durationMs = parseDuration(current.Duration);
    if (durationMs === null || durationMs === 0) continue;
    const currentEnd = current.when.getTime() + durationMs;
    const nextStart = next.when.getTime();
    if (currentEnd > nextStart) {
      overlaps.add(i);
    }
  }
  return overlaps;
}
function generateChronologicalTicks(scenes, sceneStartAngles, sceneAngularSize, timeSpan) {
  const validScenes = [];
  scenes.forEach((s, idx) => {
    if (s.when && !isNaN(s.when.getTime())) {
      validScenes.push({ date: s.when, sortedIndex: idx });
    }
  });
  if (validScenes.length === 0) {
    return [];
  }
  const validDates = validScenes.map((s) => s.date);
  const span = timeSpan || calculateTimeSpan(validDates);
  const earliestDate = validDates[0];
  if (validScenes.length === 1) {
    const singleDate = validScenes[0].date;
    const month = singleDate.toLocaleString("en-US", { month: "short" });
    const day = singleDate.getDate();
    const year = singleDate.getFullYear();
    const dateLabel = `${month} ${day}, ${year}`;
    return [{
      angle: -Math.PI / 2,
      // Top of circle
      name: dateLabel,
      shortName: dateLabel,
      isMajor: true
    }];
  }
  const ticks = [];
  const numScenes = validScenes.length;
  const getSceneStartAngle = (sortedIndex) => {
    if (sceneStartAngles && sceneStartAngles[sortedIndex] !== void 0) {
      return sceneStartAngles[sortedIndex];
    }
    const anglePerScene = 2 * Math.PI / numScenes;
    return -Math.PI / 2 + sortedIndex * anglePerScene;
  };
  const firstScene = validScenes[0];
  const lastScene = validScenes[numScenes - 1];
  const firstAngle = getSceneStartAngle(firstScene.sortedIndex);
  const lastAngle = getSceneStartAngle(lastScene.sortedIndex);
  const MAX_MAJOR_TICKS = 20;
  let step = 1;
  let numMajorTicks = numScenes;
  if (numScenes > MAX_MAJOR_TICKS) {
    step = Math.ceil(numScenes / MAX_MAJOR_TICKS);
    let bestStep = step;
    let bestMajorCount = Math.ceil((numScenes - 1) / step) + 1;
    for (let testStep = step; testStep >= 1; testStep--) {
      const testMajorCount = Math.ceil((numScenes - 1) / testStep) + 1;
      if (testMajorCount <= MAX_MAJOR_TICKS && (numScenes - 1) % testStep === 0) {
        bestStep = testStep;
        bestMajorCount = testMajorCount;
        break;
      }
    }
    step = bestStep;
    numMajorTicks = bestMajorCount;
  }
  const promoteSet = /* @__PURE__ */ new Set();
  promoteSet.add(0);
  promoteSet.add(numScenes - 1);
  for (let i = step; i < numScenes - 1; i += step) {
    promoteSet.add(i);
  }
  const angleDiff = Math.abs(lastAngle - firstAngle);
  const normalizedDiff = Math.min(angleDiff, Math.abs(angleDiff - 2 * Math.PI));
  const wouldOverlap = normalizedDiff < 0.01 || normalizedDiff > 2 * Math.PI - 0.01;
  const sceneGaps = [];
  for (let i = 0; i < validScenes.length; i++) {
    if (i === 0) {
      sceneGaps.push(0);
    } else {
      const gapMs = validScenes[i].date.getTime() - validScenes[i - 1].date.getTime();
      sceneGaps.push(gapMs);
    }
  }
  const generateLabel = (sceneDate, sceneIndex, isFirst, isLast) => {
    const formatTime12Hour = (date) => {
      const hour = date.getHours();
      const minute = date.getMinutes();
      if (hour === 12 && minute === 0) {
        return "noon";
      } else if (hour === 0 && minute === 0) {
        return "midnight";
      }
      const ampm = hour >= 12 ? "pm" : "am";
      const displayHour = hour % 12 || 12;
      const minuteStr = minute.toString().padStart(2, "0");
      return `${displayHour}:${minuteStr}${ampm}`;
    };
    const month = sceneDate.toLocaleString("en-US", { month: "short" });
    const day = sceneDate.getDate();
    const year = sceneDate.getFullYear();
    const timeStr = formatTime12Hour(sceneDate);
    const gapMs = sceneGaps[sceneIndex];
    const gapHours = gapMs / (1e3 * 60 * 60);
    const gapDays = gapHours / 24;
    if (isFirst) {
      const totalSpanHours = span.hours;
      if (totalSpanHours < 48) {
        return { name: `${month} ${day}
${timeStr}`, shortName: `${month} ${day}
${timeStr}` };
      } else {
        return { name: `${year}
${month} ${day}`, shortName: `${year}
${month} ${day}` };
      }
    }
    if (isLast) {
      const totalSpanHours = span.hours;
      if (totalSpanHours < 48) {
        return { name: `${month} ${day}
${timeStr}`, shortName: `${month} ${day}
${timeStr}` };
      } else {
        return { name: `${year}
${month} ${day}`, shortName: `${year}
${month} ${day}` };
      }
    }
    if (gapHours < 6) {
      return { name: timeStr, shortName: timeStr };
    } else if (gapHours < 48) {
      return { name: `${month} ${day}
${timeStr}`, shortName: `${month} ${day}
${timeStr}` };
    } else {
      return { name: `${month} ${day}`, shortName: `${month} ${day}` };
    }
  };
  let lastLabeledSceneDate = null;
  for (let i = 0; i < numScenes; i++) {
    const scene = validScenes[i];
    const sceneStartAngle = getSceneStartAngle(scene.sortedIndex);
    let gapFromLastLabel = 0;
    if (lastLabeledSceneDate !== null) {
      gapFromLastLabel = scene.date.getTime() - lastLabeledSceneDate.getTime();
    }
    if (i === 0) {
      sceneGaps[i] = 0;
    } else if (lastLabeledSceneDate === null) {
      sceneGaps[i] = 0;
    } else {
      sceneGaps[i] = gapFromLastLabel;
    }
    if (i === 0) {
      const labels = generateLabel(scene.date, i, true, false);
      ticks.push({
        angle: sceneStartAngle,
        name: labels.name,
        shortName: labels.shortName,
        isMajor: true,
        isFirst: true,
        sceneIndex: scene.sortedIndex,
        earthDate: scene.date.toISOString()
      });
      lastLabeledSceneDate = scene.date;
    } else if (i === numScenes - 1) {
      let tickAngle = sceneStartAngle;
      if (wouldOverlap && sceneAngularSize !== void 0) {
        tickAngle = sceneStartAngle + sceneAngularSize;
        if (tickAngle > Math.PI) tickAngle -= 2 * Math.PI;
      }
      const labels = generateLabel(scene.date, i, false, true);
      ticks.push({
        angle: tickAngle,
        name: labels.name,
        shortName: labels.shortName,
        isMajor: true,
        isLast: true,
        sceneIndex: scene.sortedIndex,
        earthDate: scene.date.toISOString()
      });
      lastLabeledSceneDate = scene.date;
    } else if (promoteSet.has(i)) {
      const labels = generateLabel(scene.date, i, false, false);
      ticks.push({
        angle: sceneStartAngle,
        name: labels.name,
        shortName: labels.shortName,
        isMajor: true,
        sceneIndex: scene.sortedIndex,
        earthDate: scene.date.toISOString()
      });
      lastLabeledSceneDate = scene.date;
    } else {
      ticks.push({
        angle: sceneStartAngle,
        name: "",
        shortName: "",
        isMajor: false,
        sceneIndex: scene.sortedIndex
      });
    }
  }
  const hasMinorTicks = ticks.some((tick) => tick.isMajor === false);
  if (!hasMinorTicks && ticks.length > 1) {
    const SYNTHETIC_INTERVAL = Math.PI / 24;
    const MAX_SYNTHETIC_PER_GAP = 12;
    const majorTicks = ticks.filter((tick) => tick.isMajor !== false).map((tick) => ({
      tick,
      positiveAngle: normalizeAnglePositive(tick.angle)
    })).sort((a, b) => a.positiveAngle - b.positiveAngle);
    const syntheticTicks = [];
    for (let i = 0; i < majorTicks.length; i++) {
      const current = majorTicks[i];
      const next = majorTicks[(i + 1) % majorTicks.length];
      let start = current.positiveAngle;
      let end = next.positiveAngle;
      if (i === majorTicks.length - 1 || end <= start) {
        end += Math.PI * 2;
      }
      const gap = end - start;
      const subdivisions = Math.min(MAX_SYNTHETIC_PER_GAP + 1, Math.floor(gap / SYNTHETIC_INTERVAL));
      for (let step2 = 1; step2 < subdivisions; step2++) {
        const anglePositive = start + gap * step2 / subdivisions;
        let angle = normalizeAngleCanonical(anglePositive);
        if (Math.abs(angle - current.tick.angle) < 1e-3 || Math.abs(angle - next.tick.angle) < 1e-3) {
          continue;
        }
        syntheticTicks.push({
          angle,
          name: "",
          shortName: "",
          isMajor: false
        });
      }
    }
    if (syntheticTicks.length > 0) {
      ticks.push(...syntheticTicks);
      ticks.sort((a, b) => normalizeAngleCanonical(a.angle) - normalizeAngleCanonical(b.angle));
    }
  }
  return ticks;
}
function normalizeAngleCanonical(angle) {
  const twoPi = Math.PI * 2;
  let normalized = angle % twoPi;
  if (normalized <= -Math.PI) {
    normalized += twoPi;
  } else if (normalized > Math.PI) {
    normalized -= twoPi;
  }
  return normalized;
}
function normalizeAnglePositive(angle) {
  const twoPi = Math.PI * 2;
  let normalized = angle % twoPi;
  if (normalized < 0) {
    normalized += twoPi;
  }
  return normalized;
}
var MONTH_NAME_MAP, MS_PER_SECOND, MS_PER_MINUTE, MS_PER_HOUR, MS_PER_DAY, MS_PER_WEEK, MS_PER_MONTH, MS_PER_YEAR, ELAPSED_TIME_UNIT_LABELS, ELAPSED_UNIT_SEQUENCE, DURATION_UNIT_DEFINITIONS, DURATION_UNIT_ALIAS_MAP;
var init_date = __esm({
  "src/utils/date.ts"() {
    MONTH_NAME_MAP = {
      january: 0,
      jan: 0,
      february: 1,
      feb: 1,
      march: 2,
      mar: 2,
      april: 3,
      apr: 3,
      may: 4,
      june: 5,
      jun: 5,
      july: 6,
      jul: 6,
      august: 7,
      aug: 7,
      september: 8,
      sept: 8,
      sep: 8,
      october: 9,
      oct: 9,
      november: 10,
      nov: 10,
      december: 11,
      dec: 11
    };
    MS_PER_SECOND = 1e3;
    MS_PER_MINUTE = 60 * MS_PER_SECOND;
    MS_PER_HOUR = 60 * MS_PER_MINUTE;
    MS_PER_DAY = 24 * MS_PER_HOUR;
    MS_PER_WEEK = 7 * MS_PER_DAY;
    MS_PER_MONTH = 30.44 * MS_PER_DAY;
    MS_PER_YEAR = 365.25 * MS_PER_DAY;
    ELAPSED_TIME_UNIT_LABELS = {
      second: { singular: "second", plural: "seconds" },
      minute: { singular: "minute", plural: "minutes" },
      hour: { singular: "hour", plural: "hours" },
      day: { singular: "day", plural: "days" },
      week: { singular: "week", plural: "weeks" },
      month: { singular: "month", plural: "months" },
      year: { singular: "year", plural: "years" }
    };
    ELAPSED_UNIT_SEQUENCE = {
      year: { ms: MS_PER_YEAR, next: "month" },
      month: { ms: MS_PER_MONTH, next: "day" },
      week: { ms: MS_PER_WEEK, next: "day" },
      day: { ms: MS_PER_DAY, next: "hour" },
      hour: { ms: MS_PER_HOUR, next: "minute" },
      minute: { ms: MS_PER_MINUTE, next: "second" },
      second: { ms: MS_PER_SECOND }
    };
    DURATION_UNIT_DEFINITIONS = [
      { key: "seconds", aliases: ["s", "sec", "secs", "second", "seconds"], multiplier: MS_PER_SECOND, singular: "second", plural: "seconds" },
      { key: "minutes", aliases: ["m", "min", "mins", "minute", "minutes"], multiplier: MS_PER_MINUTE, singular: "minute", plural: "minutes" },
      { key: "hours", aliases: ["h", "hr", "hrs", "hour", "hours"], multiplier: MS_PER_HOUR, singular: "hour", plural: "hours" },
      { key: "days", aliases: ["d", "day", "days"], multiplier: MS_PER_DAY, singular: "day", plural: "days" },
      { key: "weeks", aliases: ["w", "wk", "wks", "week", "weeks"], multiplier: MS_PER_WEEK, singular: "week", plural: "weeks" },
      { key: "months", aliases: ["mo", "mon", "mos", "month", "months"], multiplier: MS_PER_MONTH, singular: "month", plural: "months" },
      { key: "years", aliases: ["y", "yr", "yrs", "year", "years"], multiplier: MS_PER_YEAR, singular: "year", plural: "years" }
    ];
    DURATION_UNIT_ALIAS_MAP = /* @__PURE__ */ new Map();
    DURATION_UNIT_DEFINITIONS.forEach((def) => {
      def.aliases.forEach((alias) => DURATION_UNIT_ALIAS_MAP.set(alias, def));
    });
  }
});

// src/utils/sceneHelpers.ts
var sceneHelpers_exports = {};
__export(sceneHelpers_exports, {
  buildSquareClasses: () => buildSquareClasses,
  buildTextClasses: () => buildTextClasses,
  extractGradeFromScene: () => extractGradeFromScene,
  extractPosition: () => extractPosition,
  getSceneState: () => getSceneState,
  isBeatNote: () => isBeatNote,
  isStoryBeat: () => isStoryBeat,
  normalizeBooleanValue: () => normalizeBooleanValue,
  shouldDisplayMissingWhenWarning: () => shouldDisplayMissingWhenWarning,
  sortByManuscriptOrder: () => sortByManuscriptOrder,
  sortScenes: () => sortScenes,
  sortScenesChronologically: () => sortScenesChronologically
});
function normalizeBooleanValue(value) {
  if (typeof value === "boolean") {
    return value;
  }
  if (typeof value === "string") {
    const lower = value.toLowerCase().trim();
    if (lower === "" || lower === " ") {
      return false;
    }
    return lower === "yes" || lower === "true" || lower === "1";
  }
  if (typeof value === "number") {
    return value === 1;
  }
  return false;
}
function isStoryBeat(classValue) {
  if (typeof classValue !== "string") return false;
  const normalized = classValue.toLowerCase().trim();
  return normalized === "plot" || normalized === "beat";
}
function isBeatNote(scene) {
  return scene.itemType === "Beat" || scene.itemType === "Plot";
}
function sortScenes(scenes, sortByWhen, forceChronological = false) {
  if (!forceChronological && !sortByWhen) {
    return scenes.slice().sort(sortByManuscriptOrder);
  }
  return sortScenesChronologically(scenes);
}
function extractGradeFromScene(scene, gradeKey, sceneGrades, plugin) {
  if (!plugin.settings.enableAiSceneAnalysis) return;
  if (!gradeKey) return;
  const analysisText = scene["currentSceneAnalysis"];
  if (!analysisText) return;
  try {
    const firstLine = typeof analysisText === "string" ? analysisText.substring(0, analysisText.indexOf("\n") > -1 ? analysisText.indexOf("\n") : analysisText.length).trim() : "";
    if (!firstLine) return;
    const gradeMatch = firstLine.match(/^-?\s*(?:\d+(?:\.\d+)?\s+)?([ABC])(?![A-Za-z0-9])/i);
    if (gradeMatch && gradeMatch[1]) {
      sceneGrades.set(gradeKey, gradeMatch[1].toUpperCase());
    }
  } catch (e) {
  }
}
function getSceneState(scene, plugin) {
  const isSceneOpen = !!(scene.path && plugin.openScenePaths.has(scene.path));
  const isSearchMatch = !!(plugin.searchActive && scene.path && plugin.searchResults.has(scene.path));
  const hasEdits = !!(scene.pendingEdits && scene.pendingEdits.trim() !== "");
  return { isSceneOpen, isSearchMatch, hasEdits };
}
function buildSquareClasses(isSceneOpen, isSearchMatch, hasEdits) {
  let classes = "rt-number-square";
  if (isSceneOpen) classes += " rt-scene-is-open";
  if (isSearchMatch) classes += " rt-search-result";
  if (hasEdits) classes += " rt-has-edits";
  return classes;
}
function buildTextClasses(isSceneOpen, isSearchMatch, hasEdits) {
  let classes = "rt-number-text";
  if (isSceneOpen) classes += " rt-scene-is-open";
  if (isSearchMatch) classes += " rt-search-result";
  if (hasEdits) classes += " rt-has-edits";
  return classes;
}
function normalizeStatusValue(status) {
  if (!status) return null;
  if (Array.isArray(status)) {
    for (const entry of status) {
      if (typeof entry === "string") {
        const trimmed = entry.trim();
        if (trimmed) return trimmed;
      }
    }
    return null;
  }
  if (typeof status === "string") {
    const trimmed = status.trim();
    return trimmed || null;
  }
  return null;
}
function shouldDisplayMissingWhenWarning(scene) {
  if (!scene || !scene.missingWhen) return false;
  const normalizedStatus = normalizeStatusValue(scene.status);
  if (!normalizedStatus) return false;
  return STATUSES_REQUIRING_WHEN.has(normalizedStatus.toLowerCase());
}
function sortScenesChronologically(scenes) {
  return scenes.slice().sort((a, b) => {
    const aWhen = a.when instanceof Date ? a.when : parseWhenField(typeof a.when === "string" ? a.when : "");
    const bWhen = b.when instanceof Date ? b.when : parseWhenField(typeof b.when === "string" ? b.when : "");
    const aHasWhen = !!(aWhen && !isNaN(aWhen.getTime()));
    const bHasWhen = !!(bWhen && !isNaN(bWhen.getTime()));
    if (aHasWhen && bHasWhen && aWhen && bWhen) {
      const timeDiff = aWhen.getTime() - bWhen.getTime();
      if (timeDiff !== 0) return timeDiff;
      return sortByManuscriptOrder(a, b);
    }
    if (!aHasWhen && !bHasWhen) {
      return sortByManuscriptOrder(a, b);
    }
    if (!aHasWhen && bHasWhen) return -1;
    if (aHasWhen && !bHasWhen) return 1;
    return 0;
  });
}
function extractPosition(item) {
  const title = item.title || "";
  const prefixMatch = title.match(/^(\d+(?:\.\d+)?)\s*/);
  if (prefixMatch) {
    return parseFloat(prefixMatch[1]);
  }
  return Infinity;
}
function sortByManuscriptOrder(a, b) {
  const aPos = extractPosition(a);
  const bPos = extractPosition(b);
  if (aPos !== bPos) {
    if (aPos === Infinity && bPos === Infinity) {
      return (a.title || "").localeCompare(b.title || "");
    }
    return aPos - bPos;
  }
  return (a.title || "").localeCompare(b.title || "");
}
var STATUSES_REQUIRING_WHEN;
var init_sceneHelpers = __esm({
  "src/utils/sceneHelpers.ts"() {
    init_date();
    STATUSES_REQUIRING_WHEN = /* @__PURE__ */ new Set(["working", "complete"]);
  }
});

// src/utils/manuscript.ts
var manuscript_exports = {};
__export(manuscript_exports, {
  assembleManuscript: () => assembleManuscript,
  countWords: () => countWords,
  estimateTokens: () => estimateTokens,
  extractBodyText: () => extractBodyText,
  getSceneFilesByOrder: () => getSceneFilesByOrder,
  getSortedSceneFiles: () => getSortedSceneFiles,
  sliceScenesByRange: () => sliceScenesByRange
});
function stripYamlFrontmatter(content) {
  const yamlPattern = /^---\s*\n([\s\S]*?)\n---\s*\n/;
  return content.replace(yamlPattern, "");
}
function stripObsidianComments2(content) {
  content = content.replace(/%%.*?%%/g, "");
  content = content.replace(/%%[\s\S]*?%%/g, "");
  return content;
}
function extractBodyText(content) {
  let text = stripYamlFrontmatter(content);
  text = stripObsidianComments2(text);
  return text.trim();
}
function countWords(text) {
  const words = text.split(/\s+/).filter((word) => word.length > 0);
  return words.length;
}
function estimateTokens(wordCount) {
  return Math.ceil(wordCount / 0.75);
}
async function getSortedSceneFiles(plugin) {
  var _a;
  const allScenes = await plugin.getSceneData();
  const uniquePaths = /* @__PURE__ */ new Set();
  const uniqueScenes = allScenes.filter((s) => {
    if (s.itemType === "Scene" && s.path && !uniquePaths.has(s.path)) {
      uniquePaths.add(s.path);
      return true;
    }
    return false;
  });
  const currentMode = plugin.settings.currentMode || "narrative";
  const isChronologueMode = currentMode === "chronologue";
  const sortByWhen = isChronologueMode ? true : (_a = plugin.settings.sortByWhenDate) != null ? _a : false;
  const forceChronological = isChronologueMode;
  const { sortScenes: sortScenes3 } = await Promise.resolve().then(() => (init_sceneHelpers(), sceneHelpers_exports));
  const sortedScenes = sortScenes3(uniqueScenes, sortByWhen, forceChronological);
  const sceneFiles = sortedScenes.map((s) => plugin.app.vault.getAbstractFileByPath(s.path)).filter((f) => f instanceof import_obsidian4.TFile);
  let sortOrder;
  if (isChronologueMode) {
    sortOrder = "Chronological (by When date/time)";
  } else {
    sortOrder = "Narrative (by scene title/number)";
  }
  return { files: sceneFiles, sortOrder };
}
async function getSceneFilesByOrder(plugin, order, subplotFilter) {
  const allScenes = await plugin.getSceneData();
  const uniquePaths = /* @__PURE__ */ new Set();
  const uniqueScenes = allScenes.filter((scene) => {
    if (subplotFilter && subplotFilter !== "All Subplots") {
      const sceneSubplot = scene.subplot && scene.subplot.trim().length > 0 ? scene.subplot : "Main Plot";
      if (sceneSubplot !== subplotFilter) return false;
    }
    if (scene.itemType === "Scene" && scene.path && !uniquePaths.has(scene.path)) {
      uniquePaths.add(scene.path);
      return true;
    }
    return false;
  });
  const { sortScenes: sortScenes3, sortScenesChronologically: sortScenesChronologically2 } = await Promise.resolve().then(() => (init_sceneHelpers(), sceneHelpers_exports));
  let sortedScenes;
  let sortOrder;
  if (order === "chronological" || order === "reverse-chronological") {
    sortedScenes = sortScenesChronologically2(uniqueScenes);
    if (order === "reverse-chronological") {
      sortedScenes = sortedScenes.slice().reverse();
      sortOrder = "Reverse chronological (by When date/time)";
    } else {
      sortOrder = "Chronological (by When date/time)";
    }
  } else {
    sortedScenes = sortScenes3(uniqueScenes, false, false);
    if (order === "reverse-narrative") {
      sortedScenes = sortedScenes.slice().reverse();
      sortOrder = "Reverse narrative (by scene title/number)";
    } else {
      sortOrder = "Narrative (by scene title/number)";
    }
  }
  const files = [];
  const titles = [];
  const whenDates = [];
  const sceneNumbers = [];
  for (const scene of sortedScenes) {
    if (!scene.path) continue;
    const file = plugin.app.vault.getAbstractFileByPath(scene.path);
    if (!(file instanceof import_obsidian4.TFile)) continue;
    files.push(file);
    titles.push(file.basename);
    whenDates.push(scene.when ? formatWhenDate(scene.when) : null);
    const numStr = getScenePrefixNumber(scene.title, scene.number);
    sceneNumbers.push(numStr ? parseInt(numStr, 10) || 0 : 0);
  }
  return { files, sortOrder, titles, whenDates, sceneNumbers };
}
function formatWhenDate(date) {
  return date.toLocaleDateString(void 0, { year: "numeric", month: "short", day: "numeric" });
}
function sliceScenesByRange(sceneFiles, startIndex, endIndex) {
  if (!sceneFiles.length) return sceneFiles;
  const start = startIndex && startIndex > 0 ? startIndex : 1;
  const end = endIndex && endIndex > 0 ? endIndex : sceneFiles.length;
  const clampedStart = Math.min(Math.max(start, 1), sceneFiles.length);
  const clampedEnd = Math.min(Math.max(end, clampedStart), sceneFiles.length);
  return sceneFiles.slice(clampedStart - 1, clampedEnd);
}
function generateTableOfContents(scenes, totalWords, useObsidianLinks = false, sortOrder) {
  const tocLines = [
    "# TABLE OF CONTENTS",
    "",
    `Total Scenes: ${scenes.length} | Total Words: ${totalWords.toLocaleString()}`,
    ""
  ];
  if (sortOrder) {
    tocLines.push(`**Sort Order:** ${sortOrder}`);
    tocLines.push("");
  }
  tocLines.push("---", "");
  scenes.forEach((scene, index) => {
    const sceneNum = index + 1;
    if (useObsidianLinks) {
      tocLines.push(`${sceneNum}. [[#${scene.title}]] (${scene.wordCount.toLocaleString()} words)`);
    } else {
      tocLines.push(`${sceneNum}. ${scene.title} (${scene.wordCount.toLocaleString()} words)`);
    }
  });
  tocLines.push("", "---", "", "");
  return tocLines.join("\n");
}
async function assembleManuscript(sceneFiles, vault, progressCallback, useObsidianLinks = false, sortOrder, includeToc = true) {
  const scenes = [];
  const textParts = [];
  let totalWords = 0;
  for (let i = 0; i < sceneFiles.length; i++) {
    const file = sceneFiles[i];
    const title = file.basename;
    if (progressCallback) {
      progressCallback(i + 1, title, sceneFiles.length);
    }
    try {
      const content = await vault.read(file);
      const bodyText = extractBodyText(content);
      const wordCount = countWords(bodyText);
      scenes.push({ title, bodyText, wordCount });
      totalWords += wordCount;
      textParts.push(`## ${title}

${bodyText}

`);
    } catch (error) {
      console.error(`Error reading scene file ${file.path}:`, error);
      textParts.push(`## ${title}

[Error reading scene]

`);
    }
  }
  const toc = includeToc ? generateTableOfContents(scenes, totalWords, useObsidianLinks, sortOrder) : "";
  const manuscriptText = toc + textParts.join("");
  return {
    text: manuscriptText,
    totalWords,
    totalScenes: sceneFiles.length,
    scenes,
    sortOrder
  };
}
var import_obsidian4;
var init_manuscript = __esm({
  "src/utils/manuscript.ts"() {
    import_obsidian4 = require("obsidian");
    init_text();
  }
});

// src/ai/prompts/unifiedBeatAnalysis.ts
function getUnifiedBeatAnalysisJsonSchema() {
  return UNIFIED_BEAT_ANALYSIS_SCHEMA;
}
function buildUnifiedBeatAnalysisPrompt(manuscriptText, beats, beatSystem) {
  const beatList = beats.map((b, i) => {
    const parts = [
      `${i + 1}. ${b.beatName}`,
      `ideal range: ${b.idealRange}`
    ];
    if (typeof b.previousScore === "number") {
      parts.push(`previous score: ${b.previousScore}`);
    }
    if (b.previousJustification) {
      parts.push(`previous note: ${b.previousJustification}`);
    }
    return parts.join(" | ");
  }).join("\n");
  const prompt = `Beat system: ${beatSystem}

Story beats (oldest history first):
${beatList}

Score momentum (0-100) for each listed beat, include a short justification, and set isWithinRange by comparing to the ideal range. Respond strictly in the JSON schema that accompanies this prompt.

Manuscript text (table of contents followed by scenes):
${manuscriptText}`;
  return prompt;
}
var UNIFIED_BEAT_ANALYSIS_SCHEMA;
var init_unifiedBeatAnalysis = __esm({
  "src/ai/prompts/unifiedBeatAnalysis.ts"() {
    UNIFIED_BEAT_ANALYSIS_SCHEMA = {
      type: "object",
      properties: {
        beats: {
          type: "array",
          description: "Momentum analysis for each story beat",
          items: {
            type: "object",
            properties: {
              beatName: {
                type: "string",
                description: "Name of the beat"
              },
              momentumScore: {
                type: "number",
                description: "Narrative momentum score 0-100",
                minimum: 0,
                maximum: 100
              },
              idealRange: {
                type: "string",
                description: "Ideal momentum range for this beat"
              },
              isWithinRange: {
                type: "boolean",
                description: "True if momentum score is within ideal range"
              },
              justification: {
                type: "string",
                description: "Brief justification for the score (one sentence)"
              }
            },
            required: ["beatName", "momentumScore", "idealRange", "isWithinRange", "justification"]
          }
        },
        overallAssessment: {
          type: "object",
          description: "Overall manuscript assessment",
          properties: {
            summary: {
              type: "string",
              description: "Brief summary of overall momentum (max 30 words)"
            },
            strengths: {
              type: "array",
              items: { type: "string" },
              description: "List of 2-3 strengths"
            },
            improvements: {
              type: "array",
              items: { type: "string" },
              description: "List of 2-3 suggested improvements"
            }
          },
          required: ["summary", "strengths", "improvements"]
        }
      },
      required: ["beats", "overallAssessment"]
    };
  }
});

// src/api/geminiApi.ts
async function callGeminiApi(apiKey, modelId, systemPrompt, userPrompt, maxTokens = 4e3, temperature = 0.7, jsonSchema, disableThinking = false, cachedContentName) {
  var _a, _b, _c, _d, _e, _f, _g;
  if (!apiKey) {
    return { success: false, content: null, responseData: { error: { message: "Gemini API key not configured." } }, error: "Gemini API key not configured." };
  }
  if (!modelId) {
    return { success: false, content: null, responseData: { error: { message: "Gemini model ID not configured." } }, error: "Gemini model ID not configured." };
  }
  const cleanModelId = modelId.startsWith("models/") ? modelId.slice(7) : modelId;
  const url = `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(cleanModelId)}:generateContent?key=${encodeURIComponent(apiKey)}`;
  const body = {
    contents: [
      {
        role: "user",
        parts: [{ text: userPrompt }]
      }
    ],
    generationConfig: {
      temperature
    }
  };
  if (cachedContentName) {
    body.cachedContent = cachedContentName;
  }
  if (systemPrompt) {
    body.systemInstruction = { parts: [{ text: systemPrompt }] };
  }
  if (maxTokens !== null) {
    body.generationConfig.maxOutputTokens = maxTokens;
  }
  if (disableThinking) {
  }
  if (jsonSchema) {
    body.generationConfig.responseMimeType = "application/json";
    body.generationConfig.responseSchema = jsonSchema;
  }
  let responseData;
  try {
    const resp = await (0, import_obsidian5.requestUrl)({
      url,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
      throw: false
    });
    responseData = resp.json;
    if (resp.status >= 400) {
      const err = responseData;
      const msg = (_c = (_b = (_a = err == null ? void 0 : err.error) == null ? void 0 : _a.message) != null ? _b : resp.text) != null ? _c : `Gemini error (${resp.status})`;
      return { success: false, content: null, responseData, error: msg };
    }
    const success = responseData;
    if ((success == null ? void 0 : success.promptFeedback) && success.promptFeedback.blockReason) {
      const reason = success.promptFeedback.blockReason;
      return { success: false, content: null, responseData, error: `Gemini safety blocked: ${reason}` };
    }
    const candidate = (_d = success == null ? void 0 : success.candidates) == null ? void 0 : _d[0];
    if (candidate == null ? void 0 : candidate.finishReason) {
      if (candidate.finishReason === "MAX_TOKENS") {
        return {
          success: false,
          content: null,
          responseData,
          error: "Response exceeded maximum token limit. The output was truncated before completion. Try reducing the manuscript size or increasing maxOutputTokens."
        };
      }
      if (candidate.finishReason === "SAFETY") {
        return {
          success: false,
          content: null,
          responseData,
          error: "Response blocked by Gemini safety filters."
        };
      }
      if (candidate.finishReason === "RECITATION") {
        return {
          success: false,
          content: null,
          responseData,
          error: "Response blocked due to recitation concerns."
        };
      }
    }
    const text = (_f = (_e = candidate == null ? void 0 : candidate.content) == null ? void 0 : _e.parts) == null ? void 0 : _f.map((p) => p.text || "").join("").trim();
    if (text) return { success: true, content: text, responseData };
    console.error("[Gemini API] Invalid response structure:", {
      hasCandidates: !!(success == null ? void 0 : success.candidates),
      candidatesLength: ((_g = success == null ? void 0 : success.candidates) == null ? void 0 : _g.length) || 0,
      finishReason: candidate == null ? void 0 : candidate.finishReason
    });
    return { success: false, content: null, responseData, error: "Invalid response structure from Gemini." };
  } catch (e) {
    const msg = e instanceof Error ? e.message : String(e);
    responseData = { error: { message: msg } };
    return { success: false, content: null, responseData, error: msg };
  }
}
async function fetchGeminiModels(apiKey) {
  if (!apiKey) throw new Error("Gemini API key is required to fetch models.");
  const url = `https://generativelanguage.googleapis.com/v1beta/models?key=${encodeURIComponent(apiKey)}`;
  const resp = await (0, import_obsidian5.requestUrl)({ url, method: "GET", throw: false });
  const data = resp.json;
  if (resp.status >= 400 || !Array.isArray(data == null ? void 0 : data.models)) {
    throw new Error(`Error fetching Gemini models (${resp.status})`);
  }
  const mapped = data.models.map((m) => {
    var _a;
    const id = ((_a = m.name) == null ? void 0 : _a.includes("/")) ? m.name.split("/").pop() || m.name : m.name;
    return { id, name: m.displayName || id };
  });
  return mapped.sort((a, b) => a.id.localeCompare(b.id));
}
var import_obsidian5;
var init_geminiApi = __esm({
  "src/api/geminiApi.ts"() {
    import_obsidian5 = require("obsidian");
  }
});

// src/settings/defaults.ts
var DEFAULT_SETTINGS;
var init_defaults = __esm({
  "src/settings/defaults.ts"() {
    init_aiDefaults();
    DEFAULT_SETTINGS = {
      sourcePath: "",
      showSourcePathAsTitle: true,
      // Default: show source path as title of the work
      validFolderPaths: [],
      // Default empty array for folder path history
      aiOutputFolder: "AI",
      actCount: 3,
      actLabelsRaw: "Act 1, Act 2, Act 3",
      showActLabels: true,
      publishStageColors: {
        Zero: "#9E70CF",
        // Purple (Stage Zero)
        Author: "#5E85CF",
        // Blue   (Author)
        House: "#DA7847",
        // Orange (House)
        Press: "#6FB971"
        // Green  (Press)
      },
      subplotColors: [
        "#EFBDEB",
        // 0
        "#a35ca7",
        // 1
        "#6461A0",
        // 2
        "#314CB6",
        // 3
        "#0A81D1",
        // 4
        "#98CE00",
        // 5
        "#16E0BD",
        // 6
        "#78C3FB",
        // 7
        "#273C2C",
        // 8
        "#A6D8D4",
        // 9
        "#FF8600",
        // 10
        "#F9E784",
        // 11
        "#CEC3C1",
        // 12
        "#F3D34A",
        // 13
        "#004777",
        // 14
        "#8B4513"
        // 15 - Brown for Ring 16
      ],
      currentMode: "narrative",
      // Default to Narrative mode
      logApiInteractions: true,
      // Default for new setting
      targetCompletionDate: void 0,
      // Ensure it's undefined by default
      showCompletionEstimate: true,
      // Default: show the estimate tick
      openaiApiKey: "",
      // Default to empty string
      anthropicApiKey: "",
      // Default empty string
      anthropicModelId: "claude-sonnet-4-5-20250929",
      // Default to Sonnet 4.5 (20250929)
      geminiApiKey: "",
      geminiModelId: DEFAULT_GEMINI_MODEL_ID,
      // Default to Gemini 3 Pro Preview
      defaultAiProvider: "openai",
      openaiModelId: "gpt-5.1-chat-latest",
      // Default to GPT-5.1
      enableAiSceneAnalysis: true,
      showFullTripletAnalysis: true,
      enableZeroDraftMode: false,
      metadataRefreshDebounceMs: 1e4,
      discontinuityThreshold: void 0,
      // Default to auto-calculated (3x median gap or 30 days)
      enableSceneTitleAutoExpand: true,
      // Default: enabled to maintain current behavior
      enableHoverDebugLogging: false,
      sortByWhenDate: false,
      // Default: manuscript order (backward compatible)
      chronologueDurationCapSelection: "auto",
      readabilityScale: "normal",
      shouldRestoreTimelineOnLoad: false,
      aiContextTemplates: [
        {
          id: "commercial_genre",
          name: "Commercial Genre Fiction (Balanced Depth)",
          prompt: `Act as a developmental editor for a commercial genre novel. Prioritize pacing, clarity, and emotional stakes. Ensure each scene moves the plot or deepens character conflict. Keep prose lean; prefer tension and subtext to exposition. Focus feedback on momentum, scene purpose, and reader engagement.`,
          isBuiltIn: true
        },
        {
          id: "literary",
          name: "Literary / Character-Driven Fiction",
          prompt: `Act as a developmental editor for a literary or character-driven novel. Emphasize emotional resonance, internal conflict, and subtext. Feedback should focus on authenticity of character motivation, narrative voice, and thematic depth. Avoid line-level polish; focus on the psychological realism of each beat.`,
          isBuiltIn: true
        },
        {
          id: "young_adult",
          name: "Young Adult / Coming-of-Age",
          prompt: `Act as a developmental editor for a young adult coming-of-age novel. Focus on pacing, clear emotional arcs, and voice consistency. Ensure stakes feel personal and immediate. Highlight areas where dialogue or internal monologue can better show growth or vulnerability. Keep feedback concise and energetic.`,
          isBuiltIn: true
        },
        {
          id: "science_fiction",
          name: "Epic or Hard Science Fiction / World-Building Focus",
          prompt: `Act as a developmental editor for a science-fiction novel with complex world-building. Balance clarity and immersion; ensure exposition is dramatized through character action or dialogue. Focus feedback on world logic, pacing through discovery, and integrating big ideas without slowing emotional momentum. Prioritize cohesion between technology, society, and theme.`,
          isBuiltIn: true
        },
        {
          id: "thriller",
          name: "Mystery / Thriller / Suspense",
          prompt: `Act as a developmental editor for a mystery or thriller novel. Emphasize pacing, tension, and clarity of motive. Identify where reveals or reversals land too early or too late. Ensure reader curiosity and suspense are sustained through every scene. Keep feedback focused on plot mechanics and emotional rhythm.`,
          isBuiltIn: true
        },
        {
          id: "romance",
          name: "Romance / Emotional-Arc Focused Fiction",
          prompt: `Act as a developmental editor for a romance or emotionally driven narrative. Focus feedback on relationship dynamics, emotional authenticity, and pacing of attraction/conflict/resolution. Ensure internal and external conflicts are intertwined. Highlight where subtext or tension could replace exposition.`,
          isBuiltIn: true
        }
      ],
      activeAiContextTemplateId: "commercial_genre",
      beatSystem: "Save The Cat",
      // Default beat system
      customBeatSystemName: "Custom",
      customBeatSystemBeats: [],
      dominantSubplots: {},
      // Default: empty map, will use outermost subplot for scenes in multiple subplots
      globalPovMode: "off",
      lastSeenReleaseNotesVersion: "",
      cachedReleaseNotes: null,
      releaseNotesLastFetched: void 0,
      localBaseUrl: "http://localhost:11434/v1",
      localModelId: "llama3",
      localApiKey: "",
      localSendPulseToAiReport: true,
      enablePlanetaryTime: false,
      planetaryProfiles: [],
      activePlanetaryProfileId: void 0,
      frontmatterMappings: {},
      enableCustomMetadataMapping: false,
      enableAdvancedYamlEditor: false,
      sceneYamlTemplates: {
        base: `Class: Scene              # Type: Scene, Beat, Backdrop
Act: {{Act}}              # Which act (1..Act Count)
When: {{When}}            # Story chronology date (YYYY-MM-DD 12:30pm)
Duration: 1 hour         # How long the scene lasts (e.g., "45 seconds", "45s", "45sec", "2 hours", "3days")
Synopsis: Short scene summary.                # Brief description of what happens in this scene
Subplot: {{Subplot}}      # Single subplot (or use array format below for multiple)
Character: {{Character}}  # Characters in the scene (use array format below for multiple)
POV:                      # blank, first, you, third, omni, narrator, two, all, count
Status: Todo              # Scene status (Todo/Working/Complete)
Due: {{When}}             # Target completion date (YYYY-MM-DD). When setting Scene to Complete, change this to that day's date for better novel completion estimate
Publish Stage: Zero       # Revision stage (Zero/Author/House/Press)
Pending Edits:            # Notes for next revision (especially for zero draft mode)
Pulse Update:             # AI-generated scene pulse analysis flag`,
        advanced: `Class: Scene
Act: {{Act}}
When: {{When}}
Duration: 1 hours
Synopsis: Short scene summary.
Subplot:
{{SubplotList}}
Character:
{{CharacterList}}
Place:
{{PlaceList}}
Questions:                           # Analysis Block
Reader Emotion:
Internal: How do the characters change?
Type:
Shift:
Publish Stage: Zero
Status: Todo
Due:                                  # Target completion date (YYYY-MM-DD).
Words:                                # Statistics
Total Time:                           # Tracked time spent writing scene
Revision:                             # Revision count (suggest leaving blank until stage > Zero)
Pending Edits:
Pulse Update: No`
      },
      bookDesignerTemplates: [],
      backdropYamlTemplate: `Class: Backdrop                   # Backdrop events appear below the outer ring in Chronologue Mode
When: {{When}}                       # Start Date/Time (YYYY-MM-DD HH:MM)
End: {{End}}                         # End Date/Time (YYYY-MM-DD HH:MM)
Synopsis: What this backdrop represents and how it shapes the story.`
    };
  }
});

// src/utils/aiOutput.ts
function resolveAiOutputFolder(plugin) {
  var _a;
  const raw = ((_a = plugin.settings.aiOutputFolder) == null ? void 0 : _a.trim()) || DEFAULT_SETTINGS.aiOutputFolder || "AI";
  return (0, import_obsidian6.normalizePath)(raw);
}
async function ensureAiOutputFolder(plugin) {
  const folder = resolveAiOutputFolder(plugin);
  try {
    await plugin.app.vault.createFolder(folder);
  } catch (e) {
  }
  return folder;
}
var import_obsidian6;
var init_aiOutput = __esm({
  "src/utils/aiOutput.ts"() {
    import_obsidian6 = require("obsidian");
    init_defaults();
  }
});

// src/GossamerCommands.ts
var GossamerCommands_exports = {};
__export(GossamerCommands_exports, {
  getActiveGossamerRun: () => getActiveGossamerRun,
  openGossamerScoreEntry: () => openGossamerScoreEntry,
  parseScoresFromClipboard: () => parseScoresFromClipboard,
  resetGossamerModeState: () => resetGossamerModeState,
  resetRotation: () => resetRotation,
  restoreBaseMode: () => restoreBaseMode,
  runGossamerAiAnalysis: () => runGossamerAiAnalysis,
  setBaseModeAllScenes: () => setBaseModeAllScenes,
  toggleGossamerMode: () => toggleGossamerMode
});
function parseScoresFromClipboard(clipboardText) {
  const scores = /* @__PURE__ */ new Map();
  const simpleFormatRegex = /(\d+)\s*:\s*(\d+)/g;
  const simpleMatches = Array.from(clipboardText.matchAll(simpleFormatRegex));
  if (simpleMatches.length > 0) {
    for (const match2 of simpleMatches) {
      const position = parseInt(match2[1]);
      const score = parseInt(match2[2]);
      if (!isNaN(position) && !isNaN(score) && score >= 0 && score <= 100) {
        scores.set(`__position_${position}`, score);
      }
    }
    return scores;
  }
  const lineRegex = /^(.+?):\s*(\d+)\s*$/gm;
  let match;
  while ((match = lineRegex.exec(clipboardText)) !== null) {
    const beatName = match[1].trim();
    const score = parseInt(match[2]);
    if (!isNaN(score) && score >= 0 && score <= 100) {
      scores.set(beatName, score);
      const normalizedBeat = normalizeBeatName(beatName);
      scores.set(normalizedBeat, score);
      const withoutNumber = beatName.replace(/^\d+\.?\s*/, "").trim();
      if (withoutNumber !== beatName) {
        scores.set(withoutNumber, score);
        scores.set(normalizeBeatName(withoutNumber), score);
      }
      const withoutPercent = beatName.replace(/\s*\d+(?:\s*-\s*\d+)?\s*%?\s*$/i, "").trim();
      if (withoutPercent !== beatName) {
        scores.set(withoutPercent, score);
        scores.set(normalizeBeatName(withoutPercent), score);
      }
      const withoutNumberAndPercent = beatName.replace(/^\d+\.?\s*/, "").replace(/\s*\d+(?:\s*-\s*\d+)?\s*%?\s*$/i, "").trim();
      if (withoutNumberAndPercent !== beatName && withoutNumberAndPercent !== withoutNumber && withoutNumberAndPercent !== withoutPercent) {
        scores.set(withoutNumberAndPercent, score);
        scores.set(normalizeBeatName(withoutNumberAndPercent), score);
      }
      const coreBeatName = beatName.replace(/^\d+\.?\s*/, "").replace(/\s*\d+(?:\s*-\s*\d+)?\s*%?\s*$/i, "").replace(/\s+of\s+/gi, " ").trim();
      if (coreBeatName !== beatName && coreBeatName !== withoutNumber && coreBeatName !== withoutPercent && coreBeatName !== withoutNumberAndPercent) {
        scores.set(coreBeatName, score);
        scores.set(normalizeBeatName(coreBeatName), score);
      }
    }
  }
  return scores;
}
function setInMemoryRun(plugin, run) {
  lastRunByPlugin.set(plugin, run);
  plugin._gossamerLastRun = run;
}
async function openGossamerScoreEntry(plugin) {
  const scenes = await plugin.getSceneData();
  const plotBeats = scenes.filter((s) => s.itemType === "Beat" || s.itemType === "Plot");
  if (plotBeats.length === 0) {
    new import_obsidian7.Notice('No story beats found. Create notes with frontmatter "Class: Beat" (or "Class: Plot" deprecated).');
    return;
  }
  const modal = new GossamerScoreModal(plugin.app, plugin, plotBeats);
  modal.open();
}
function getActiveGossamerRun(plugin) {
  var _a;
  return (_a = lastRunByPlugin.get(plugin)) != null ? _a : null;
}
async function toggleGossamerMode(plugin) {
  var _a;
  const view = getFirstView(plugin);
  if (!view) return;
  const current = getInteractionMode(view) === "gossamer";
  if (current) {
    exitGossamerMode(plugin);
  } else {
    const scenes = await plugin.getSceneData();
    const beatNotes = scenes.filter((s) => s.itemType === "Beat" || s.itemType === "Plot");
    if (beatNotes.length === 0) {
      new import_obsidian7.Notice('Cannot enter Gossamer mode: No story beats found. Create notes with frontmatter "Class: Beat" (or "Class: Plot" for backward compatibility).');
      return;
    }
    const selectedBeatModel = ((_a = plugin.settings.beatSystem) == null ? void 0 : _a.trim()) || void 0;
    const allRuns = buildAllGossamerRuns(scenes, selectedBeatModel);
    if (allRuns.current.beats.length === 0) {
      const systemMsg = selectedBeatModel ? ` with Beat Model: ${selectedBeatModel}` : "";
      new import_obsidian7.Notice(`Cannot enter Gossamer mode: No story beat notes found${systemMsg}. Create notes with Class: Beat (or Class: Plot for backward compatibility).`);
      return;
    }
    if (!allRuns.hasAnyScores) {
      new import_obsidian7.Notice('No Gossamer scores found. Showing ideal ranges and spokes. Add scores using "Gossamer enter momentum scores" command.');
    }
    setInMemoryRun(plugin, allRuns.current);
    plugin._gossamerHistoricalRuns = allRuns.historical;
    plugin._gossamerMinMax = allRuns.minMax;
    setBaseModeAllScenes(plugin);
    resetRotation(plugin);
    plugin.clearSearch();
    enterGossamerMode(plugin);
  }
}
async function enterGossamerMode(plugin) {
  var _a, _b;
  const view = getFirstView(plugin);
  if (!view) return;
  const modeManager = hasKey(view, "getModeManager") && typeof view.getModeManager === "function" ? view.getModeManager() : null;
  if (modeManager) {
    await modeManager.switchMode("gossamer" /* GOSSAMER */);
  } else {
    if (hasKey(view, "currentMode")) {
      view.currentMode = "gossamer";
    }
    plugin.settings.currentMode = "gossamer";
    plugin.saveSettings();
  }
  if (!modeManager) {
    const v = view;
    const svg = (_b = (_a = v == null ? void 0 : v.containerEl) == null ? void 0 : _a.querySelector) == null ? void 0 : _b.call(_a, ".radial-timeline-svg");
    let didSelective = false;
    try {
      const rs = plugin.getRendererService && plugin.getRendererService() || plugin.rendererService;
      if (rs && v) {
        v.sceneData = plugin.lastSceneData || v.sceneData;
        v.currentMode = "gossamer";
        const viewArg = {
          containerEl: v.containerEl,
          plugin,
          sceneData: v.sceneData,
          currentMode: "gossamer"
        };
        didSelective = rs.updateGossamerLayer(viewArg);
      }
      if (didSelective && svg) {
        svg.setAttribute("data-gossamer-mode", "true");
        const allElements = svg.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title");
        allElements.forEach((el) => {
          const group = el.closest(".rt-scene-group");
          const itemType = group == null ? void 0 : group.getAttribute("data-item-type");
          if (itemType !== "Beat") {
            el.classList.add("rt-non-selected");
          }
        });
        const modeToggle = svg.querySelector("#mode-toggle");
        if (modeToggle) {
          const originalMode = _previousBaseMode || "narrative";
          modeToggle.setAttribute("data-current-mode", originalMode);
          const title = modeToggle.querySelector("title");
          if (title) {
            title.textContent = originalMode === "allscenes" ? "Switch to Main Plot mode" : "Switch to All Scenes mode";
          }
        }
        const setup = v == null ? void 0 : v.setupGossamerEventListeners;
        if (typeof setup === "function") setup(svg);
      }
    } catch (e) {
    }
    if (!didSelective) {
      plugin.refreshTimelineIfNeeded(void 0);
    }
  }
}
async function exitGossamerMode(plugin) {
  var _a;
  if (_isExitingGossamer) {
    return;
  }
  const view = getFirstView(plugin);
  if (!view) {
    return;
  }
  _isExitingGossamer = true;
  const modeManager = hasKey(view, "getModeManager") && typeof view.getModeManager === "function" ? view.getModeManager() : null;
  if (modeManager) {
    const restoredMode2 = restoreBaseMode(plugin);
    await modeManager.switchMode(restoredMode2);
    window.setTimeout(() => {
      _isExitingGossamer = false;
    }, 100);
    return;
  }
  const svg = (_a = view == null ? void 0 : view.containerEl) == null ? void 0 : _a.querySelector(".radial-timeline-svg");
  if (svg) {
    const allElements = svg.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title, .rt-subplot-ring-label-text");
    allElements.forEach((el) => el.classList.remove("rt-non-selected"));
    svg.removeAttribute("data-gossamer-mode");
  }
  if (svg && typeof view.removeGossamerEventListeners === "function") {
    view.removeGossamerEventListeners(svg);
  }
  const restoredMode = restoreBaseMode(plugin);
  if (hasKey(view, "currentMode")) {
    view.currentMode = restoredMode;
  }
  plugin.settings.currentMode = restoredMode;
  plugin.saveSettings();
  if (typeof view.refreshTimeline === "function") {
    view.refreshTimeline();
  } else {
    plugin.refreshTimelineIfNeeded(null);
  }
  window.setTimeout(() => {
    _isExitingGossamer = false;
  }, 100);
}
function setBaseModeAllScenes(plugin) {
  if (_previousBaseMode === null) {
    _previousBaseMode = plugin.settings.currentMode || "narrative";
  }
}
function restoreBaseMode(plugin) {
  if (_previousBaseMode !== null) {
    const mode = _previousBaseMode;
    _previousBaseMode = null;
    return mode;
  }
  return "narrative";
}
function resetGossamerModeState() {
  _previousBaseMode = null;
}
function resetRotation(plugin) {
  const views = getAllViews(plugin);
  if (!Array.isArray(views)) return;
  views.forEach((view) => {
    if (hasKey(view, "rotationState")) {
      view.rotationState = false;
    }
  });
}
function getAllViews(plugin) {
  const timelineService = plugin.timelineService;
  if (timelineService && typeof timelineService.getTimelineViews === "function") {
    return timelineService.getTimelineViews();
  }
  return null;
}
function getFirstView(plugin) {
  const timelineService = plugin.timelineService;
  if (timelineService && typeof timelineService.getFirstTimelineView === "function") {
    return timelineService.getFirstTimelineView();
  }
  const views = getAllViews(plugin);
  return views && views.length > 0 ? views[0] : null;
}
function hasKey(obj, key) {
  return typeof obj === "object" && obj !== null && key in obj;
}
function getInteractionMode(view) {
  if (hasKey(view, "currentMode")) {
    const val = view.currentMode;
    if (val === "narrative" || val === "gossamer" || val === "subplot") return val;
  }
  return void 0;
}
async function runGossamerAiAnalysis(plugin) {
  var _a;
  const settingsBeatSystem = plugin.settings.beatSystem || "Save The Cat";
  let beatSystemDisplayName = settingsBeatSystem;
  if (settingsBeatSystem === "Custom") {
    const scenes = await plugin.getSceneData({ filterBeatsBySystem: false });
    const allBeats = scenes.filter((s) => s.itemType === "Beat" || s.itemType === "Plot");
    const recognizedSystems = ["Save The Cat", "Hero's Journey", "Story Grid"];
    for (const beat of allBeats) {
      if (!beat.path) continue;
      const file = plugin.app.vault.getAbstractFileByPath(beat.path);
      if (!file) continue;
      const cache = plugin.app.metadataCache.getFileCache(file);
      const beatModel = (_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a["Beat Model"];
      if (beatModel && !recognizedSystems.includes(beatModel)) {
        beatSystemDisplayName = beatModel;
        break;
      }
    }
  }
  const beatSystem = settingsBeatSystem;
  const processAnalysis = async (options, modal) => {
    var _a2;
    try {
      modal.setStatus("Validating configuration...");
      if (!plugin.settings.geminiApiKey || plugin.settings.geminiApiKey.trim() === "") {
        modal.addError("Gemini API key not configured. Go to Settings \u2192 AI \u2192 Gemini API key.");
        modal.completeProcessing(false, "Configuration error");
        new import_obsidian7.Notice("Gemini API key not configured. Go to Settings \u2192 AI \u2192 Gemini API key.");
        return;
      }
      modal.setStatus("Loading story beats...");
      const scenes = await plugin.getSceneData();
      let plotBeats = scenes.filter((s) => s.itemType === "Beat" || s.itemType === "Plot");
      const { filterBeatsBySystem: filterBeatsBySystem2 } = await Promise.resolve().then(() => (init_gossamer(), gossamer_exports));
      if (beatSystem && beatSystem.trim() !== "" && plotBeats.some((p) => p["Beat Model"])) {
        plotBeats = filterBeatsBySystem2(plotBeats, beatSystem, plugin.settings.customBeatSystemName);
      }
      if (plotBeats.length === 0) {
        modal.addError('No story beats found. Create notes with frontmatter "Class: Beat".');
        modal.completeProcessing(false, "No beats found");
        new import_obsidian7.Notice('No story beats found. Create notes with frontmatter "Class: Beat".');
        return;
      }
      const beats = plotBeats.sort((a, b) => {
        const aMatch = (a.title || "").match(/^(\d+(?:\.\d+)?)/);
        const bMatch = (b.title || "").match(/^(\d+(?:\.\d+)?)/);
        const aNum = aMatch ? parseFloat(aMatch[1]) : 0;
        const bNum = bMatch ? parseFloat(bMatch[1]) : 0;
        return aNum - bNum;
      }).map((beat, index) => {
        const beatData = beat;
        const file = plugin.app.vault.getAbstractFileByPath(beat.path || "");
        const cache = file ? plugin.app.metadataCache.getFileCache(file) : null;
        const fm = cache == null ? void 0 : cache.frontmatter;
        const rangeValue = typeof (fm == null ? void 0 : fm.Range) === "string" ? fm.Range : "0-100";
        return {
          beatName: (beat.title || "Unknown Beat").replace(/^\d+(?:\.\d+)?\s+/, ""),
          beatNumber: index + 1,
          idealRange: rangeValue,
          previousScore: typeof beatData[beatData.GossamerLatestRun ? `Gossamer${beatData.GossamerLatestRun}` : "Gossamer1"] === "number" ? beatData[beatData.GossamerLatestRun ? `Gossamer${beatData.GossamerLatestRun}` : "Gossamer1"] : void 0,
          previousJustification: typeof beatData[beatData.GossamerLatestRun ? `Gossamer${beatData.GossamerLatestRun} Justification` : "Gossamer1 Justification"] === "string" ? beatData[beatData.GossamerLatestRun ? `Gossamer${beatData.GossamerLatestRun} Justification` : "Gossamer1 Justification"] : void 0
        };
      });
      modal.setStatus("Assembling manuscript with table of contents...");
      const { getSortedSceneFiles: getSortedSceneFiles2 } = await Promise.resolve().then(() => (init_manuscript(), manuscript_exports));
      const { files: sceneFiles, sortOrder } = await getSortedSceneFiles2(plugin);
      if (sceneFiles.length === 0) {
        modal.addError("No scenes found in source path.");
        modal.completeProcessing(false, "No scenes found");
        new import_obsidian7.Notice("No scenes found in source path.");
        return;
      }
      const manuscript = await assembleManuscript(sceneFiles, plugin.app.vault, void 0, true, sortOrder);
      if (!manuscript.text || manuscript.text.trim().length === 0) {
        modal.addError("Manuscript is empty. Check that your scene files have content.");
        modal.completeProcessing(false, "Empty manuscript");
        new import_obsidian7.Notice("Manuscript is empty. Check that your scene files have content.");
        return;
      }
      const estimatedTokens = Math.ceil(manuscript.text.length / 4);
      const manuscriptInfo = {
        totalScenes: manuscript.totalScenes,
        totalWords: manuscript.totalWords,
        estimatedTokens,
        beatCount: beats.length,
        beatSystem: beatSystemDisplayName,
        // Use display name (may include custom name)
        hasIterativeContext: beats.some((b) => b.previousScore !== void 0)
      };
      modal.setManuscriptInfo(manuscriptInfo);
      modal.setStatus("Building analysis prompt...");
      const prompt = buildUnifiedBeatAnalysisPrompt(manuscript.text, beats, beatSystem);
      const schema = getUnifiedBeatAnalysisJsonSchema();
      modal.setStatus("Sending manuscript to Gemini API for momentum analysis...");
      modal.apiCallStarted();
      const geminiModelId = resolveGeminiModelId(plugin);
      const result = await callGeminiApi(
        plugin.settings.geminiApiKey,
        geminiModelId,
        null,
        // No system prompt - instructions in user prompt
        prompt,
        9e3,
        // Allow larger JSON output
        0.7,
        // Temperature
        schema
      );
      if (!result.success || !result.content) {
        modal.apiCallError(result.error || "Failed to get response from Gemini");
        modal.completeProcessing(false, "API call failed");
        if ((_a2 = result.error) == null ? void 0 : _a2.toLowerCase().includes("rate limit")) {
          modal.showRateLimitWarning();
        }
        if (plugin.settings.logApiInteractions) {
          await createFailureDiagnosticReport(
            plugin,
            manuscript,
            beats,
            beatSystem,
            prompt,
            result.error || "Unknown error"
          );
        }
        throw new Error(result.error || "Failed to get response from Gemini");
      }
      modal.apiCallSuccess();
      modal.setStatus("Parsing AI response...");
      const analysis = JSON.parse(result.content);
      modal.setStatus("Updating beat notes...");
      const files = plugin.app.vault.getMarkdownFiles();
      let updateCount = 0;
      const unmatchedBeats = [];
      for (let i = 0; i < analysis.beats.length; i++) {
        const beat = analysis.beats[i];
        const matchingBeat = plotBeats[i];
        if (!matchingBeat) {
          unmatchedBeats.push(beat.beatName);
          continue;
        }
        const file = matchingBeat.path ? plugin.app.vault.getAbstractFileByPath(matchingBeat.path) : null;
        if (!file || !(file instanceof import_obsidian7.TFile)) {
          unmatchedBeats.push(beat.beatName);
          continue;
        }
        await plugin.app.fileManager.processFrontMatter(file, (yaml) => {
          const fm = yaml;
          const { nextIndex, updated } = appendGossamerScore(fm);
          Object.assign(fm, updated);
          fm[`Gossamer${nextIndex}`] = beat.momentumScore;
          fm[`Gossamer${nextIndex} Justification`] = beat.justification || "";
          const now = /* @__PURE__ */ new Date();
          const timestamp2 = now.toLocaleString(void 0, {
            year: "numeric",
            month: "short",
            day: "numeric",
            hour: "numeric",
            minute: "2-digit",
            hour12: true
          });
          const modelId = resolveGeminiModelId(plugin);
          fm["Gossamer Last Updated"] = `${timestamp2} by ${modelId}`;
        });
        updateCount++;
      }
      if (unmatchedBeats.length > 0) {
        modal.addError(`Could not match ${unmatchedBeats.length} beat(s): ${unmatchedBeats.join(", ")}`);
      }
      modal.setStatus("Generating analysis report...");
      const reportTimestamp = /* @__PURE__ */ new Date();
      const timestamp = reportTimestamp.toLocaleString();
      const reportLines = [
        `# Gossamer Momentum Analysis Report`,
        ``,
        `**Date:** ${timestamp}`,
        `**Beat System:** ${beatSystem}`,
        `**Model:** ${resolveGeminiModelId(plugin)}`,
        `**Manuscript:** ${manuscript.totalScenes} scenes, ${manuscript.totalWords.toLocaleString()} words`,
        `**Beats Updated:** ${updateCount} of ${analysis.beats.length}`,
        ``,
        `---`,
        ``,
        `## Summary`,
        ``,
        analysis.overallAssessment.summary,
        ``,
        `**Strengths:**`,
        ...analysis.overallAssessment.strengths.map((s) => `- ${s}`),
        ``,
        `**Improvements:**`,
        ...analysis.overallAssessment.improvements.map((i) => `- ${i}`),
        ``
      ];
      if (unmatchedBeats.length > 0) {
        reportLines.push(`**\u26A0\uFE0F Unmatched Beats:** ${unmatchedBeats.length} beat(s) could not be matched to notes: ${unmatchedBeats.join(", ")}`);
        reportLines.push(``);
      }
      reportLines.push(`**Beat Scores:**`);
      reportLines.push(``);
      reportLines.push(`| Beat | Score | Range | Status |`);
      reportLines.push(`|------|-------|-------|--------|`);
      for (const beat of analysis.beats) {
        const status = beat.isWithinRange ? "\u2713" : "\u26A0\uFE0F";
        reportLines.push(`| ${beat.beatName} | ${beat.momentumScore} | ${beat.idealRange} | ${status} |`);
      }
      reportLines.push(``);
      reportLines.push(`---`);
      reportLines.push(``);
      reportLines.push(`## Debug Information`);
      reportLines.push(``);
      reportLines.push(`### Manuscript Scenes Sent`);
      reportLines.push(``);
      reportLines.push(`The following ${manuscript.totalScenes} scenes were assembled and sent to Gemini (with table of contents):`);
      reportLines.push(``);
      manuscript.scenes.forEach((scene, idx) => {
        const wordCount = scene.wordCount || 0;
        reportLines.push(`${idx + 1}. ${scene.title || "Untitled Scene"} (${wordCount.toLocaleString()} words)`);
      });
      reportLines.push(``);
      reportLines.push(`**Total Words:** ${manuscript.totalWords.toLocaleString()}`);
      reportLines.push(``);
      reportLines.push(`### Prompt Sent to Gemini`);
      reportLines.push(``);
      reportLines.push(`\`\`\`markdown`);
      reportLines.push(prompt);
      reportLines.push(`\`\`\``);
      reportLines.push(``);
      reportLines.push(`### JSON Response Received from Gemini`);
      reportLines.push(``);
      reportLines.push(`\`\`\`json`);
      reportLines.push(result.content || "");
      reportLines.push(`\`\`\``);
      reportLines.push(``);
      let reportFile;
      let aiFolderPath = resolveAiOutputFolder(plugin);
      if (plugin.settings.logApiInteractions) {
        aiFolderPath = await ensureAiOutputFolder(plugin);
        const reportDate = /* @__PURE__ */ new Date();
        const dateStr = reportDate.toLocaleDateString(void 0, {
          year: "numeric",
          month: "short",
          day: "numeric"
        });
        const timeStr = reportDate.toLocaleTimeString(void 0, {
          hour: "numeric",
          minute: "2-digit",
          hour12: true
        }).replace(/:/g, ".");
        const reportPath = `${aiFolderPath}/Gossamer Analysis ${dateStr} ${timeStr}.md`;
        reportFile = await plugin.app.vault.create(reportPath, reportLines.join("\n"));
        const leaf = plugin.app.workspace.getLeaf("tab");
        await leaf.openFile(reportFile);
      }
      const successMessage = `\u2713 Updated ${updateCount} beats with momentum scores`;
      const logMessage = plugin.settings.logApiInteractions ? `${successMessage}. Report saved to ${aiFolderPath} (includes full manuscript).` : `${successMessage}. (Logging disabled - no report saved)`;
      modal.completeProcessing(true, successMessage);
      new import_obsidian7.Notice(logMessage);
    } catch (e) {
      const errorMsg = (e == null ? void 0 : e.message) || "Unknown error";
      modal.addError(`Processing failed: ${errorMsg}`);
      modal.completeProcessing(false, "Processing failed");
      new import_obsidian7.Notice(`Failed to run Gossamer AI analysis: ${errorMsg}`);
      console.error("[Gossamer AI]", e);
    }
  };
  try {
    const scenes = await plugin.getSceneData();
    let plotBeats = scenes.filter((s) => s.itemType === "Beat" || s.itemType === "Plot");
    const { filterBeatsBySystem: filterBeatsBySystem2 } = await Promise.resolve().then(() => (init_gossamer(), gossamer_exports));
    if (beatSystem && beatSystem.trim() !== "" && plotBeats.some((p) => p["Beat Model"])) {
      plotBeats = filterBeatsBySystem2(plotBeats, beatSystem);
    }
    const { getSortedSceneFiles: getSortedSceneFiles2 } = await Promise.resolve().then(() => (init_manuscript(), manuscript_exports));
    const { files: sceneFiles } = await getSortedSceneFiles2(plugin);
    const manuscript = await assembleManuscript(sceneFiles, plugin.app.vault);
    const estimatedTokens = Math.ceil(manuscript.text.length / 4);
    const beatsWithPreviousAnalysis = plotBeats.filter((beat) => {
      const beatData = beat;
      const latestRun = beatData.GossamerLatestRun || 1;
      return typeof beatData[`Gossamer${latestRun} Justification`] === "string";
    }).length;
    const manuscriptInfo = {
      totalScenes: manuscript.totalScenes,
      totalWords: manuscript.totalWords,
      estimatedTokens,
      beatCount: plotBeats.length,
      beatSystem: beatSystemDisplayName,
      // Use display name (may include custom name)
      hasIterativeContext: beatsWithPreviousAnalysis > 0
    };
    const modal = new GossamerProcessingModal(plugin.app, plugin, async (options) => {
      await processAnalysis(options, modal);
    });
    modal.open();
    modal.setManuscriptInfo(manuscriptInfo);
  } catch (e) {
    const errorMsg = (e == null ? void 0 : e.message) || "Unknown error";
    new import_obsidian7.Notice(`Failed to prepare Gossamer analysis: ${errorMsg}`);
    console.error("[Gossamer AI Pre-check]", e);
  }
}
async function createFailureDiagnosticReport(plugin, manuscript, beats, beatSystem, prompt, errorMessage) {
  const reportTimestamp = /* @__PURE__ */ new Date();
  const timestamp = reportTimestamp.toLocaleString();
  const reportLines = [
    `# Gossamer AI Analysis - FAILED`,
    ``,
    `**Date:** ${timestamp}`,
    `**Beat System:** ${beatSystem}`,
    `**Model:** ${resolveGeminiModelId(plugin)}`,
    `**Error:** ${errorMessage}`,
    ``,
    `---`,
    ``,
    `## Error Details`,
    ``,
    errorMessage,
    ``,
    `## Manuscript Sent`,
    ``,
    `**Scenes:** ${manuscript.totalScenes}`,
    `**Words:** ${manuscript.totalWords.toLocaleString()}`,
    `**Estimated Input Tokens:** ~${Math.ceil(manuscript.text.length / 4).toLocaleString()}`,
    `**Story Beats:** ${beats.length}`,
    ``,
    `### Scene List`,
    ``
  ];
  manuscript.scenes.forEach((scene, idx) => {
    const wordCount = scene.wordCount || 0;
    reportLines.push(`${idx + 1}. ${scene.title || "Untitled Scene"} (${wordCount.toLocaleString()} words)`);
  });
  reportLines.push(``);
  reportLines.push(`### Prompt Sent to Gemini`);
  reportLines.push(``);
  reportLines.push(`\`\`\`markdown`);
  reportLines.push(prompt);
  reportLines.push(`\`\`\``);
  reportLines.push(``);
  const reportDate = /* @__PURE__ */ new Date();
  const dateStr = reportDate.toLocaleDateString(void 0, {
    year: "numeric",
    month: "short",
    day: "numeric"
  });
  const timeStr = reportDate.toLocaleTimeString(void 0, {
    hour: "numeric",
    minute: "2-digit",
    hour12: true
  }).replace(/:/g, ".");
  const aiFolderPath = await ensureAiOutputFolder(plugin);
  const reportPath = `${aiFolderPath}/Gossamer Analysis FAILED ${dateStr} ${timeStr}.md`;
  const reportFile = await plugin.app.vault.create(reportPath, reportLines.join("\n"));
  const leaf = plugin.app.workspace.getLeaf("tab");
  await leaf.openFile(reportFile);
  new import_obsidian7.Notice(`\u26A0\uFE0F Analysis failed. Diagnostic report saved to ${aiFolderPath}.`);
}
var import_obsidian7, resolveGeminiModelId, lastRunByPlugin, _previousBaseMode, _isExitingGossamer;
var init_GossamerCommands = __esm({
  "src/GossamerCommands.ts"() {
    init_aiDefaults();
    init_gossamer();
    import_obsidian7 = require("obsidian");
    init_GossamerScoreModal();
    init_GossamerProcessingModal();
    init_ModeDefinition();
    init_manuscript();
    init_unifiedBeatAnalysis();
    init_geminiApi();
    init_aiOutput();
    resolveGeminiModelId = (plugin) => {
      var _a;
      return ((_a = plugin == null ? void 0 : plugin.settings) == null ? void 0 : _a.geminiModelId) || DEFAULT_GEMINI_MODEL_ID;
    };
    lastRunByPlugin = /* @__PURE__ */ new WeakMap();
    _previousBaseMode = null;
    _isExitingGossamer = false;
  }
});

// src/modes/definitions/AllScenesMode.ts
var NARRATIVE_MODE;
var init_AllScenesMode = __esm({
  "src/modes/definitions/AllScenesMode.ts"() {
    init_ModeDefinition();
    NARRATIVE_MODE = {
      id: "narrative" /* NARRATIVE */,
      name: "Narrative",
      description: "View all scenes across all subplots in manuscript order with subplot coloring",
      rendering: {
        outerRingContent: "narrative",
        innerRingContent: "subplot-scenes",
        beatDisplay: "outer-ring-slices",
        sceneColoring: "subplot",
        numberSquares: "full",
        overlayLayers: [],
        visualMuting: []
      },
      interactions: {
        hoverBehavior: "standard-scene-hover",
        clickBehavior: "open-scene-file",
        enableZeroDraftMode: true,
        exitBehavior: "toggle-button"
      },
      ui: {
        acronym: "NARR",
        tooltip: "Switch to Subplot mode",
        showInToggleButton: true,
        order: 1
      }
    };
  }
});

// src/modes/definitions/MainPlotMode.ts
var SUBPLOT_MODE;
var init_MainPlotMode = __esm({
  "src/modes/definitions/MainPlotMode.ts"() {
    init_ModeDefinition();
    SUBPLOT_MODE = {
      id: "subplot" /* SUBPLOT */,
      name: "Subplot",
      description: "View Main Plot scenes with publish stage coloring, other subplots in inner rings",
      rendering: {
        outerRingContent: "subplot-only",
        innerRingContent: "subplot-scenes",
        beatDisplay: "none",
        sceneColoring: "publish-stage",
        numberSquares: "full",
        overlayLayers: [],
        visualMuting: ["non-main-plot"]
      },
      interactions: {
        hoverBehavior: "plot-only-hover",
        clickBehavior: "open-plot-file",
        enableZeroDraftMode: true,
        exitBehavior: "toggle-button"
      },
      ui: {
        acronym: "SUBP",
        tooltip: "Switch to Narrative mode",
        showInToggleButton: true,
        order: 2
      }
    };
  }
});

// src/modes/definitions/GossamerMode.ts
var import_obsidian8, GOSSAMER_MODE;
var init_GossamerMode = __esm({
  "src/modes/definitions/GossamerMode.ts"() {
    import_obsidian8 = require("obsidian");
    init_ModeDefinition();
    GOSSAMER_MODE = {
      id: "gossamer" /* GOSSAMER */,
      name: "Gossamer",
      description: "Gossamer score analysis overlay with beat tracking and historical data",
      rendering: {
        outerRingContent: "narrative",
        innerRingContent: "subplot-scenes",
        beatDisplay: "outer-ring-slices",
        sceneColoring: "subplot",
        numberSquares: "full",
        overlayLayers: [
          "gossamer-dots",
          "gossamer-spokes",
          "gossamer-outlines",
          "confidence-band"
        ],
        visualMuting: ["non-plot"]
      },
      interactions: {
        hoverBehavior: "gossamer-bidirectional",
        clickBehavior: "gossamer-open-file",
        enableZeroDraftMode: false,
        // Gossamer mode has its own click behavior
        exitBehavior: "click-background"
        // Custom handlers are registered in GossamerMode.ts in view/modes
      },
      ui: {
        acronym: "GOSS",
        tooltip: "Switch to Gossamer mode",
        showInToggleButton: true,
        // Show in mode toggle button
        order: 3
      },
      // Lifecycle hooks
      onEnter: async (view) => {
        var _a;
        const plugin = view.plugin;
        const scenes = await plugin.getSceneData();
        const beatNotes = scenes.filter((s) => s.itemType === "Beat" || s.itemType === "Plot");
        if (beatNotes.length === 0) {
          new import_obsidian8.Notice('Cannot enter Gossamer mode: No story beats found. Create notes with frontmatter "Class: Beat" (or "Class: Plot" for backward compatibility).');
          throw new Error("Cannot enter Gossamer mode: No story beats found");
        }
        const { buildAllGossamerRuns: buildAllGossamerRuns2 } = await Promise.resolve().then(() => (init_gossamer(), gossamer_exports));
        const { setBaseModeAllScenes: setBaseModeAllScenes2, resetRotation: resetRotation2 } = await Promise.resolve().then(() => (init_GossamerCommands(), GossamerCommands_exports));
        const selectedBeatModel = ((_a = plugin.settings.beatSystem) == null ? void 0 : _a.trim()) || void 0;
        const allRuns = buildAllGossamerRuns2(scenes, selectedBeatModel);
        if (allRuns.current.beats.length === 0) {
          const systemMsg = selectedBeatModel ? ` with Beat Model: ${selectedBeatModel}` : "";
          new import_obsidian8.Notice(`Cannot enter Gossamer mode: No story beat notes found${systemMsg}. Create notes with Class: Beat (or Class: Plot for backward compatibility).`);
          throw new Error(`Cannot enter Gossamer mode: No beats found for system: ${selectedBeatModel}`);
        }
        if (!allRuns.hasAnyScores) {
          new import_obsidian8.Notice('No Gossamer scores found. Showing ideal ranges and spokes. Add scores using "Gossamer enter momentum scores" command.');
        }
        plugin._gossamerLastRun = allRuns.current;
        plugin._gossamerHistoricalRuns = allRuns.historical;
        plugin._gossamerMinMax = allRuns.minMax;
        setBaseModeAllScenes2(plugin);
        resetRotation2(plugin);
        plugin.clearSearch();
        view.interactionMode = "gossamer";
      },
      onExit: async (view) => {
      }
    };
  }
});

// src/utils/planetaryTime.ts
function getActivePlanetaryProfile(settings) {
  var _a;
  if (!settings.enablePlanetaryTime) return null;
  const profiles = settings.planetaryProfiles || [];
  if (!profiles.length) return null;
  const activeId = settings.activePlanetaryProfileId || ((_a = profiles[0]) == null ? void 0 : _a.id);
  const profile = profiles.find((p) => p.id === activeId) || profiles[0];
  return profile || null;
}
function validatePlanetaryProfile(profile) {
  const errors = [];
  if (!profile.label || profile.label.trim().length === 0) errors.push("label");
  if (!Number.isFinite(profile.hoursPerDay) || profile.hoursPerDay <= 0) errors.push("hoursPerDay");
  if (!Number.isFinite(profile.daysPerWeek) || profile.daysPerWeek < 1) errors.push("daysPerWeek");
  if (!Number.isFinite(profile.daysPerYear) || profile.daysPerYear < 1) errors.push("daysPerYear");
  if (profile.epochOffsetDays !== void 0 && !Number.isFinite(profile.epochOffsetDays)) errors.push("epochOffsetDays");
  return { ok: errors.length === 0, errors };
}
function convertFromEarth(date, profile) {
  var _a;
  if (!(date instanceof Date) || Number.isNaN(date.getTime())) return null;
  const { hoursPerDay, daysPerYear, daysPerWeek } = profile;
  if (hoursPerDay <= 0 || daysPerYear <= 0) return null;
  const localDayMs = hoursPerDay * 60 * 60 * 1e3;
  const epochShiftMs = ((_a = profile.epochOffsetDays) != null ? _a : 0) * EARTH_DAY_MS;
  const shifted = date.getTime() + epochShiftMs;
  const totalLocalDays = shifted / localDayMs;
  const fullLocalDays = Math.floor(totalLocalDays);
  const dayFraction = totalLocalDays - fullLocalDays;
  const localYear = Math.floor(fullLocalDays / daysPerYear) + 1;
  const localDayOfYear = mod(fullLocalDays, daysPerYear);
  const monthNames = profile.monthNames || [];
  const monthCount = Math.max(1, monthNames.length || 12);
  const daysPerMonth = Math.max(1, Math.floor(daysPerYear / monthCount));
  const localMonthIndex = Math.min(monthCount - 1, Math.floor(localDayOfYear / daysPerMonth));
  const localDayOfMonth = mod(localDayOfYear, daysPerMonth) + 1;
  const localWeekdayIndex = daysPerWeek > 0 ? mod(fullLocalDays, daysPerWeek) : 0;
  const localDayMsWithinDay = Math.max(0, Math.round(dayFraction * localDayMs));
  const localHours = Math.floor(localDayMsWithinDay / (60 * 60 * 1e3));
  const localMinutes = Math.floor(localDayMsWithinDay % (60 * 60 * 1e3) / (60 * 1e3));
  const localSeconds = Math.floor(localDayMsWithinDay % (60 * 1e3) / 1e3);
  const formatted = formatPlanetaryDateTime({
    profile,
    localYear,
    localMonthIndex,
    localDayOfMonth,
    localWeekdayIndex,
    localHours,
    localMinutes
  });
  return {
    profile,
    localYear,
    localDayOfYear,
    localMonthIndex,
    localDayOfMonth,
    localWeekdayIndex,
    localHours,
    localMinutes,
    localSeconds,
    formatted
  };
}
function formatPlanetaryDateTime(opts) {
  var _a, _b, _c, _d;
  const { profile, localYear, localMonthIndex, localDayOfMonth, localWeekdayIndex, localHours, localMinutes } = opts;
  const monthLabel = (_b = (_a = profile.monthNames) == null ? void 0 : _a[localMonthIndex]) != null ? _b : `Month ${localMonthIndex + 1}`;
  const weekdayLabel = (_d = (_c = profile.weekdayNames) == null ? void 0 : _c[localWeekdayIndex]) != null ? _d : `Day ${localWeekdayIndex + 1}`;
  const epochLabel = profile.epochLabel ? `${profile.epochLabel.toUpperCase()} ` : "";
  const timeStr = `${pad(localHours)}:${pad(localMinutes)}`;
  const weekdayAbbrev = abbreviate(weekdayLabel);
  const monthAbbrev = abbreviate(monthLabel);
  return `${epochLabel}Year ${localYear} \u2609 ${weekdayAbbrev} ${monthAbbrev} \xB7 ${localDayOfMonth} @ ${timeStr}`;
}
function formatPlanetaryDateAdaptive(conversion, earthLabel) {
  var _a, _b;
  const hasTime = /(\d{1,2}:\d{2}|noon|midnight)/i.test(earthLabel);
  const hasYear = /\b(1\d{3}|2\d{3})\b/.test(earthLabel);
  const isTimeOnly = hasTime && !hasYear && !/[A-Za-z]{3,}/.test(earthLabel.replace(/am|pm|noon|midnight/i, ""));
  const { profile, localYear, localMonthIndex, localDayOfMonth, localHours, localMinutes } = conversion;
  const monthLabel = (_b = (_a = profile.monthNames) == null ? void 0 : _a[localMonthIndex]) != null ? _b : `${localMonthIndex + 1}`;
  const monthAbbrev = abbreviate(monthLabel);
  const timeStr = `${pad(localHours)}:${pad(localMinutes)}`;
  const parts = [];
  if (isTimeOnly) {
    return timeStr;
  }
  if (hasYear) {
    parts.push(`Yr ${localYear}`);
  }
  parts.push(`${monthAbbrev} ${localDayOfMonth}`);
  if (hasTime) {
    parts.push(timeStr);
  }
  return parts.join(" \xB7 ");
}
function parseCommaNames(input) {
  if (!input) return void 0;
  const names = input.split(",").map((n) => n.trim()).filter(Boolean);
  return names.length ? names : void 0;
}
function pad(value) {
  return String(Math.max(0, value)).padStart(2, "0");
}
function mod(value, divisor) {
  const result = value % divisor;
  return result < 0 ? result + divisor : result;
}
function abbreviate(label) {
  const trimmed = label.trim();
  if (!trimmed) return "";
  const token = trimmed.split(/\s+/)[0];
  return token.slice(0, 3).toUpperCase();
}
function formatElapsedTimePlanetary(ms, profile, clickCount = 0) {
  if (!Number.isFinite(ms) || ms === 0) {
    return "0 local minutes";
  }
  const safeMs = Math.max(0, Math.abs(ms));
  const { hoursPerDay, daysPerWeek, daysPerYear } = profile;
  const localMinuteMs = hoursPerDay * 60 * 60 * 1e3 / (hoursPerDay * 60);
  const localHourMs = hoursPerDay * 60 * 60 * 1e3 / hoursPerDay;
  const localDayMs = hoursPerDay * 60 * 60 * 1e3;
  const localWeekMs = localDayMs * daysPerWeek;
  const localMonthMs = localDayMs * (daysPerYear / 12);
  const localYearMs = localDayMs * daysPerYear;
  const unitIndex = (clickCount % 5 + 5) % 5;
  const pickAutoUnit = () => {
    if (safeMs >= localYearMs * 2) {
      const years = safeMs / localYearMs;
      return `${years.toFixed(1)} local years`;
    } else if (safeMs >= localMonthMs * 2) {
      const months = safeMs / localMonthMs;
      return `${months.toFixed(1)} local months`;
    } else if (safeMs >= localWeekMs * 2) {
      const weeks = safeMs / localWeekMs;
      return `${weeks.toFixed(1)} local weeks`;
    } else if (safeMs >= localDayMs * 2) {
      const days = safeMs / localDayMs;
      return `${days.toFixed(1)} local days`;
    } else if (safeMs >= localHourMs * 2) {
      const hours = safeMs / localHourMs;
      return `${hours.toFixed(1)} local hours`;
    } else {
      const minutes = safeMs / localMinuteMs;
      return `${Math.round(minutes)} local minutes`;
    }
  };
  switch (unitIndex) {
    case 0:
      return pickAutoUnit();
    case 1: {
      const hours = safeMs / localHourMs;
      return `${hours.toFixed(1)} local hours`;
    }
    case 2: {
      const days = safeMs / localDayMs;
      return `${days.toFixed(1)} local days`;
    }
    case 3: {
      const weeks = safeMs / localWeekMs;
      return `${weeks.toFixed(1)} local weeks`;
    }
    case 4:
    default: {
      const months = safeMs / localMonthMs;
      return `${months.toFixed(1)} local months`;
    }
  }
}
var EARTH_DAY_MS;
var init_planetaryTime = __esm({
  "src/utils/planetaryTime.ts"() {
    EARTH_DAY_MS = 24 * 60 * 60 * 1e3;
  }
});

// src/renderer/components/ChronologueTimeline.ts
function collectChronologueSceneEntries(scenes) {
  const seenKeys = /* @__PURE__ */ new Set();
  const entries = [];
  scenes.forEach((scene, index) => {
    var _a;
    const whenDate = scene.when instanceof Date ? scene.when : parseWhenField(typeof scene.when === "string" ? scene.when : "");
    if (!whenDate) return;
    const key = scene.path ? `path:${scene.path}` : `title:${(_a = scene.title) != null ? _a : ""}::${whenDate.getTime()}`;
    if (seenKeys.has(key)) return;
    seenKeys.add(key);
    entries.push({ scene, date: whenDate, sourceIndex: index });
  });
  return entries;
}
function renderChronologueTimelineArc(scenes, outerRadius, scenePositions, durationCapMs, arcRadius = 758, precomputedEntries) {
  const sceneEntries = precomputedEntries != null ? precomputedEntries : collectChronologueSceneEntries(scenes);
  const validDates = sceneEntries.map((entry) => entry.date);
  if (validDates.length === 0) {
    return "";
  }
  const timeSpan = calculateTimeSpan(validDates);
  const earliestDate = validDates.reduce(
    (earliest, current) => current.getTime() < earliest.getTime() ? current : earliest
  );
  let svg = "";
  svg += `<g class="rt-chronologue-timeline-arc">`;
  if (scenePositions) {
    const durationSegments = renderDurationTickArcs({
      sceneEntries,
      arcRadius,
      timeSpanTotalMs: timeSpan.totalMs,
      scenePositions,
      durationCapMs
    });
    if (durationSegments) {
      svg += durationSegments;
    }
  }
  svg += `</g>`;
  return svg;
}
function renderDurationTickArcs(params) {
  const { sceneEntries, arcRadius, timeSpanTotalMs, scenePositions, durationCapMs } = params;
  if (sceneEntries.length === 0 || timeSpanTotalMs <= 0) {
    return null;
  }
  const sortedEntries = sceneEntries.slice().sort((a, b) => a.date.getTime() - b.date.getTime());
  const parsedDurations = sortedEntries.map((entry) => {
    const raw = entry.scene.Duration;
    if (!raw) {
      return { durationMs: 0, rawDuration: raw };
    }
    const value = parseDuration(raw);
    if (value === null) {
      return { durationMs: null, rawDuration: raw };
    }
    return { durationMs: value, rawDuration: raw };
  });
  const validDurationValues = [];
  parsedDurations.forEach((info) => {
    if (info.durationMs && info.durationMs > 0) {
      validDurationValues.push(info.durationMs);
    }
  });
  if (validDurationValues.length === 0 && !parsedDurations.some((d) => d.durationMs === null || d.durationMs === 0)) {
    return null;
  }
  const observedMaxDurationMs = validDurationValues.length > 0 ? Math.max(...validDurationValues) : 0;
  const scaleCapMs = typeof durationCapMs === "number" && durationCapMs > 0 ? durationCapMs : observedMaxDurationMs;
  const scaleMs = scaleCapMs > 0 ? scaleCapMs : observedMaxDurationMs > 0 ? observedMaxDurationMs : 1;
  const overlapIndices = detectSceneOverlaps(sortedEntries.map((entry) => ({
    when: entry.date,
    Duration: entry.scene.Duration
  })));
  const durationPaths = [];
  const TWO_PI = Math.PI * 2;
  const EDGE_MARGIN_RAD = Math.PI / 360;
  const STUB_FILL_RATIO = 0.2;
  sortedEntries.forEach((entry, idx) => {
    const durationInfo = parsedDurations[idx];
    const durationMs = durationInfo.durationMs;
    const sceneKey = entry.scene.path || `title:${entry.scene.title || ""}`;
    const manuscriptPosition = scenePositions.get(sceneKey);
    if (!manuscriptPosition) {
      return;
    }
    const marginAngle = 2 / arcRadius;
    const startAngle = manuscriptPosition.startAngle + marginAngle;
    const endAngle = manuscriptPosition.endAngle - marginAngle;
    const availableAngle = endAngle - startAngle;
    if (availableAngle <= 0) return;
    let spanAngle;
    let isUnparseable = false;
    let isOngoing = false;
    let isOverlap = overlapIndices.has(idx);
    if (durationMs === null || durationMs === 0) {
      if (durationInfo.rawDuration && durationInfo.rawDuration.toLowerCase().trim() === "ongoing") {
        spanAngle = availableAngle;
        isOngoing = true;
        isOverlap = true;
      } else {
        spanAngle = availableAngle * STUB_FILL_RATIO;
        isUnparseable = true;
      }
    } else {
      const ratio = scaleMs > 0 ? Math.min(durationMs / scaleMs, 1) : 1;
      spanAngle = availableAngle * ratio;
    }
    if (spanAngle <= 0) return;
    const arcStart = startAngle;
    const arcEnd = arcStart + spanAngle;
    const largeArcFlag = spanAngle > Math.PI ? 1 : 0;
    let arcClass = "rt-duration-arc";
    if (isUnparseable) {
      arcClass += " rt-duration-arc-unparseable";
    }
    if (isOverlap) {
      arcClass += " rt-duration-arc-overlap";
    }
    if (isOngoing) {
      arcClass += " rt-duration-arc-ongoing";
    }
    const x1 = formatNumber(arcRadius * Math.cos(arcStart));
    const y1 = formatNumber(arcRadius * Math.sin(arcStart));
    const x2 = formatNumber(arcRadius * Math.cos(arcEnd));
    const y2 = formatNumber(arcRadius * Math.sin(arcEnd));
    durationPaths.push(
      `<path d="M ${x1} ${y1} A ${formatNumber(arcRadius)} ${formatNumber(arcRadius)} 0 ${largeArcFlag} 1 ${x2} ${y2}" class="${arcClass}" />`
    );
  });
  if (durationPaths.length === 0) {
    return null;
  }
  return `<g class="rt-chronologue-duration-ticks">
        ${durationPaths.join("")}
    </g>`;
}
function mapTimeToAngle(timeMs, startMs, endMs) {
  const progress = (timeMs - startMs) / (endMs - startMs);
  return progress * 2 * Math.PI - Math.PI / 2;
}
function renderElapsedTimeArc(scene1, scene2, outerRadius, arcWidth = 2) {
  const date1 = parseWhenField(typeof scene1.when === "string" ? scene1.when : "");
  const date2 = parseWhenField(typeof scene2.when === "string" ? scene2.when : "");
  if (!date1 || !date2) {
    return "";
  }
  const [earlierScene, laterScene] = date1.getTime() < date2.getTime() ? [scene1, scene2] : [scene2, scene1];
  const [earlierDate, laterDate] = date1.getTime() < date2.getTime() ? [date1, date2] : [date2, date1];
  const arcRadius = outerRadius + 15;
  const startAngle = mapTimeToAngle(earlierDate.getTime(), earlierDate.getTime(), laterDate.getTime());
  const endAngle = mapTimeToAngle(laterDate.getTime(), earlierDate.getTime(), laterDate.getTime());
  const largeArcFlag = endAngle - startAngle > Math.PI ? 1 : 0;
  const x1 = formatNumber(arcRadius * Math.cos(startAngle));
  const y1 = formatNumber(arcRadius * Math.sin(startAngle));
  const x2 = formatNumber(arcRadius * Math.cos(endAngle));
  const y2 = formatNumber(arcRadius * Math.sin(endAngle));
  const arcPath2 = `M ${x1} ${y1} A ${formatNumber(arcRadius)} ${formatNumber(arcRadius)} 0 ${largeArcFlag} 1 ${x2} ${y2}`;
  return `<g class="rt-elapsed-time-arc">
        <path d="${arcPath2}" fill="none" stroke="var(--interactive-accent)" stroke-width="${arcWidth}" opacity="0.8"/>
    </g>`;
}
function renderChronologicalBackboneArc(scenes, outerRingInnerRadius, outerRingOuterRadius, discontinuityThreshold = 3, scenePositions, precomputedEntries, customThresholdMs) {
  const sceneEntries = precomputedEntries != null ? precomputedEntries : collectChronologueSceneEntries(scenes);
  if (sceneEntries.length === 0 || !scenePositions) return "";
  const preparedScenes = prepareScenesForDiscontinuityDetection(scenes);
  if (preparedScenes.length < 3) return "";
  const autoThreshold = calculateAutoDiscontinuityThreshold(scenes);
  const effectiveThreshold = customThresholdMs != null ? customThresholdMs : autoThreshold;
  if (!effectiveThreshold || effectiveThreshold <= 0) {
    return "";
  }
  const discontinuityIndices = detectDiscontinuities(preparedScenes, effectiveThreshold);
  if (discontinuityIndices.length === 0) {
    return "";
  }
  const timestampToEntry = /* @__PURE__ */ new Map();
  sceneEntries.forEach((entry) => {
    if (entry.scene.itemType === "Scene") {
      timestampToEntry.set(entry.date.getTime(), entry);
    }
  });
  const markerRadius = (outerRingInnerRadius + outerRingOuterRadius) / 2;
  let svg = `<g class="rt-chronologue-backbone-discontinuities">`;
  discontinuityIndices.forEach((sceneIndex) => {
    if (sceneIndex >= preparedScenes.length) return;
    const currScene = preparedScenes[sceneIndex];
    const nextScene = sceneIndex < preparedScenes.length - 1 ? preparedScenes[sceneIndex + 1] : null;
    const TIME_TOLERANCE_MS = 6e4;
    const hasAdjacentSameTime = nextScene && Math.abs(currScene.when.getTime() - nextScene.when.getTime()) < TIME_TOLERANCE_MS;
    if (hasAdjacentSameTime) {
      return;
    }
    const sceneEntry = timestampToEntry.get(currScene.when.getTime());
    if (!sceneEntry) return;
    const sceneKey = sceneEntry.scene.path || `title:${sceneEntry.scene.title || ""}`;
    const manuscriptPosition = scenePositions.get(sceneKey);
    if (!manuscriptPosition) return;
    const midAngle = (manuscriptPosition.startAngle + manuscriptPosition.endAngle) / 2;
    const x = formatNumber(markerRadius * Math.cos(midAngle));
    const y = formatNumber(markerRadius * Math.sin(midAngle));
    const angularWidth = manuscriptPosition.endAngle - manuscriptPosition.startAngle;
    const arcLengthAtMarker = markerRadius * angularWidth;
    const dynamicFontSize = Math.max(8, Math.min(20, arcLengthAtMarker * 0.6));
    const dynamicStrokeWidth = Math.max(2, Math.min(6, dynamicFontSize * 0.3));
    svg += `<text x="${x}" y="${y}" class="rt-discontinuity-marker" text-anchor="middle" dominant-baseline="middle" font-size="${formatNumber(dynamicFontSize)}" stroke-width="${formatNumber(dynamicStrokeWidth)}">\u221E</text>`;
  });
  svg += `</g>`;
  return svg;
}
var init_ChronologueTimeline = __esm({
  "src/renderer/components/ChronologueTimeline.ts"() {
    init_svg();
    init_date();
  }
});

// src/view/interactions/ChronologueShiftController.ts
var ChronologueShiftController_exports = {};
__export(ChronologueShiftController_exports, {
  isAlienModeActive: () => isAlienModeActive,
  isShiftModeActive: () => isShiftModeActive,
  resetShiftModeState: () => resetShiftModeState,
  setupChronologueShiftController: () => setupChronologueShiftController
});
function isShiftModeActive() {
  return globalShiftModeActive;
}
function isAlienModeActive() {
  return globalAlienModeActive;
}
function resetShiftModeState() {
  globalShiftModeActive = false;
  globalAlienModeActive = false;
}
function setupChronologueShiftController(view, svg) {
  if (view.currentMode !== "chronologue") {
    return;
  }
  let shiftModeActive = false;
  let alienModeActive = false;
  let selectedScenes = [];
  let hoveredScenePath = null;
  let elapsedTimeClickCount = 0;
  const viewBox = svg.getAttribute("viewBox");
  let outerRadius = 300;
  if (viewBox) {
    const [, , width, height] = viewBox.split(" ").map(parseFloat);
    const size = Math.min(width, height);
    outerRadius = size / 2 - 50;
  }
  const sceneGeometry = /* @__PURE__ */ new Map();
  const sceneGroupBySceneId = /* @__PURE__ */ new Map();
  const sceneSubplotIndexBySceneId = /* @__PURE__ */ new Map();
  const numberSquareBySceneId = /* @__PURE__ */ new Map();
  const numberTextBySceneId = /* @__PURE__ */ new Map();
  const subplotColors = [];
  for (let i = 0; i < 16; i++) {
    const varName = `--rt-subplot-colors-${i}`;
    const computed = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    subplotColors[i] = computed || "#EFBDEB";
  }
  const allSynopsisElements = Array.from(svg.querySelectorAll(".rt-scene-info"));
  const synopsisBySceneId = /* @__PURE__ */ new Map();
  allSynopsisElements.forEach((synopsis) => {
    const sceneId = synopsis.getAttribute("data-for-scene");
    if (sceneId) {
      synopsisBySceneId.set(sceneId, synopsis);
    }
  });
  const sceneIdCache = /* @__PURE__ */ new WeakMap();
  const getSceneIdFromGroup = (group) => {
    var _a;
    const cached = sceneIdCache.get(group);
    if (cached) return cached;
    const pathEl = group.querySelector(".rt-scene-path");
    const sceneId = (_a = pathEl == null ? void 0 : pathEl.id) != null ? _a : null;
    if (sceneId) {
      sceneIdCache.set(group, sceneId);
    }
    return sceneId;
  };
  const sceneGroups = Array.from(svg.querySelectorAll('.rt-scene-group[data-item-type="Scene"]'));
  sceneGroups.forEach((group) => {
    var _a;
    const sceneId = getSceneIdFromGroup(group);
    if (sceneId) {
      sceneGroupBySceneId.set(sceneId, group);
      const subplotIndexAttr = group.getAttribute("data-subplot-color-index") || group.getAttribute("data-subplot-index");
      if (subplotIndexAttr) {
        const subplotIndex = parseInt(subplotIndexAttr, 10);
        if (!isNaN(subplotIndex)) {
          sceneSubplotIndexBySceneId.set(sceneId, subplotIndex);
        }
      }
      const square = svg.querySelector(`.rt-number-square[data-scene-id="${sceneId}"]`);
      const text = svg.querySelector(`.rt-number-text[data-scene-id="${sceneId}"]`);
      if (square) numberSquareBySceneId.set(sceneId, square);
      if (text) numberTextBySceneId.set(sceneId, text);
    }
    const scenePath = group.getAttribute("data-path");
    if (!scenePath) return;
    const ringAttr = group.getAttribute("data-ring");
    const ringIndex = ringAttr ? parseInt(ringAttr, 10) : 0;
    const startAngleAttr = group.getAttribute("data-start-angle");
    const outerRadiusAttr = group.getAttribute("data-outer-r");
    const angle = startAngleAttr ? parseFloat(startAngleAttr) : NaN;
    const outerRadiusValue = outerRadiusAttr ? parseFloat(outerRadiusAttr) : NaN;
    if (isNaN(angle)) return;
    const existing = sceneGeometry.get(scenePath);
    if (!existing || ringIndex > existing.ring) {
      sceneGeometry.set(scenePath, {
        startAngle: angle,
        outerRadius: !isNaN(outerRadiusValue) ? outerRadiusValue : (_a = existing == null ? void 0 : existing.outerRadius) != null ? _a : null,
        ring: ringIndex
      });
    }
  });
  const shiftButton = createShiftButton();
  svg.appendChild(shiftButton);
  let altButton = null;
  const activeProfile = getActivePlanetaryProfile(view.plugin.settings);
  const isProfileValid = activeProfile ? validatePlanetaryProfile(activeProfile).ok : false;
  const shouldShowAlt = view.plugin.settings.enablePlanetaryTime && isProfileValid;
  if (shouldShowAlt) {
    altButton = createAltButton();
    svg.appendChild(altButton);
  }
  const activateShiftMode = (enableAlien = false) => {
    if (!shiftModeActive) {
      shiftModeActive = true;
      globalShiftModeActive = true;
      updateShiftButtonState(shiftButton, true);
    }
    if (enableAlien && altButton) {
      if (!alienModeActive) {
        alienModeActive = true;
        globalAlienModeActive = true;
        updateAltButtonState(altButton, true);
      }
    } else {
    }
    const modeAttr = alienModeActive ? "alien" : "active";
    svg.setAttribute("data-shift-mode", modeAttr);
    if (alienModeActive) {
      updateDateLabelsForAlienMode(true);
    }
    applyShiftModeToAllScenes(svg);
    allSynopsisElements.forEach((syn) => {
      if (syn.classList.contains("rt-visible")) {
        syn.classList.remove("rt-visible");
      }
    });
    const hoveredGroups = svg.querySelectorAll('.rt-scene-group[data-item-type="Scene"]:hover');
    if (hoveredGroups.length > 0) {
      const hoveredGroup = hoveredGroups[0];
      const scenePathEncoded = hoveredGroup.getAttribute("data-path");
      if (scenePathEncoded) {
        hoveredScenePath = scenePathEncoded;
        hoveredGroup.classList.add("rt-shift-hover");
        const sid = getSceneIdFromGroup(hoveredGroup);
        setNumberSquareActiveBySceneId(sid, true, numberSquareBySceneId, numberTextBySceneId, sceneSubplotIndexBySceneId, subplotColors);
      }
    }
  };
  const deactivateShiftMode = () => {
    if (shiftModeActive) {
      shiftModeActive = false;
      globalShiftModeActive = false;
      updateShiftButtonState(shiftButton, false);
      alienModeActive = false;
      globalAlienModeActive = false;
      if (altButton) updateAltButtonState(altButton, false);
      updateDateLabelsForAlienMode(false);
      selectedScenes = [];
      rebuildSelectedPathsSet();
      hoveredScenePath = null;
      elapsedTimeClickCount = 0;
      removeElapsedTimeArc(svg);
      removeSceneHighlights(svg);
      removeShiftModeFromAllScenes(svg);
      svg.removeAttribute("data-shift-mode");
      svg.classList.remove("rt-global-fade");
      svg.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title, .rt-discontinuity-marker").forEach((el) => {
        el.classList.remove("rt-selected", "rt-non-selected");
      });
      svg.querySelectorAll(".rt-scene-info.rt-visible").forEach((syn) => {
        syn.classList.remove("rt-visible");
      });
      svg.classList.remove("scene-hover");
      const hoveredSceneGroup = svg.querySelector('.rt-scene-group[data-item-type="Scene"]:hover');
    }
  };
  const updateDateLabelsForAlienMode = (enableAlien) => {
    const dateLabels = svg.querySelectorAll(".rt-month-label-outer[data-earth-date]");
    const profile = getActivePlanetaryProfile(view.plugin.settings);
    const includeTimeInLabel = (earthLabel) => /(\d{1,2}:\d{2}\s*(am|pm)?|noon|midnight)/i.test(earthLabel);
    const padTime = (value) => String(Math.max(0, value)).padStart(2, "0");
    dateLabels.forEach((label) => {
      var _a;
      const textPath = label.querySelector("textPath");
      if (!textPath) return;
      if (enableAlien && profile) {
        const earthDateStr = label.getAttribute("data-earth-date");
        if (!earthDateStr) return;
        if (!label.getAttribute("data-earth-label")) {
          const tspans = textPath.querySelectorAll("tspan");
          if (tspans.length > 0) {
            const lines = Array.from(tspans).map((t2) => t2.textContent || "");
            label.setAttribute("data-earth-label", lines.join("\n"));
          } else {
            label.setAttribute("data-earth-label", textPath.textContent || "");
          }
        }
        if (!label.getAttribute("data-earth-label-html")) {
          label.setAttribute("data-earth-label-html", textPath.innerHTML);
        }
        const earthLabel = label.getAttribute("data-earth-label") || "";
        const earthDate = new Date(earthDateStr);
        const conversion = convertFromEarth(earthDate, profile);
        if (conversion) {
          const monthName = ((_a = profile.monthNames) == null ? void 0 : _a[conversion.localMonthIndex]) || String(conversion.localMonthIndex + 1);
          const isBoundary = label.classList.contains("rt-date-boundary");
          if (isBoundary) {
            const alienLines = [];
            if (profile.epochLabel) alienLines.push(profile.epochLabel);
            alienLines.push(`YEAR ${conversion.localYear}`);
            alienLines.push(`${monthName} ${conversion.localDayOfMonth}`);
            if (includeTimeInLabel(earthLabel)) {
              alienLines.push(`${padTime(conversion.localHours)}:${padTime(conversion.localMinutes)}`);
            }
            while (textPath.firstChild) textPath.removeChild(textPath.firstChild);
            alienLines.forEach((line, i) => {
              const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
              tspan.setAttribute("x", "0");
              tspan.setAttribute("dy", i === 0 ? "0" : "0.9em");
              tspan.textContent = line;
              textPath.appendChild(tspan);
            });
          } else {
            const alienText = formatPlanetaryDateAdaptive(conversion, earthLabel);
            while (textPath.firstChild) textPath.removeChild(textPath.firstChild);
            textPath.textContent = alienText;
          }
        }
      } else {
        const earthLabelHtml = label.getAttribute("data-earth-label-html");
        const earthLabel = label.getAttribute("data-earth-label");
        if (earthLabelHtml) {
          textPath.innerHTML = earthLabelHtml;
        } else if (earthLabel) {
          while (textPath.firstChild) textPath.removeChild(textPath.firstChild);
          if (earthLabel.includes("\n")) {
            earthLabel.split("\n").forEach((line, i) => {
              const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
              tspan.setAttribute("x", "0");
              tspan.setAttribute("dy", i === 0 ? "0" : "0.9em");
              tspan.textContent = line;
              textPath.appendChild(tspan);
            });
          } else {
            textPath.textContent = earthLabel;
          }
        }
      }
    });
  };
  const toggleAlienMode = () => {
    if (!altButton) return;
    if (alienModeActive) {
      deactivateShiftMode();
    } else {
      if (!shiftModeActive) {
        activateShiftMode(true);
      } else {
        alienModeActive = true;
        globalAlienModeActive = true;
        updateAltButtonState(altButton, true);
        svg.setAttribute("data-shift-mode", "alien");
        updateDateLabelsForAlienMode(true);
      }
    }
  };
  view.registerDomEvent(shiftButton, "click", (e) => {
    e.stopPropagation();
    if (shiftModeActive) {
      deactivateShiftMode();
    } else {
      activateShiftMode(false);
    }
  });
  if (altButton) {
    view.registerDomEvent(altButton, "click", (e) => {
      e.stopPropagation();
      toggleAlienMode();
    });
  }
  let capsLockState = false;
  let pendingCapsLockSync = false;
  const syncShiftModeToCapsLock = (isActive) => {
    if (capsLockState === isActive) {
      return;
    }
    capsLockState = isActive;
    if (isActive) {
      if (!shiftModeActive) activateShiftMode(false);
    } else {
      if (shiftModeActive) deactivateShiftMode();
    }
  };
  const handleKeyDown = (e) => {
    var _a, _b, _c;
    const activeView = (_c = (_b = (_a = view.app) == null ? void 0 : _a.workspace) == null ? void 0 : _b.activeLeaf) == null ? void 0 : _c.view;
    if (activeView !== view || view.currentMode !== "chronologue") {
      return;
    }
    const activeEl = document.activeElement;
    if (activeEl) {
      const tag = activeEl.tagName.toUpperCase();
      if (tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT" || activeEl.isContentEditable) {
        return;
      }
    }
    if (e.key === "Shift") {
      activateShiftMode(e.altKey);
    } else if (e.key === "Alt") {
      if (altButton) {
        e.preventDefault();
        toggleAlienMode();
      }
    } else if (e.key === "CapsLock") {
      if (e.repeat) {
        return;
      }
      const reportedState = e.getModifierState("CapsLock");
      if (reportedState !== capsLockState) {
        syncShiftModeToCapsLock(reportedState);
        pendingCapsLockSync = false;
      } else {
        pendingCapsLockSync = true;
      }
    }
  };
  const handleKeyUp = (e) => {
    var _a, _b, _c;
    const activeView = (_c = (_b = (_a = view.app) == null ? void 0 : _a.workspace) == null ? void 0 : _b.activeLeaf) == null ? void 0 : _c.view;
    if (activeView !== view || view.currentMode !== "chronologue") {
      return;
    }
    const activeElUp = document.activeElement;
    if (activeElUp) {
      const tagUp = activeElUp.tagName.toUpperCase();
      if (tagUp === "INPUT" || tagUp === "TEXTAREA" || tagUp === "SELECT" || activeElUp.isContentEditable) {
        return;
      }
    }
    if (e.key === "Shift") {
      deactivateShiftMode();
    } else if (e.key === "Alt") {
      e.preventDefault();
    } else if (e.key === "CapsLock") {
      const reportedState = e.getModifierState("CapsLock");
      if (pendingCapsLockSync || reportedState !== capsLockState) {
        pendingCapsLockSync = false;
        syncShiftModeToCapsLock(reportedState);
      }
    }
  };
  document.addEventListener("keydown", handleKeyDown);
  document.addEventListener("keyup", handleKeyUp);
  view.register(() => {
    document.removeEventListener("keydown", handleKeyDown);
    document.removeEventListener("keyup", handleKeyUp);
  });
  view._chronologueShiftCleanup = () => {
    document.removeEventListener("keydown", handleKeyDown);
    document.removeEventListener("keyup", handleKeyUp);
    if (shiftButton && shiftButton.parentNode) {
      shiftButton.parentNode.removeChild(shiftButton);
    }
    if (altButton && altButton.parentNode) {
      altButton.parentNode.removeChild(altButton);
    }
  };
  const findSceneByPath = (path) => {
    const decodedPath = decodeURIComponent(path);
    const allScenes = view.sceneData || view.scenes;
    if (allScenes && Array.isArray(allScenes)) {
      const scene = allScenes.find((s) => s.path === decodedPath);
      if (scene) {
        return scene;
      }
    }
    const sceneGroup = svg.querySelector(`.rt-scene-group[data-path="${path}"]`);
    if (!sceneGroup) return null;
    return {
      path: decodedPath,
      when: void 0,
      title: "",
      subplot: "",
      itemType: "Scene"
    };
  };
  const setupShiftModeHover = () => {
    let selectedPathsSet = /* @__PURE__ */ new Set();
    const rebuildSelectedPathsSet2 = () => {
      selectedPathsSet = new Set(selectedScenes.map((s) => s.path ? encodeURIComponent(s.path) : "").filter((p) => p));
    };
    view.registerDomEvent(svg, "pointerover", (e) => {
      if (!shiftModeActive) return;
      const g = e.target.closest('.rt-scene-group[data-item-type="Scene"]');
      if (!g) return;
      e.stopImmediatePropagation();
      e.preventDefault();
      const scenePathEncoded = g.getAttribute("data-path");
      if (!scenePathEncoded) return;
      const isLocked = selectedPathsSet.has(scenePathEncoded);
      if (!isLocked) {
        hoveredScenePath = scenePathEncoded;
        g.classList.add("rt-shift-hover");
        const sid = getSceneIdFromGroup(g);
        setNumberSquareActiveBySceneId(sid, true, numberSquareBySceneId, numberTextBySceneId, sceneSubplotIndexBySceneId, subplotColors);
      }
    }, { capture: true });
    view.registerDomEvent(svg, "pointerout", (e) => {
      if (!shiftModeActive) return;
      const g = e.target.closest('.rt-scene-group[data-item-type="Scene"]');
      if (!g) return;
      e.stopImmediatePropagation();
      e.preventDefault();
      const scenePathEncoded = g.getAttribute("data-path");
      if (!scenePathEncoded) return;
      const isLocked = selectedPathsSet.has(scenePathEncoded);
      if (!isLocked) {
        hoveredScenePath = null;
        g.classList.remove("rt-shift-hover");
        const sid = getSceneIdFromGroup(g);
        setNumberSquareActiveBySceneId(sid, false, numberSquareBySceneId, numberTextBySceneId, sceneSubplotIndexBySceneId, subplotColors);
      }
    }, { capture: true });
    return rebuildSelectedPathsSet2;
  };
  const rebuildSelectedPathsSet = setupShiftModeHover();
  view.handleShiftModeClick = (e, sceneGroup) => {
    if (!shiftModeActive) return false;
    e.preventDefault();
    e.stopPropagation();
    const scenePathEncoded = sceneGroup.getAttribute("data-path");
    if (!scenePathEncoded) return true;
    const scene = findSceneByPath(scenePathEncoded);
    if (!scene) return true;
    const isAlreadyLocked = selectedScenes.some((s) => {
      const encoded = s.path ? encodeURIComponent(s.path) : "";
      return encoded === scenePathEncoded;
    });
    if (isAlreadyLocked) {
      selectedScenes = selectedScenes.filter((s) => {
        const encoded = s.path ? encodeURIComponent(s.path) : "";
        return encoded !== scenePathEncoded;
      });
      rebuildSelectedPathsSet();
      updateSceneSelection(svg, selectedScenes, numberSquareBySceneId, numberTextBySceneId, sceneSubplotIndexBySceneId, subplotColors);
      if (selectedScenes.length < 2) {
        removeElapsedTimeArc(svg);
      } else {
        showElapsedTime(svg, selectedScenes, elapsedTimeClickCount, sceneGeometry, outerRadius, view.plugin.settings);
      }
      return true;
    }
    selectedScenes.push(scene);
    if (selectedScenes.length > 2) {
      selectedScenes = selectedScenes.slice(-2);
    }
    rebuildSelectedPathsSet();
    updateSceneSelection(svg, selectedScenes, numberSquareBySceneId, numberTextBySceneId, sceneSubplotIndexBySceneId, subplotColors);
    if (selectedScenes.length === 2) {
      showElapsedTime(svg, selectedScenes, elapsedTimeClickCount, sceneGeometry, outerRadius, view.plugin.settings);
    }
    return true;
  };
  view.registerDomEvent(svg, "click", (e) => {
    if (!shiftModeActive || selectedScenes.length !== 2) return;
    const elapsedTimeLabel = e.target.closest(".rt-elapsed-time-label");
    if (!elapsedTimeLabel) return;
    e.preventDefault();
    e.stopPropagation();
    elapsedTimeClickCount++;
    showElapsedTime(svg, selectedScenes, elapsedTimeClickCount, sceneGeometry, outerRadius, view.plugin.settings);
  });
}
function createShiftButtonShape() {
  return "M0 11C0 4.92487 4.92487 0 11 0H67C83.5685 0 97 13.4315 97 30V44C97 50.0751 92.0751 55 86 55H11C4.92487 55 0 50.0751 0 44V11Z";
}
function createShiftButton() {
  const button = document.createElementNS("http://www.w3.org/2000/svg", "g");
  button.setAttribute("class", "rt-shift-mode-button");
  button.setAttribute("id", "shift-mode-toggle");
  button.setAttribute("transform", `translate(${SHIFT_BUTTON_POS_X}, ${SHIFT_BUTTON_POS_Y})`);
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path.setAttribute("d", createShiftButtonShape());
  path.setAttribute("class", "rt-shift-button-bg");
  path.setAttribute("fill", "var(--interactive-normal)");
  path.setAttribute("stroke", "var(--text-normal)");
  path.setAttribute("stroke-width", "2");
  const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
  text.setAttribute("x", "48.5");
  text.setAttribute("y", "45");
  text.setAttribute("text-anchor", "middle");
  text.setAttribute("dominant-baseline", "middle");
  text.setAttribute("class", "rt-shift-button-text");
  text.textContent = "\u2191 SHIFT";
  button.classList.add("rt-tooltip-target");
  button.setAttribute("data-tooltip", "Elapsed scene time comparison & gap visualization");
  button.setAttribute("data-tooltip-placement", "bottom");
  button.appendChild(path);
  button.appendChild(text);
  return button;
}
function updateShiftButtonState(button, active) {
  const bg = button.querySelector(".rt-shift-button-bg");
  const text = button.querySelector(".rt-shift-button-text");
  const currentTransform = button.getAttribute("transform") || "";
  const baseTransform = currentTransform.replace(/scale\([^)]+\)/, "").trim();
  if (active) {
    button.setAttribute("transform", `${baseTransform} scale(${BUTTON_ACTIVE_SCALE})`);
    button.classList.add("rt-shift-mode-active");
  } else {
    button.setAttribute("transform", `${baseTransform}`);
    button.classList.remove("rt-shift-mode-active");
  }
}
function createAltButton() {
  const button = document.createElementNS("http://www.w3.org/2000/svg", "g");
  button.setAttribute("class", "rt-shift-mode-button rt-alt-button");
  button.setAttribute("id", "alt-mode-toggle");
  const posX = SHIFT_BUTTON_POS_X - 10 - 43;
  const posY = SHIFT_BUTTON_POS_Y + 9;
  button.setAttribute("transform", `translate(${posX}, ${posY})`);
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path.setAttribute("d", createAltButtonShape());
  path.setAttribute("class", "rt-shift-button-bg");
  path.setAttribute("fill", "var(--interactive-normal)");
  path.setAttribute("stroke", "var(--text-normal)");
  path.setAttribute("stroke-width", "2");
  const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
  text.setAttribute("x", "21.5");
  text.setAttribute("y", "36");
  text.setAttribute("text-anchor", "middle");
  text.setAttribute("dominant-baseline", "middle");
  text.setAttribute("class", "rt-shift-button-text");
  text.textContent = "ALT";
  button.classList.add("rt-tooltip-target");
  button.setAttribute("data-tooltip", "Toggle Planetary Calendar");
  button.setAttribute("data-tooltip-placement", "bottom");
  button.appendChild(path);
  button.appendChild(text);
  return button;
}
function createAltButtonShape() {
  return "M42.6961 35.5616C42.6818 41.0016 38.5008 46 31.7718 46L9.73753 46C2.98561 46 0.0473404 38.6061 0.00495911 34.3114C-0.0062027 33.1802 0.00495911 29.0328 0.00495911 27.6455C0.00495911 25.6393 0.412907 19.3215 8.25278 10.1803C16.1106 1.01827 24.0073 0 26.207 2.71215e-06L32.8167 0C39.9299 0 42.6743 5.31298 42.7024 10.1803C42.7133 12.0656 42.7024 33.1802 42.6961 35.5616Z";
}
function updateAltButtonState(button, active) {
  const ALT_WIDTH = 43;
  const ALT_HEIGHT = 46;
  const SHIFT_HEIGHT = 55;
  const basePosX = SHIFT_BUTTON_POS_X - 10 - ALT_WIDTH;
  const basePosY = SHIFT_BUTTON_POS_Y + (SHIFT_HEIGHT - ALT_HEIGHT);
  if (active) {
    const expansionX = ALT_WIDTH * (BUTTON_ACTIVE_SCALE - 1);
    const scaledPosX = basePosX - expansionX;
    const scaledPosY = SHIFT_BUTTON_POS_Y + (SHIFT_HEIGHT - ALT_HEIGHT) * BUTTON_ACTIVE_SCALE;
    button.setAttribute("transform", `translate(${scaledPosX}, ${scaledPosY}) scale(${BUTTON_ACTIVE_SCALE})`);
    button.classList.add("rt-shift-mode-active");
  } else {
    button.setAttribute("transform", `translate(${basePosX}, ${basePosY})`);
    button.classList.remove("rt-shift-mode-active");
  }
}
function setNumberSquareActiveBySceneId(sceneId, active, numberSquareBySceneId, numberTextBySceneId, sceneSubplotIndexBySceneId, subplotColors) {
  if (!sceneId) return;
  const square = numberSquareBySceneId.get(sceneId);
  const text = numberTextBySceneId.get(sceneId);
  if (square) {
    square.classList.toggle("rt-shift-active", active);
    if (active) {
      const subplotIndex = sceneSubplotIndexBySceneId.get(sceneId);
      if (subplotIndex !== void 0) {
        const colorIdx = subplotIndex % 16;
        square.setAttribute("data-subplot-idx", colorIdx.toString());
      }
    } else {
      square.removeAttribute("data-subplot-idx");
    }
  }
  if (text) text.classList.toggle("rt-shift-active", active);
}
function applyShiftModeToAllScenes(svg) {
  const allSceneGroups = svg.querySelectorAll('.rt-scene-group[data-item-type="Scene"]');
  allSceneGroups.forEach((group) => {
    group.classList.remove("rt-shift-hover");
    const path = group.querySelector(".rt-scene-path");
    if (path) {
      path.classList.remove("rt-shift-locked", "rt-shift-selected");
    }
  });
}
function removeShiftModeFromAllScenes(svg) {
  const allSceneGroups = svg.querySelectorAll('.rt-scene-group[data-item-type="Scene"]');
  allSceneGroups.forEach((group) => {
    group.classList.remove("rt-shift-hover");
    const path = group.querySelector(".rt-scene-path");
    if (path) {
      path.classList.remove("rt-shift-locked", "rt-shift-selected", "rt-shift-non-select");
    }
  });
  svg.querySelectorAll(".rt-number-square.rt-shift-active").forEach((el) => el.classList.remove("rt-shift-active"));
  svg.querySelectorAll(".rt-number-text.rt-shift-active").forEach((el) => el.classList.remove("rt-shift-active"));
}
function updateSceneSelection(svg, selectedScenes, numberSquareBySceneId, numberTextBySceneId, sceneSubplotIndexBySceneId, subplotColors) {
  const selectedPaths = new Set(selectedScenes.map((s) => s.path ? encodeURIComponent(s.path) : "").filter((p) => p));
  const allSceneGroups = svg.querySelectorAll('.rt-scene-group[data-item-type="Scene"]');
  allSceneGroups.forEach((group) => {
    var _a;
    const path = group.querySelector(".rt-scene-path");
    if (path) {
      path.classList.remove("rt-shift-locked", "rt-shift-selected");
    }
    const scenePathEncoded = group.getAttribute("data-path");
    if (scenePathEncoded && selectedPaths.has(scenePathEncoded)) {
      group.classList.remove("rt-shift-hover");
    }
    const sid = ((_a = group.querySelector(".rt-scene-path")) == null ? void 0 : _a.id) || null;
    setNumberSquareActiveBySceneId(sid, false, numberSquareBySceneId, numberTextBySceneId, sceneSubplotIndexBySceneId, subplotColors);
  });
  selectedScenes.forEach((scene) => {
    const encodedPath = scene.path ? encodeURIComponent(scene.path) : "";
    if (!encodedPath) return;
    const sceneGroup = svg.querySelector(`.rt-scene-group[data-path="${encodedPath}"]`);
    if (sceneGroup) {
      const path = sceneGroup.querySelector(".rt-scene-path");
      if (path) {
        path.classList.add("rt-shift-locked");
        path.classList.add("rt-shift-selected");
        setNumberSquareActiveBySceneId(path.id, true, numberSquareBySceneId, numberTextBySceneId, sceneSubplotIndexBySceneId, subplotColors);
      }
      sceneGroup.classList.remove("rt-shift-hover");
    }
  });
}
function removeSceneHighlights(svg) {
  const allSceneGroups = svg.querySelectorAll('.rt-scene-group[data-item-type="Scene"]');
  allSceneGroups.forEach((group) => {
    const path = group.querySelector(".rt-scene-path");
    if (path) {
      path.classList.remove("rt-shift-selected", "rt-shift-locked");
    }
    group.classList.remove("rt-shift-hover");
  });
  svg.querySelectorAll(".rt-number-square.rt-shift-active").forEach((el) => el.classList.remove("rt-shift-active"));
  svg.querySelectorAll(".rt-number-text.rt-shift-active").forEach((el) => el.classList.remove("rt-shift-active"));
}
function showElapsedTime(svg, scenes, clickCount, sceneGeometry, defaultOuterRadius, settings) {
  var _a, _b;
  removeElapsedTimeArc(svg);
  if (scenes.length !== 2) {
    return;
  }
  const [scene1, scene2] = scenes;
  const encodedPath1 = encodeURIComponent(scene1.path || "");
  const encodedPath2 = encodeURIComponent(scene2.path || "");
  const geometry1 = sceneGeometry.get(encodedPath1);
  const geometry2 = sceneGeometry.get(encodedPath2);
  const parseSceneDate = (scene) => {
    if (scene.when instanceof Date) return scene.when;
    if (typeof scene.when === "string") return parseWhenField(scene.when);
    return null;
  };
  const date1 = parseSceneDate(scene1);
  const date2 = parseSceneDate(scene2);
  if (!date1 || !date2) {
    return;
  }
  const elapsedMs = Math.abs(date2.getTime() - date1.getTime());
  const isAlienMode = svg.getAttribute("data-shift-mode") === "alien";
  const profile = settings ? getActivePlanetaryProfile(settings) : null;
  const elapsedTimeText = isAlienMode && profile ? formatElapsedTimePlanetary(elapsedMs, profile, clickCount) : formatElapsedTime(elapsedMs, clickCount);
  if (geometry1 && geometry2) {
    const startAngleScene1 = geometry1.startAngle;
    const startAngleScene2 = geometry2.startAngle;
    const firstSceneIsEarlier = date1.getTime() <= date2.getTime();
    const startAngle = firstSceneIsEarlier ? startAngleScene1 : startAngleScene2;
    const endAngle = firstSceneIsEarlier ? startAngleScene2 : startAngleScene1;
    let normalizedStart = startAngle;
    let normalizedEnd = endAngle;
    if (normalizedEnd < normalizedStart) {
      normalizedEnd += 2 * Math.PI;
    }
    const sweep = normalizedEnd - normalizedStart;
    const largeArcFlag = sweep > Math.PI ? 1 : 0;
    const baseOuterRadius = Math.max(
      (_a = geometry1.outerRadius) != null ? _a : defaultOuterRadius,
      (_b = geometry2.outerRadius) != null ? _b : defaultOuterRadius,
      defaultOuterRadius
    );
    const arcRadius = ELAPSED_ARC_RADIUS;
    const x1 = arcRadius * Math.cos(startAngle);
    const y1 = arcRadius * Math.sin(startAngle);
    const x2 = arcRadius * Math.cos(endAngle);
    const y2 = arcRadius * Math.sin(endAngle);
    const arcPath2 = `M ${x1} ${y1} A ${arcRadius} ${arcRadius} 0 ${largeArcFlag} 1 ${x2} ${y2}`;
    const arcGroup2 = document.createElementNS("http://www.w3.org/2000/svg", "g");
    arcGroup2.setAttribute("class", "rt-elapsed-time-arc");
    const arcPathElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
    arcPathElement.setAttribute("d", arcPath2);
    arcPathElement.setAttribute("class", "rt-elapsed-arc-path");
    arcGroup2.appendChild(arcPathElement);
    const addEndpointMarker = (angle) => {
      const innerRadius = arcRadius;
      const outerRadius = arcRadius + ELAPSED_TICK_LENGTH;
      const innerX = innerRadius * Math.cos(angle);
      const innerY = innerRadius * Math.sin(angle);
      const outerX = outerRadius * Math.cos(angle);
      const outerY = outerRadius * Math.sin(angle);
      const marker = document.createElementNS("http://www.w3.org/2000/svg", "line");
      marker.setAttribute("x1", `${innerX}`);
      marker.setAttribute("y1", `${innerY}`);
      marker.setAttribute("x2", `${outerX}`);
      marker.setAttribute("y2", `${outerY}`);
      marker.setAttribute("class", "rt-elapsed-endpoint-marker");
      arcGroup2.appendChild(marker);
    };
    addEndpointMarker(startAngle);
    addEndpointMarker(endAngle);
    hideOverlappingTicks(svg, startAngle, endAngle);
    const midpointNormalized = normalizedStart + sweep / 2;
    const midpointAngle2 = normalizeAngle(midpointNormalized);
    const labelRadius2 = arcRadius + 24;
    const labelX2 = labelRadius2 * Math.cos(midpointAngle2);
    const labelY2 = labelRadius2 * Math.sin(midpointAngle2);
    const labelGroup2 = createElapsedTimeLabel(labelX2, labelY2, elapsedTimeText, midpointAngle2);
    const chronologueArcLayer2 = svg.querySelector(".rt-chronologue-timeline-arc");
    if (chronologueArcLayer2) {
      chronologueArcLayer2.appendChild(arcGroup2);
      chronologueArcLayer2.appendChild(labelGroup2);
      const parent = chronologueArcLayer2.parentElement;
      if (parent) {
        parent.appendChild(chronologueArcLayer2);
      }
    } else {
      svg.appendChild(arcGroup2);
      svg.appendChild(labelGroup2);
    }
    return;
  }
  const fallbackArc = renderElapsedTimeArc(scene1, scene2, defaultOuterRadius);
  const arcGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
  arcGroup.setAttribute("class", "rt-elapsed-time-arc");
  arcGroup.innerHTML = fallbackArc;
  const midpointTime = (date1.getTime() + date2.getTime()) / 2;
  const earliestTime = Math.min(date1.getTime(), date2.getTime());
  const latestTime = Math.max(date1.getTime(), date2.getTime());
  const timeRange = latestTime - earliestTime;
  const progress = timeRange > 0 ? (midpointTime - earliestTime) / timeRange : 0.5;
  const midpointAngle = -Math.PI / 2 + progress * 2 * Math.PI;
  const labelRadius = defaultOuterRadius + 30;
  const labelX = labelRadius * Math.cos(midpointAngle);
  const labelY = labelRadius * Math.sin(midpointAngle);
  const labelGroup = createElapsedTimeLabel(labelX, labelY, elapsedTimeText, midpointAngle);
  const chronologueArcLayer = svg.querySelector(".rt-chronologue-timeline-arc");
  if (chronologueArcLayer) {
    chronologueArcLayer.appendChild(arcGroup);
    chronologueArcLayer.appendChild(labelGroup);
    const parent = chronologueArcLayer.parentElement;
    if (parent) {
      parent.appendChild(chronologueArcLayer);
    }
  } else {
    svg.appendChild(arcGroup);
    svg.appendChild(labelGroup);
  }
}
function createElapsedTimeLabel(x, y, value, midpointAngle) {
  const labelGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
  labelGroup.setAttribute("class", "rt-elapsed-time-group");
  const labelText = document.createElementNS("http://www.w3.org/2000/svg", "text");
  labelText.setAttribute("y", `${y}`);
  labelText.setAttribute("dominant-baseline", "middle");
  labelText.setAttribute("fill", "var(--interactive-accent)");
  labelText.setAttribute("class", "rt-elapsed-time-label");
  labelText.textContent = value;
  let textAnchor = "middle";
  let adjustedX = x;
  if (midpointAngle !== void 0) {
    const normalizedAngle = (midpointAngle % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
    if (normalizedAngle > 5.5 || normalizedAngle < 0.8) {
      textAnchor = "end";
      adjustedX = x - 10;
    } else if (normalizedAngle > 2.4 && normalizedAngle < 3.9) {
      textAnchor = "start";
      adjustedX = x + 10;
    }
  }
  labelText.setAttribute("x", `${adjustedX}`);
  labelText.setAttribute("text-anchor", textAnchor);
  labelGroup.appendChild(labelText);
  return labelGroup;
}
function normalizeAngle(angle) {
  const twoPi = Math.PI * 2;
  let normalized = angle % twoPi;
  if (normalized < 0) {
    normalized += twoPi;
  }
  return normalized;
}
function removeElapsedTimeArc(svg) {
  const existingArc = svg.querySelector(".rt-elapsed-time-arc");
  const existingGroup = svg.querySelector(".rt-elapsed-time-group");
  if (existingArc) existingArc.remove();
  if (existingGroup) existingGroup.remove();
  restoreHiddenTicks(svg);
}
function hideOverlappingTicks(svg, angle1, angle2) {
  const ANGLE_TOLERANCE = 0.01;
  const ticks = Array.from(svg.querySelectorAll(".rt-chronological-tick"));
  ticks.forEach((tick) => {
    const x1Str = tick.getAttribute("x1");
    const y1Str = tick.getAttribute("y1");
    if (!x1Str || !y1Str) return;
    const x1 = parseFloat(x1Str);
    const y1 = parseFloat(y1Str);
    const tickAngle = Math.atan2(y1, x1);
    const normalizeAngle3 = (angle) => {
      let normalized = angle;
      while (normalized > Math.PI) normalized -= 2 * Math.PI;
      while (normalized < -Math.PI) normalized += 2 * Math.PI;
      return normalized;
    };
    const normalizedTickAngle = normalizeAngle3(tickAngle);
    const normalizedAngle1 = normalizeAngle3(angle1);
    const normalizedAngle2 = normalizeAngle3(angle2);
    const matchesAngle1 = Math.abs(normalizedTickAngle - normalizedAngle1) < ANGLE_TOLERANCE;
    const matchesAngle2 = Math.abs(normalizedTickAngle - normalizedAngle2) < ANGLE_TOLERANCE;
    if (matchesAngle1 || matchesAngle2) {
      tick.classList.add("rt-tick-hidden");
    }
  });
}
function restoreHiddenTicks(svg) {
  const hiddenTicks = Array.from(svg.querySelectorAll(".rt-tick-hidden"));
  hiddenTicks.forEach((tick) => tick.classList.remove("rt-tick-hidden"));
}
var BUTTON_ACTIVE_SCALE, globalShiftModeActive, globalAlienModeActive;
var init_ChronologueShiftController = __esm({
  "src/view/interactions/ChronologueShiftController.ts"() {
    init_planetaryTime();
    init_date();
    init_ChronologueTimeline();
    init_LayoutConstants();
    BUTTON_ACTIVE_SCALE = 1.2;
    globalShiftModeActive = false;
    globalAlienModeActive = false;
  }
});

// src/modes/definitions/ChronologueMode.ts
var CHRONOLOGUE_MODE;
var init_ChronologueMode = __esm({
  "src/modes/definitions/ChronologueMode.ts"() {
    init_ModeDefinition();
    CHRONOLOGUE_MODE = {
      id: "chronologue" /* CHRONOLOGUE */,
      name: "Chronologue",
      description: "View scenes in chronological story order based on When field",
      rendering: {
        outerRingContent: "chronologue",
        innerRingContent: "chronologue",
        beatDisplay: "none",
        sceneColoring: "subplot",
        numberSquares: "full",
        overlayLayers: ["chronological-timeline"],
        visualMuting: []
      },
      interactions: {
        hoverBehavior: "standard-scene-hover",
        clickBehavior: "open-scene-file",
        enableZeroDraftMode: true,
        exitBehavior: "toggle-button"
      },
      ui: {
        acronym: "CHRO",
        tooltip: "Switch to Chronologue mode",
        showInToggleButton: true,
        order: 3
      },
      /**
       * Exit lifecycle hook - Clean up shift mode state
       */
      onExit: async (view) => {
        if (view._chronologueShiftCleanup) {
          view._chronologueShiftCleanup();
          delete view._chronologueShiftCleanup;
        }
        const { resetShiftModeState: resetShiftModeState2 } = await Promise.resolve().then(() => (init_ChronologueShiftController(), ChronologueShiftController_exports));
        resetShiftModeState2();
        const container = view.containerEl;
        if (container) {
          const svg = container.querySelector(".radial-timeline-svg");
          if (svg) {
            svg.removeAttribute("data-shift-mode");
            const shiftButton = svg.querySelector("#shift-mode-toggle");
            if (shiftButton) {
              shiftButton.remove();
            }
            svg.querySelectorAll(".rt-shift-hover, .rt-shift-locked, .rt-shift-selected, .rt-shift-non-select").forEach((el) => {
              el.classList.remove("rt-shift-hover", "rt-shift-locked", "rt-shift-selected", "rt-shift-non-select");
            });
            svg.querySelectorAll(".rt-shift-active").forEach((el) => {
              el.classList.remove("rt-shift-active");
              el.removeAttribute("data-subplot-idx");
            });
            svg.querySelectorAll(".rt-elapsed-time-arc, .rt-elapsed-time-group").forEach((el) => {
              el.remove();
            });
            svg.querySelectorAll(".rt-selected, .rt-non-selected").forEach((el) => {
              el.classList.remove("rt-selected", "rt-non-selected");
            });
          }
        }
      }
    };
  }
});

// src/modes/ModeRegistry.ts
var ModeRegistry_exports = {};
__export(ModeRegistry_exports, {
  getAllModes: () => getAllModes,
  getModeDefinition: () => getModeDefinition,
  getNextToggleMode: () => getNextToggleMode,
  getToggleableModes: () => getToggleableModes,
  isModeRegistered: () => isModeRegistered
});
function getModeDefinition(mode) {
  const definition = MODE_REGISTRY.get(mode);
  if (!definition) {
    return NARRATIVE_MODE;
  }
  return definition;
}
function getAllModes() {
  return Array.from(MODE_REGISTRY.values());
}
function getToggleableModes() {
  return getAllModes().filter((mode) => mode.ui.showInToggleButton).sort((a, b) => a.ui.order - b.ui.order);
}
function getNextToggleMode(currentMode) {
  var _a;
  const toggleable = getToggleableModes();
  const currentIndex = toggleable.findIndex((mode) => mode.id === currentMode);
  if (currentIndex === -1) {
    return ((_a = toggleable[0]) == null ? void 0 : _a.id) || "narrative" /* NARRATIVE */;
  }
  const nextIndex = (currentIndex + 1) % toggleable.length;
  return toggleable[nextIndex].id;
}
function isModeRegistered(mode) {
  return MODE_REGISTRY.has(mode);
}
var MODE_REGISTRY;
var init_ModeRegistry = __esm({
  "src/modes/ModeRegistry.ts"() {
    init_ModeDefinition();
    init_AllScenesMode();
    init_MainPlotMode();
    init_GossamerMode();
    init_ChronologueMode();
    MODE_REGISTRY = /* @__PURE__ */ new Map([
      ["narrative" /* NARRATIVE */, NARRATIVE_MODE],
      ["subplot" /* SUBPLOT */, SUBPLOT_MODE],
      ["chronologue" /* CHRONOLOGUE */, CHRONOLOGUE_MODE],
      ["gossamer" /* GOSSAMER */, GOSSAMER_MODE]
    ]);
  }
});

// src/utils/fileUtils.ts
async function openOrRevealFile(app, file, newLeaf = false) {
  const leaves = app.workspace.getLeavesOfType("markdown");
  const existingLeaf = leaves.find((leaf) => {
    var _a;
    const view = leaf.view;
    return view instanceof import_obsidian11.MarkdownView && ((_a = view.file) == null ? void 0 : _a.path) === file.path;
  });
  if (existingLeaf) {
    app.workspace.setActiveLeaf(existingLeaf);
    return;
  }
  await app.workspace.openLinkText(file.path, "", newLeaf);
}
var import_obsidian11;
var init_fileUtils = __esm({
  "src/utils/fileUtils.ts"() {
    import_obsidian11 = require("obsidian");
  }
});

// src/view/interactions/DominantSubplotHandler.ts
async function handleDominantSubplotSelection(view, clickedGroup, svgElement, scenes) {
  var _a, _b, _c, _d;
  const subplotIndexAttr = clickedGroup.getAttribute("data-subplot-index");
  const encodedPath = clickedGroup.getAttribute("data-path");
  if (!subplotIndexAttr || !encodedPath) {
    return;
  }
  const subplotIndex = parseInt(subplotIndexAttr, 10);
  if (isNaN(subplotIndex)) {
    return;
  }
  const subplotLabels = Array.from(svgElement.querySelectorAll(".rt-subplot-ring-label-text"));
  const masterSubplotOrder = subplotLabels.map((label) => label.getAttribute("data-subplot-name")).filter((name) => name !== null);
  if (subplotIndex >= masterSubplotOrder.length) {
    return;
  }
  const clickedSubplot = masterSubplotOrder[subplotIndex];
  const scenesInClickedSubplot = scenes.filter((s) => s.subplot === clickedSubplot);
  const pathToScenes = /* @__PURE__ */ new Map();
  scenes.forEach((s) => {
    if (s.path) {
      if (!pathToScenes.has(s.path)) {
        pathToScenes.set(s.path, []);
      }
      pathToScenes.get(s.path).push(s);
    }
  });
  let updatedCount = 0;
  if (!view.plugin.settings.dominantSubplots) {
    view.plugin.settings.dominantSubplots = {};
  }
  scenesInClickedSubplot.forEach((scene) => {
    if (!scene.path) return;
    const scenesWithSamePath = pathToScenes.get(scene.path) || [];
    if (scenesWithSamePath.length > 1) {
      view.plugin.settings.dominantSubplots[scene.path] = clickedSubplot;
      updatedCount++;
    }
  });
  if (updatedCount > 0) {
    if (view.plugin.saveSettings) {
      await view.plugin.saveSettings();
    }
    const timelineView = (_d = (_c = (_b = (_a = view.plugin.app) == null ? void 0 : _a.workspace) == null ? void 0 : _b.getLeavesOfType("radial-timeline")) == null ? void 0 : _c[0]) == null ? void 0 : _d.view;
    if (timelineView == null ? void 0 : timelineView.refreshTimeline) {
      timelineView.refreshTimeline();
    }
  }
}
var init_DominantSubplotHandler = __esm({
  "src/view/interactions/DominantSubplotHandler.ts"() {
  }
});

// src/view/interactions/SynopsisTitleColorManager.ts
function updateSynopsisTitleColor(synopsis, sceneId, mode) {
  var _a;
  const titleTspans = synopsis.querySelectorAll('.rt-scene-title-bold[data-item-type="title"]');
  if (titleTspans.length === 0) return;
  let color = null;
  if (mode === "narrative" || mode === "chronologue") {
    const sceneGroup = (_a = document.getElementById(sceneId)) == null ? void 0 : _a.closest(".rt-scene-group");
    if (sceneGroup) {
      if (sceneGroup.getAttribute("data-item-type") === "Backdrop") {
        color = getComputedStyle(document.documentElement).getPropertyValue("--rt-max-publish-stage-color").trim();
      } else {
        const subplotIndex = sceneGroup.getAttribute("data-subplot-color-index") || sceneGroup.getAttribute("data-subplot-index");
        if (subplotIndex) {
          const idx = (parseInt(subplotIndex, 10) % 16 + 16) % 16;
          const varName = `--rt-subplot-colors-${idx}`;
          color = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        }
      }
    }
  } else if (mode === "subplot") {
    color = synopsis.getAttribute("data-stage-color");
  }
  if (color) {
    titleTspans.forEach((tspan) => {
      tspan.style.setProperty("--rt-dynamic-color", color);
    });
  }
}
var init_SynopsisTitleColorManager = __esm({
  "src/view/interactions/SynopsisTitleColorManager.ts"() {
  }
});

// src/view/interactions/SceneTitleExpansion.ts
function needsExpansion(textWidth, currentArcLength, midRadius) {
  const angularNudgePx = TEXTPATH_START_NUDGE_RAD2 * midRadius;
  const requiredArcPx = textWidth + PADDING_PX + TEXTPATH_START_OFFSET_PX + angularNudgePx;
  return currentArcLength < requiredArcPx;
}
function calculateTargetSize(textWidth, midRadius) {
  const angularNudgePx = TEXTPATH_START_NUDGE_RAD2 * midRadius;
  const requiredArcPx = textWidth + PADDING_PX + TEXTPATH_START_OFFSET_PX + angularNudgePx;
  const targetArcPx = requiredArcPx * HOVER_EXPAND_FACTOR;
  return targetArcPx / midRadius;
}
function getActBoundaries(actNumber, totalActs = 3) {
  if (actNumber === 0) {
    return {
      start: -Math.PI / 2,
      end: -Math.PI / 2 + 2 * Math.PI
    };
  } else {
    const NUM_ACTS = Math.max(3, totalActs);
    return {
      start: actNumber * 2 * Math.PI / NUM_ACTS - Math.PI / 2,
      end: (actNumber + 1) * 2 * Math.PI / NUM_ACTS - Math.PI / 2
    };
  }
}
function redistributeAngles(elements, hoveredId, targetSize, actStartAngle) {
  const scenes = elements.filter((e) => e.isScene);
  const beats = elements.filter((e) => !e.isScene);
  const totalBeatSpace = beats.reduce((sum, beat) => sum + (beat.endAngle - beat.startAngle), 0);
  const totalActSpace = elements.reduce((sum, el) => sum + (el.endAngle - el.startAngle), 0);
  const availableSceneSpace = totalActSpace - totalBeatSpace;
  const spaceForOtherScenes = availableSceneSpace - targetSize;
  const sizePerOtherScene = spaceForOtherScenes / (scenes.length - 1);
  const results = [];
  let currentAngle = actStartAngle;
  for (const element of elements) {
    let newStart = currentAngle;
    let newEnd;
    if (element.id === hoveredId) {
      newEnd = currentAngle + targetSize;
    } else if (element.isScene) {
      newEnd = currentAngle + sizePerOtherScene;
    } else {
      const originalSize = element.endAngle - element.startAngle;
      newEnd = currentAngle + originalSize;
    }
    results.push({
      id: element.id,
      newStartAngle: newStart,
      newEndAngle: newEnd
    });
    currentAngle = newEnd;
  }
  return results;
}
function buildArcPath(innerRadius, outerRadius, startAngle, endAngle) {
  const formatNumber3 = (n) => n.toFixed(6);
  const largeArcFlag = endAngle - startAngle > Math.PI ? 1 : 0;
  return `
        M ${formatNumber3(innerRadius * Math.cos(startAngle))} ${formatNumber3(innerRadius * Math.sin(startAngle))}
        L ${formatNumber3(outerRadius * Math.cos(startAngle))} ${formatNumber3(outerRadius * Math.sin(startAngle))}
        A ${formatNumber3(outerRadius)} ${formatNumber3(outerRadius)} 0 ${largeArcFlag} 1 ${formatNumber3(outerRadius * Math.cos(endAngle))} ${formatNumber3(outerRadius * Math.sin(endAngle))}
        L ${formatNumber3(innerRadius * Math.cos(endAngle))} ${formatNumber3(innerRadius * Math.sin(endAngle))}
        A ${formatNumber3(innerRadius)} ${formatNumber3(innerRadius)} 0 ${largeArcFlag} 0 ${formatNumber3(innerRadius * Math.cos(startAngle))} ${formatNumber3(innerRadius * Math.sin(startAngle))}
    `;
}
function buildTextPath(radius, startAngle, endAngle) {
  const formatNumber3 = (n) => n.toFixed(6);
  const textStart = startAngle + TEXTPATH_START_NUDGE_RAD2;
  const largeArcFlag = endAngle - textStart > Math.PI ? 1 : 0;
  return `M ${formatNumber3(radius * Math.cos(textStart))} ${formatNumber3(radius * Math.sin(textStart))} A ${formatNumber3(radius)} ${formatNumber3(radius)} 0 ${largeArcFlag} 1 ${formatNumber3(radius * Math.cos(endAngle))} ${formatNumber3(radius * Math.sin(endAngle))}`;
}
var HOVER_EXPAND_FACTOR, SCENE_TITLE_INSET2, TEXTPATH_START_NUDGE_RAD2, TEXTPATH_START_OFFSET_PX, PADDING_PX;
var init_SceneTitleExpansion = __esm({
  "src/view/interactions/SceneTitleExpansion.ts"() {
    HOVER_EXPAND_FACTOR = 1.05;
    SCENE_TITLE_INSET2 = 22;
    TEXTPATH_START_NUDGE_RAD2 = 0.02;
    TEXTPATH_START_OFFSET_PX = 4;
    PADDING_PX = 8;
  }
});

// src/view/interactions/SceneInteractionManager.ts
var SceneInteractionManager;
var init_SceneInteractionManager = __esm({
  "src/view/interactions/SceneInteractionManager.ts"() {
    init_SynopsisTitleColorManager();
    init_SceneTitleExpansion();
    SceneInteractionManager = class {
      constructor(view, svg, totalActs) {
        this.enabled = true;
        this.totalActs = 3;
        // State tracking
        this.currentGroup = null;
        this.currentSynopsis = null;
        this.currentSceneId = null;
        this.rafId = null;
        this.registerFn = null;
        // Original state storage for reset
        this.originalAngles = /* @__PURE__ */ new Map();
        this.originalSquareTransforms = /* @__PURE__ */ new Map();
        // Cleanup registration (for Obsidian's Component system)
        this.cleanupCallbacks = [];
        this.svg = svg;
        this.totalActs = Math.max(3, totalActs != null ? totalActs : 3);
        this.registerFn = typeof view.register === "function" ? view.register.bind(view) : null;
        this.measurementText = document.createElementNS("http://www.w3.org/2000/svg", "text");
        this.measurementText.classList.add("rt-measure-text");
        svg.appendChild(this.measurementText);
        this.register(() => {
          if (this.rafId !== null) {
            cancelAnimationFrame(this.rafId);
            this.rafId = null;
          }
        });
      }
      setActCount(count) {
        this.totalActs = Math.max(3, count);
      }
      /**
       * Get the view (uses getLeavesOfType to avoid persistent reference)
       */
      getView() {
        const doc = this.svg.ownerDocument;
        if (!doc || !doc.defaultView) return null;
        const win = doc.defaultView;
        if (!win.app) return null;
        const leaves = win.app.workspace.getLeavesOfType("radial-timeline");
        if (!leaves || leaves.length === 0) return null;
        return leaves[0].view;
      }
      /**
       * Enable or disable title expansion based on settings
       */
      setTitleExpansionEnabled(enabled) {
        this.enabled = enabled;
      }
      /**
       * Handle scene hover
       */
      onSceneHover(group, sceneId, mouseEvent) {
        const view = this.getView();
        if (!view) return;
        this.currentGroup = group;
        this.currentSceneId = sceneId;
        this.currentSynopsis = this.findSynopsisForScene(sceneId);
        this.applySelection(group, sceneId);
        if (this.currentSynopsis) {
          if (mouseEvent) {
            view.plugin.synopsisManager.updatePosition(
              this.currentSynopsis,
              mouseEvent,
              this.svg,
              sceneId
            );
          }
          const currentMode = view.plugin.settings.currentMode || "narrative";
          updateSynopsisTitleColor(this.currentSynopsis, sceneId, currentMode);
          this.currentSynopsis.classList.add("rt-visible");
        }
        if (this.enabled && view.plugin.settings.enableSceneTitleAutoExpand) {
          const sceneTitle = group.querySelector(".rt-scene-title");
          if (sceneTitle) {
            this.redistributeActScenes(group);
          }
        }
      }
      /**
       * Handle scene leave
       */
      onSceneLeave() {
        if (this.originalAngles.size > 0) {
          this.resetAngularRedistribution();
        }
        this.clearSelection();
        this.currentGroup = null;
        this.currentSynopsis = null;
        this.currentSceneId = null;
      }
      /**
       * Update synopsis position on mouse move
       */
      onMouseMove(e) {
        if (this.rafId !== null) return;
        const rafId = window.requestAnimationFrame(() => {
          this.rafId = null;
          const view = this.getView();
          if (!view || !this.currentSynopsis || !this.currentSceneId) return;
          if (!this.currentSynopsis.classList.contains("rt-visible")) return;
          view.plugin.synopsisManager.updatePosition(
            this.currentSynopsis,
            e,
            this.svg,
            this.currentSceneId
          );
        });
        this.register(() => cancelAnimationFrame(rafId));
        this.rafId = rafId;
      }
      /**
       * Clean up resources
       */
      cleanup() {
        if (this.rafId !== null) {
          cancelAnimationFrame(this.rafId);
          this.rafId = null;
        }
        if (this.measurementText && this.measurementText.parentNode) {
          this.measurementText.parentNode.removeChild(this.measurementText);
        }
        this.resetAngularRedistribution();
        this.clearSelection();
        this.cleanupCallbacks.forEach((fn) => {
          try {
            fn();
          } catch (e) {
          }
        });
        this.cleanupCallbacks = [];
      }
      // ========================================================================
      // Private Helper Methods
      // ========================================================================
      findSynopsisForScene(sceneId) {
        return this.svg.querySelector(`.rt-scene-info[data-for-scene="${sceneId}"]`);
      }
      clearSelection() {
        const all = this.svg.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title, .rt-discontinuity-marker");
        all.forEach((el) => el.classList.remove("rt-selected"));
        const view = this.getView();
        if (view && view.currentMode !== "gossamer") {
          all.forEach((el) => el.classList.remove("rt-non-selected"));
        }
        if (this.currentSynopsis) {
          this.currentSynopsis.classList.remove("rt-visible");
        }
      }
      applySelection(group, sceneId) {
        const pathEl = group.querySelector(".rt-scene-path");
        if (pathEl) pathEl.classList.add("rt-selected");
        const numberSquare = this.svg.querySelector(`.rt-number-square[data-scene-id="${sceneId}"]`);
        if (numberSquare) numberSquare.classList.add("rt-selected");
        const numberText = this.svg.querySelector(`.rt-number-text[data-scene-id="${sceneId}"]`);
        if (numberText) numberText.classList.add("rt-selected");
        const sceneTitle = group.querySelector(".rt-scene-title");
        if (sceneTitle) sceneTitle.classList.add("rt-selected");
        const related = /* @__PURE__ */ new Set();
        const currentPathAttr = group.getAttribute("data-path");
        if (currentPathAttr) {
          const matches = this.svg.querySelectorAll(`[data-path="${currentPathAttr}"]`);
          matches.forEach((mg) => {
            if (mg === group) return;
            const rp = mg.querySelector(".rt-scene-path");
            if (rp) related.add(rp);
            const rt = mg.querySelector(".rt-scene-title");
            if (rt) related.add(rt);
            const rid = rp == null ? void 0 : rp.id;
            if (rid) {
              const rsq = this.svg.querySelector(`.rt-number-square[data-scene-id="${rid}"]`);
              if (rsq) related.add(rsq);
              const rtx = this.svg.querySelector(`.rt-number-text[data-scene-id="${rid}"]`);
              if (rtx) related.add(rtx);
            }
          });
        }
        const all = this.svg.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title, .rt-discontinuity-marker");
        all.forEach((el) => {
          if (!el.classList.contains("rt-selected") && !related.has(el)) {
            el.classList.add("rt-non-selected");
          }
        });
      }
      // ========================================================================
      // Scene Title Expansion Logic
      // ========================================================================
      storeOriginalAngles() {
        if (this.originalAngles.size > 0) return;
        const view = this.getView();
        if (!view) return;
        this.svg.querySelectorAll(".rt-scene-group").forEach((group) => {
          const start = Number(group.getAttribute("data-start-angle")) || 0;
          const end = Number(group.getAttribute("data-end-angle")) || 0;
          this.originalAngles.set(group.id, { start, end });
          const scenePathEl = group.querySelector(".rt-scene-path");
          if (scenePathEl) {
            const sceneId = scenePathEl.id;
            const numberSquareGroup = view.getSquareGroupForSceneId(this.svg, sceneId);
            if (numberSquareGroup) {
              const originalTransform = numberSquareGroup.getAttribute("transform") || "";
              this.originalSquareTransforms.set(sceneId, originalTransform);
            }
          }
        });
      }
      resetAngularRedistribution() {
        this.originalAngles.forEach((angles, groupId) => {
          const group = this.svg.getElementById(groupId);
          if (!group) return;
          const innerR = Number(group.getAttribute("data-inner-r")) || 0;
          const outerR = Number(group.getAttribute("data-outer-r")) || 0;
          const path = group.querySelector(".rt-scene-path");
          if (path) {
            path.setAttribute("d", buildArcPath(innerR, outerR, angles.start, angles.end));
          }
          const textPath = group.querySelector('path[id^="textPath-"]');
          if (textPath) {
            const insetAttr = group.getAttribute("data-title-inset");
            const titleInset = insetAttr ? Number(insetAttr) : SCENE_TITLE_INSET2;
            const textPathRadius = Math.max(innerR, outerR - titleInset);
            textPath.setAttribute("d", buildTextPath(textPathRadius, angles.start, angles.end));
          }
          const scenePathEl = group.querySelector(".rt-scene-path");
          if (scenePathEl) {
            const sceneId = scenePathEl.id;
            const originalTransform = this.originalSquareTransforms.get(sceneId);
            if (originalTransform !== void 0) {
              const match = originalTransform.match(/translate\(([^,]+),\s*([^)]+)\)/);
              if (match) {
                const view = this.getView();
                if (view) {
                  view.setNumberSquareGroupPosition(
                    this.svg,
                    sceneId,
                    parseFloat(match[1]),
                    parseFloat(match[2])
                  );
                }
              }
            }
          }
        });
        this.originalAngles.clear();
        this.originalSquareTransforms.clear();
      }
      redistributeActScenes(hoveredGroup) {
        this.storeOriginalAngles();
        const hoveredAct = hoveredGroup.getAttribute("data-act");
        const hoveredRing = hoveredGroup.getAttribute("data-ring");
        if (!hoveredAct || !hoveredRing) return;
        const actElements = [];
        const sceneElements = [];
        this.svg.querySelectorAll(".rt-scene-group").forEach((group) => {
          if (group.getAttribute("data-act") === hoveredAct && group.getAttribute("data-ring") === hoveredRing) {
            const path = group.querySelector(".rt-scene-path");
            if (path) {
              const sceneTitle = group.querySelector(".rt-scene-title");
              const isScene = !!sceneTitle;
              if (isScene) {
                sceneElements.push(group);
              }
              actElements.push({
                id: group.id,
                startAngle: Number(group.getAttribute("data-start-angle")) || 0,
                endAngle: Number(group.getAttribute("data-end-angle")) || 0,
                innerRadius: Number(group.getAttribute("data-inner-r")) || 0,
                outerRadius: Number(group.getAttribute("data-outer-r")) || 0,
                isScene
              });
            }
          }
        });
        if (actElements.length <= 1) return;
        if (!sceneElements.includes(hoveredGroup)) return;
        const hoveredData = actElements.find((e) => e.id === hoveredGroup.id);
        if (!hoveredData) return;
        const hoveredMidR = (hoveredData.innerRadius + hoveredData.outerRadius) / 2;
        const currentArcPx = (hoveredData.endAngle - hoveredData.startAngle) * hoveredMidR;
        const hoveredSceneTitle = hoveredGroup.querySelector(".rt-scene-title");
        if (!hoveredSceneTitle) return;
        const titleText = hoveredSceneTitle.textContent || "";
        if (!titleText.trim()) return;
        this.measurementText.textContent = titleText;
        const hoveredComputed = getComputedStyle(hoveredSceneTitle);
        const fontFamily = hoveredComputed.fontFamily || "sans-serif";
        const fontSize = hoveredComputed.fontSize || "18px";
        this.measurementText.style.setProperty("--rt-measurement-font-family", fontFamily);
        this.measurementText.style.setProperty("--rt-measurement-font-size", fontSize);
        const textBBox = this.measurementText.getBBox();
        const textWidth = textBBox.width;
        if (!needsExpansion(textWidth, currentArcPx, hoveredMidR)) {
          return;
        }
        const targetSize = calculateTargetSize(textWidth, hoveredMidR);
        const actNum = Number(hoveredAct);
        const actBounds = getActBoundaries(actNum, this.totalActs);
        const redistribution = redistributeAngles(
          actElements,
          hoveredGroup.id,
          targetSize,
          actBounds.start
        );
        redistribution.forEach((result) => {
          const group = this.svg.getElementById(result.id);
          if (!group) return;
          const innerR = Number(group.getAttribute("data-inner-r")) || 0;
          const outerR = Number(group.getAttribute("data-outer-r")) || 0;
          const path = group.querySelector(".rt-scene-path");
          if (path) {
            path.setAttribute("d", buildArcPath(innerR, outerR, result.newStartAngle, result.newEndAngle));
          }
          const textPath = group.querySelector('path[id^="textPath-"]');
          if (textPath) {
            const insetAttr = group.getAttribute("data-title-inset");
            const titleInset = insetAttr ? Number(insetAttr) : SCENE_TITLE_INSET2;
            const textPathRadius = Math.max(innerR, outerR - titleInset);
            textPath.setAttribute("d", buildTextPath(textPathRadius, result.newStartAngle, result.newEndAngle));
          }
          const scenePathEl = group.querySelector(".rt-scene-path");
          if (scenePathEl) {
            const sceneId = scenePathEl.id;
            const squareRadius = (innerR + outerR) / 2;
            const squareX = squareRadius * Math.cos(result.newStartAngle);
            const squareY = squareRadius * Math.sin(result.newStartAngle);
            const view = this.getView();
            if (view) {
              view.setNumberSquareGroupPosition(this.svg, sceneId, squareX, squareY);
            }
          }
        });
      }
      register(fn) {
        if (this.registerFn) {
          try {
            this.registerFn(fn);
            return;
          } catch (e) {
          }
        }
        this.cleanupCallbacks.push(fn);
      }
    };
  }
});

// src/services/SceneReorderService.ts
async function applySceneNumberUpdates(app, updates) {
  var _a, _b;
  for (const update of updates) {
    const file = app.vault.getAbstractFileByPath(update.path);
    if (!(file instanceof import_obsidian12.TFile)) continue;
    await app.fileManager.processFrontMatter(file, (fm) => {
      if (update.actNumber !== void 0) {
        fm["Act"] = update.actNumber;
      }
    });
    const currentBasename = file.basename;
    const renamedBase = buildRenamedBasename(currentBasename, update.newNumber);
    if (renamedBase !== currentBasename) {
      const parentPath = (_b = (_a = file.parent) == null ? void 0 : _a.path) != null ? _b : "";
      const newPath = parentPath ? `${parentPath}/${renamedBase}.${file.extension}` : `${renamedBase}.${file.extension}`;
      await app.fileManager.renameFile(file, newPath);
    }
  }
}
function buildRenamedBasename(basename, newNumber) {
  var _a, _b;
  const match = basename.match(/^\s*(\d+(?:\.\d+)?)\s+(.*)$/);
  if (match) {
    const rest = (_b = (_a = match[2]) == null ? void 0 : _a.trim()) != null ? _b : "";
    return `${newNumber} ${rest}`.trim();
  }
  return `${newNumber} ${basename}`.trim();
}
var import_obsidian12;
var init_SceneReorderService = __esm({
  "src/services/SceneReorderService.ts"() {
    import_obsidian12 = require("obsidian");
  }
});

// src/modals/DragConfirmModal.ts
var import_obsidian13, ICON_SHUFFLE, ICON_LIST_ORDERED, ICON_BLOCKS, DragConfirmModal;
var init_DragConfirmModal = __esm({
  "src/modals/DragConfirmModal.ts"() {
    import_obsidian13 = require("obsidian");
    ICON_SHUFFLE = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-shuffle-icon lucide-shuffle"><path d="m18 14 4 4-4 4"/><path d="m18 2 4 4-4 4"/><path d="M2 18h1.973a4 4 0 0 0 3.3-1.7l5.454-8.6a4 4 0 0 1 3.3-1.7H22"/><path d="M2 6h1.972a4 4 0 0 1 3.6 2.2"/><path d="M22 18h-6.041a4 4 0 0 1-3.3-1.8l-.359-.45"/></svg>`;
    ICON_LIST_ORDERED = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-list-ordered-icon lucide-list-ordered"><path d="M11 5h10"/><path d="M11 12h10"/><path d="M11 19h10"/><path d="M4 4h1v5"/><path d="M4 9h2"/><path d="M6.5 20H3.4c0-1 2.6-1.925 2.6-3.5a1.5 1.5 0 0 0-2.6-1.02"/></svg>`;
    ICON_BLOCKS = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-blocks-icon lucide-blocks"><path d="M10 22V7a1 1 0 0 0-1-1H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-5a1 1 0 0 0-1-1H2"/><rect x="14" y="2" width="8" height="8" rx="1"/></svg>`;
    DragConfirmModal = class extends import_obsidian13.Modal {
      constructor(app, summaryLines, accent) {
        super(app);
        this.decision = false;
        this.summary = summaryLines;
        this.accent = accent;
      }
      onOpen() {
        const { contentEl, modalEl } = this;
        contentEl.empty();
        if (modalEl) {
          modalEl.classList.add("rt-modal-shell");
          modalEl.style.width = "min(560px, 90vw)";
        }
        contentEl.addClass("rt-modal-container", "rt-drag-confirm-modal");
        if (this.accent) {
          contentEl.style.setProperty("--rt-confirm-accent", this.accent);
        }
        const header = contentEl.createDiv({ cls: "rt-modal-header" });
        header.createSpan({ cls: "rt-modal-badge", text: "Reorder" });
        header.createDiv({ cls: "rt-modal-title", text: "Confirm reorder" });
        const listDiv = contentEl.createDiv({ cls: "rt-drag-confirm-list" });
        this.summary.forEach((line, index) => {
          const row = listDiv.createDiv({ cls: "rt-drag-confirm-row" });
          const iconContainer = row.createDiv({ cls: "rt-drag-confirm-row-icon" });
          if (index === 0) {
            this.setIcon(iconContainer, ICON_SHUFFLE);
          } else if (index === 1) {
            this.setIcon(iconContainer, ICON_LIST_ORDERED);
          } else {
            this.setIcon(iconContainer, ICON_BLOCKS);
          }
          row.createDiv({ cls: "rt-drag-confirm-row-text", text: line });
        });
        const buttons = contentEl.createDiv({ cls: "rt-modal-actions" });
        const confirmBtn = buttons.createEl("button", { text: "Apply", cls: "rt-mod-cta" });
        const cancelBtn = buttons.createEl("button", { text: "Cancel" });
        confirmBtn.addEventListener("click", () => {
          this.decision = true;
          this.close();
        });
        cancelBtn.addEventListener("click", () => {
          this.decision = false;
          this.close();
        });
      }
      setIcon(container, svgString) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svgString, "image/svg+xml");
        if (doc.documentElement) {
          container.empty();
          container.appendChild(document.importNode(doc.documentElement, true));
        }
      }
      getResult() {
        return this.decision;
      }
    };
  }
});

// src/view/interactions/OuterRingDragController.ts
var import_obsidian14, OuterRingDragController;
var init_OuterRingDragController = __esm({
  "src/view/interactions/OuterRingDragController.ts"() {
    import_obsidian14 = require("obsidian");
    init_SceneReorderService();
    init_DragConfirmModal();
    init_LayoutConstants();
    OuterRingDragController = class {
      constructor(view, svg, options) {
        this.HOLD_MS = 180;
        this.MOVE_THRESHOLD_PX = 7;
        this.currentTarget = null;
        this.dragging = false;
        this.sourceSceneId = null;
        this.sourceGroup = null;
        this.holdTimer = null;
        this.startX = 0;
        this.startY = 0;
        this.confirming = false;
        this.dropTick = null;
        this.dropArc = null;
        this.view = view;
        this.svg = svg;
        this.options = options;
      }
      attach() {
        if (this.options.mode !== "narrative") return;
        const outerGroups = Array.from(this.svg.querySelectorAll('.number-square-group[data-outer-ring="true"]'));
        if (!outerGroups.length) return;
        this.view.registerDomEvent(window, "pointermove", (evt) => this.onPointerMove(evt));
        this.view.registerDomEvent(window, "pointerup", () => this.onPointerUp());
        outerGroups.forEach((group) => {
          this.view.registerDomEvent(group, "pointerdown", (evt) => this.startDrag(evt, group));
        });
      }
      log(msg, data) {
        var _a;
        if (!this.options.enableDebug) return;
        const pluginAny = (_a = this.view) == null ? void 0 : _a.plugin;
        if (pluginAny == null ? void 0 : pluginAny.log) {
          pluginAny.log(`Outer ring drag \xB7 ${msg}`, data);
        }
      }
      cssEscape(value) {
        if (typeof window.CSS !== "undefined" && window.CSS.escape) {
          return window.CSS.escape(value);
        }
        return value.replace(/[^a-zA-Z0-9_\-]/g, "\\$&");
      }
      splitNumberParts(numText) {
        if (!numText) return { intPart: 0, suffix: "" };
        const trimmed = String(numText).trim();
        const match = trimmed.match(/^(\d+)(\..+)?$/);
        if (!match) return { intPart: 0, suffix: "" };
        return { intPart: Number(match[1]) || 0, suffix: match[2] || "" };
      }
      getSceneIdFromNumberGroup(group) {
        if (!group) return null;
        const rect = group.querySelector(".rt-number-square[data-scene-id]");
        return (rect == null ? void 0 : rect.dataset.sceneId) || null;
      }
      buildOuterRingOrder() {
        const groups = Array.from(this.svg.querySelectorAll('.number-square-group[data-outer-ring="true"]'));
        return groups.map((group) => {
          var _a;
          const sceneId = this.getSceneIdFromNumberGroup(group) || "";
          const pathEl = sceneId ? this.svg.querySelector(`#${this.cssEscape(sceneId)}`) : null;
          const sceneGroup = pathEl == null ? void 0 : pathEl.closest(".rt-scene-group");
          const encodedPath = (sceneGroup == null ? void 0 : sceneGroup.getAttribute("data-path")) || "";
          const path = encodedPath ? decodeURIComponent(encodedPath) : "";
          const numberTextEl = this.svg.querySelector(`.rt-number-text[data-scene-id="${this.cssEscape(sceneId)}"]`);
          const numberText = ((_a = numberTextEl == null ? void 0 : numberTextEl.textContent) == null ? void 0 : _a.trim()) || "";
          return { sceneId, path, numberText };
        }).filter((entry) => entry.sceneId && entry.path);
      }
      clearHighlight() {
        if (this.currentTarget) {
          this.currentTarget.classList.remove("rt-drop-target");
          this.currentTarget.style.removeProperty("--rt-drag-stroke-color");
          this.currentTarget = null;
        }
        if (this.dropTick) {
          this.dropTick.setAttribute("d", "");
        }
        if (this.dropArc) {
          this.dropArc.setAttribute("d", "");
        }
      }
      setHighlight(group) {
        var _a, _b;
        if (!group || group === this.currentTarget) return;
        this.clearHighlight();
        this.currentTarget = group;
        this.currentTarget.classList.add("rt-drop-target");
        if (this.originColor) {
          this.currentTarget.style.setProperty("--rt-drag-stroke-color", this.originColor);
        }
        const sceneId = this.getSceneIdFromNumberGroup(group);
        if (!sceneId) return;
        const pathEl = this.svg.querySelector(`#${this.cssEscape(sceneId)}`);
        const sceneGroup = pathEl == null ? void 0 : pathEl.closest(".rt-scene-group");
        if (!sceneGroup) return;
        const startAngle = Number((_a = sceneGroup.getAttribute("data-start-angle")) != null ? _a : "");
        const outerR = Number((_b = sceneGroup.getAttribute("data-outer-r")) != null ? _b : "");
        if (!Number.isFinite(startAngle) || !Number.isFinite(outerR)) return;
        this.updateDropTick(startAngle, outerR, this.originColor);
        if (this.originStartAngle !== void 0 && this.originOuterR !== void 0) {
          const rArc = Math.max(this.originOuterR, outerR) + 12;
          this.updateDropArc(this.originStartAngle, startAngle, rArc, this.originColor);
        }
      }
      findOuterGroup(evt) {
        var _a;
        const direct = (_a = evt.target) == null ? void 0 : _a.closest('.number-square-group[data-outer-ring="true"]');
        if (direct) return direct;
        const fromPoint = document.elementFromPoint(evt.clientX, evt.clientY);
        const fallback = fromPoint == null ? void 0 : fromPoint.closest('.number-square-group[data-outer-ring="true"]');
        return fallback;
      }
      ensureDropTick() {
        if (this.dropTick && this.dropTick.isConnected) return this.dropTick;
        const existing = this.svg.querySelector(".rt-drop-target-tick");
        if (existing) {
          this.dropTick = existing;
          return existing;
        }
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.classList.add("rt-drop-target-tick");
        path.setAttribute("d", "");
        const overlays = this.svg.querySelector("#rt-overlays");
        if (overlays) overlays.appendChild(path);
        else this.svg.appendChild(path);
        this.dropTick = path;
        return path;
      }
      ensureDropArc() {
        if (this.dropArc && this.dropArc.isConnected) return this.dropArc;
        const existing = this.svg.querySelector(".rt-drop-target-arc");
        if (existing) {
          this.dropArc = existing;
          return existing;
        }
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.classList.add("rt-drop-target-arc");
        path.setAttribute("d", "");
        const overlays = this.svg.querySelector("#rt-overlays");
        if (overlays) overlays.appendChild(path);
        else this.svg.appendChild(path);
        this.dropArc = path;
        return path;
      }
      updateDropTick(startAngle, outerR, color) {
        const tickLen = 18;
        const r2 = DRAG_DROP_TICK_OUTER_RADIUS;
        const r1 = r2 - tickLen;
        const x1 = r1 * Math.cos(startAngle);
        const y1 = r1 * Math.sin(startAngle);
        const x2 = r2 * Math.cos(startAngle);
        const y2 = r2 * Math.sin(startAngle);
        const tick = this.ensureDropTick();
        tick.setAttribute("d", `M ${x1} ${y1} L ${x2} ${y2}`);
        if (color) {
          tick.style.stroke = color;
          tick.removeAttribute("stroke");
        } else {
          tick.style.removeProperty("stroke");
        }
      }
      updateDropArc(startAngle, endAngle, radius, color) {
        const arc = this.ensureDropArc();
        const rArc = DRAG_DROP_ARC_RADIUS;
        const norm = (a) => {
          while (a < -Math.PI) a += Math.PI * 2;
          while (a > Math.PI) a -= Math.PI * 2;
          return a;
        };
        let a0 = startAngle;
        let a1 = endAngle;
        const delta = norm(a1 - a0);
        const largeArc = Math.abs(delta) > Math.PI ? 1 : 0;
        const sweep = delta >= 0 ? 1 : 0;
        const x0 = rArc * Math.cos(a0);
        const y0 = rArc * Math.sin(a0);
        const x1p = rArc * Math.cos(a1);
        const y1p = rArc * Math.sin(a1);
        arc.setAttribute("d", `M ${x0} ${y0} A ${rArc} ${rArc} 0 ${largeArc} ${sweep} ${x1p} ${y1p}`);
        if (color) {
          arc.style.stroke = color;
          arc.removeAttribute("stroke");
        } else {
          arc.style.removeProperty("stroke");
        }
      }
      resetState() {
        this.dragging = false;
        this.sourceSceneId = null;
        if (this.sourceGroup) {
          this.sourceGroup.classList.remove("rt-drag-source");
        }
        this.sourceGroup = null;
        if (this.holdTimer !== null) {
          window.clearTimeout(this.holdTimer);
          this.holdTimer = null;
        }
        this.svg.classList.remove("rt-dragging-outer");
        this.clearHighlight();
        this.log("resetState");
      }
      beginDrag() {
        if (this.dragging || !this.sourceGroup) return;
        this.dragging = true;
        this.svg.classList.add("rt-dragging-outer");
        this.sourceGroup.classList.add("rt-drag-source");
        this.setHighlight(this.sourceGroup);
        this.log("beginDrag", { sceneId: this.sourceSceneId });
      }
      async finishDrag() {
        var _a, _b, _c, _d, _e;
        if (this.confirming) {
          this.resetState();
          return;
        }
        const targetId = this.currentTarget ? this.getSceneIdFromNumberGroup(this.currentTarget) : null;
        if (!this.sourceSceneId || !targetId || this.sourceSceneId === targetId) {
          this.resetState();
          return;
        }
        const order = this.buildOuterRingOrder();
        const fromIdx = order.findIndex((o) => o.sceneId === this.sourceSceneId);
        const toIdx = order.findIndex((o) => o.sceneId === targetId);
        if (fromIdx === -1 || toIdx === -1) {
          this.resetState();
          return;
        }
        const reordered = [...order];
        const [moved] = reordered.splice(fromIdx, 1);
        reordered.splice(toIdx, 0, moved);
        const updates = [];
        reordered.forEach((entry, idx) => {
          const { suffix } = this.splitNumberParts(entry.numberText);
          const nextNumber = `${idx + 1}${suffix}`;
          if (nextNumber !== entry.numberText) {
            updates.push({ path: entry.path, newNumber: nextNumber });
          }
        });
        const targetPathEl = this.svg.querySelector(`#${this.cssEscape(targetId)}`);
        const targetGroup = targetPathEl == null ? void 0 : targetPathEl.closest(".rt-scene-group");
        const targetActIdx = targetGroup ? Number((_a = targetGroup.getAttribute("data-act")) != null ? _a : 0) : 0;
        const targetActNumber = Number.isFinite(targetActIdx) ? targetActIdx + 1 : void 0;
        const sourcePath = moved.path;
        const sourceOriginalNumber = (_c = (_b = order[fromIdx]) == null ? void 0 : _b.numberText) != null ? _c : "";
        const targetOriginalNumber = (_e = (_d = order[toIdx]) == null ? void 0 : _d.numberText) != null ? _e : "";
        const summaryLines = [
          `Move scene ${sourceOriginalNumber} before scene ${targetOriginalNumber}.`,
          `Will renumber ${updates.length} scene(s).`
        ];
        if (targetActNumber !== void 0) {
          summaryLines.push(`Update moved scene Act \u2192 ${targetActNumber}.`);
        }
        this.confirming = true;
        let confirmed = false;
        try {
          const modal = new DragConfirmModal(this.view.plugin.app, summaryLines, this.originColor);
          confirmed = await new Promise((resolve) => {
            const onClose = () => resolve(modal.getResult());
            modal.onClose = onClose;
            modal.open();
          });
        } finally {
          this.confirming = false;
        }
        if (!confirmed) {
          this.resetState();
          return;
        }
        if (targetActNumber !== void 0) {
          updates.forEach((u) => {
            if (u.path === sourcePath) {
              u.actNumber = targetActNumber;
            }
          });
        }
        if (updates.length === 0) {
          this.resetState();
          return;
        }
        this.log("apply updates", { count: updates.length, from: fromIdx, to: toIdx });
        await applySceneNumberUpdates(this.view.plugin.app, updates);
        new import_obsidian14.Notice(`Moved scene ${sourceOriginalNumber} \u2192 before ${targetOriginalNumber}`, 2e3);
        this.options.onRefresh();
        this.resetState();
      }
      onPointerMove(evt) {
        if (!this.sourceGroup || !this.sourceSceneId) return;
        if (!this.dragging) {
          const dx = evt.clientX - this.startX;
          const dy = evt.clientY - this.startY;
          if (Math.sqrt(dx * dx + dy * dy) >= this.MOVE_THRESHOLD_PX) {
            if (this.holdTimer !== null) {
              window.clearTimeout(this.holdTimer);
              this.holdTimer = null;
            }
            this.beginDrag();
          }
        }
        if (this.dragging) {
          const group = this.findOuterGroup(evt);
          this.setHighlight(group);
          this.log("drag move", { target: this.getSceneIdFromNumberGroup(group) });
        }
      }
      async onPointerUp() {
        if (this.holdTimer !== null) {
          window.clearTimeout(this.holdTimer);
          this.holdTimer = null;
        }
        if (this.dragging) {
          await this.finishDrag();
        } else {
          this.resetState();
        }
      }
      startDrag(evt, group) {
        if (evt.button !== 0) return;
        const sceneId = this.getSceneIdFromNumberGroup(group);
        if (!sceneId) return;
        evt.preventDefault();
        this.sourceSceneId = sceneId;
        this.sourceGroup = group;
        this.startX = evt.clientX;
        this.startY = evt.clientY;
        this.originColor = this.resolveSubplotColorFromGroup(group);
        this.captureOriginGeometry(sceneId);
        if (this.holdTimer !== null) {
          window.clearTimeout(this.holdTimer);
        }
        this.holdTimer = window.setTimeout(() => {
          this.holdTimer = null;
          this.beginDrag();
        }, this.HOLD_MS);
        this.log("pointerdown", { sceneId });
      }
      captureOriginGeometry(sceneId) {
        var _a, _b;
        const pathEl = this.svg.querySelector(`#${this.cssEscape(sceneId)}`);
        const sceneGroup = pathEl == null ? void 0 : pathEl.closest(".rt-scene-group");
        if (!sceneGroup) {
          this.originStartAngle = void 0;
          this.originOuterR = void 0;
          return;
        }
        const startAngle = Number((_a = sceneGroup.getAttribute("data-start-angle")) != null ? _a : "");
        const outerR = Number((_b = sceneGroup.getAttribute("data-outer-r")) != null ? _b : "");
        this.originStartAngle = Number.isFinite(startAngle) ? startAngle : void 0;
        this.originOuterR = Number.isFinite(outerR) ? outerR : void 0;
      }
      resolveSubplotColorFromGroup(group) {
        var _a;
        const subplotIdxAttr = group.getAttribute("data-subplot-color-index") || group.getAttribute("data-subplot-index");
        if (!subplotIdxAttr) return void 0;
        const idx = Number(subplotIdxAttr);
        if (!Number.isFinite(idx)) return void 0;
        const colors = (_a = this.view.plugin.settings) == null ? void 0 : _a.subplotColors;
        if (colors && colors[idx]) return colors[idx];
        return void 0;
      }
    };
  }
});

// src/modals/ZeroDraftModal.ts
var ZeroDraftModal_exports = {};
__export(ZeroDraftModal_exports, {
  ZeroDraftModal: () => ZeroDraftModal,
  default: () => ZeroDraftModal_default
});
var import_obsidian15, ZeroDraftModal, ZeroDraftModal_default;
var init_ZeroDraftModal = __esm({
  "src/modals/ZeroDraftModal.ts"() {
    import_obsidian15 = require("obsidian");
    ZeroDraftModal = class extends import_obsidian15.Modal {
      constructor(app, options) {
        super(app);
        this.titleText = options.titleText;
        this.originalText = (options.initialText || "").trim();
        this.onOk = options.onOk;
        this.onOverride = options.onOverride;
      }
      onOpen() {
        const { contentEl, titleEl, modalEl } = this;
        titleEl.setText("");
        if (modalEl) {
          modalEl.classList.add("rt-modal-shell");
          modalEl.style.width = "680px";
          modalEl.style.maxWidth = "92vw";
        }
        contentEl.addClass("rt-modal-container");
        contentEl.addClass("rt-zero-draft-modal");
        const header = contentEl.createDiv({ cls: "rt-modal-header" });
        header.createSpan({ cls: "rt-modal-badge", text: "Zero Draft" });
        header.createDiv({ cls: "rt-modal-title", text: this.titleText });
        header.createDiv({ cls: "rt-modal-subtitle", text: "Enter Pending Edits below, or click Override to open the note directly." });
        const infoEl = contentEl.createDiv({ cls: "rt-zero-draft-info" });
        infoEl.setText("Zero draft mode is enabled. This scene has Publish Stage = Zero and Status = Complete. You can turn this off in Settings \u2192 Zero draft mode.");
        this.textareaEl = contentEl.createEl("textarea", { cls: "rt-zero-draft-textarea" });
        this.textareaEl.value = this.originalText;
        const buttonRow = contentEl.createDiv({ cls: "rt-modal-actions" });
        new import_obsidian15.ButtonComponent(buttonRow).setButtonText("Save").setCta().onClick(() => {
          const next = (this.textareaEl.value || "").trim();
          if (this.originalText.length > 0 && next.length === 0) {
            const confirmed = window.confirm("Delete existing pending edits content? This will remove all previous text.");
            if (!confirmed) return;
          }
          this.onOk(next);
          this.close();
        });
        new import_obsidian15.ButtonComponent(buttonRow).setButtonText("Override").setWarning().onClick(() => {
          const current = (this.textareaEl.value || "").trim();
          const isDirty = current !== this.originalText;
          if (isDirty) {
            const discard = window.confirm("Discard changes?");
            if (!discard) return;
          }
          this.onOverride();
          this.close();
        });
        new import_obsidian15.ButtonComponent(buttonRow).setButtonText("Cancel").onClick(() => {
          const current = (this.textareaEl.value || "").trim();
          const isDirty = current !== this.originalText;
          if (isDirty) {
            const discard = window.confirm("Discard changes?");
            if (!discard) return;
          }
          this.close();
        });
      }
    };
    ZeroDraftModal_default = ZeroDraftModal;
  }
});

// src/view/modes/AllScenesMode.ts
var AllScenesMode_exports = {};
__export(AllScenesMode_exports, {
  setupAllScenesDelegatedHover: () => setupAllScenesDelegatedHover,
  setupOuterRingDrag: () => setupOuterRingDrag,
  setupSceneInteractions: () => setupSceneInteractions
});
function setupSceneInteractions(view, group, svgElement, scenes) {
  if (view.currentMode !== "narrative") return;
  const path = group.querySelector(".rt-scene-path");
  if (!path) return;
  const encodedPath = group.getAttribute("data-path");
  if (encodedPath && encodedPath !== "") {
    const filePath = decodeURIComponent(encodedPath);
    view.registerDomEvent(path, "click", async (evt) => {
      var _a, _b, _c;
      const file = view.plugin.app.vault.getAbstractFileByPath(filePath);
      if (!(file instanceof import_obsidian16.TFile)) return;
      await handleDominantSubplotSelection(view, group, svgElement, scenes);
      if (view.plugin.settings.enableZeroDraftMode) {
        const cache = view.plugin.app.metadataCache.getFileCache(file);
        const fm = cache && cache.frontmatter ? cache.frontmatter : {};
        const getFm = (key) => {
          if (!fm) return void 0;
          const lower = key.toLowerCase();
          for (const k of Object.keys(fm)) {
            if (k.toLowerCase() === lower) return fm[k];
          }
          return void 0;
        };
        const stageValue = String((_a = getFm("Publish Stage")) != null ? _a : "Zero");
        const statusValue = String((_b = getFm("Status")) != null ? _b : "Todo");
        const isStageZero = stageValue.trim().toLowerCase() === "zero";
        const isStatusComplete = statusValue.trim().toLowerCase() === "complete";
        if (isStageZero && isStatusComplete) {
          evt.preventDefault();
          evt.stopPropagation();
          const pendingEdits = String((_c = getFm("Pending Edits")) != null ? _c : "").trim();
          const sceneTitle = file.basename || "Scene";
          const modal = new (init_ZeroDraftModal(), __toCommonJS(ZeroDraftModal_exports)).default(view.plugin.app, {
            titleText: `Pending Edits \u2014 ${sceneTitle}`,
            initialText: pendingEdits,
            onOk: async (nextText) => {
              try {
                await view.plugin.app.fileManager.processFrontMatter(file, (yaml) => {
                  yaml["Pending Edits"] = nextText;
                });
              } catch (e) {
              }
            },
            onOverride: async () => {
              await openOrRevealFile(view.plugin.app, file, false);
            }
          });
          modal.open();
          return;
        }
      }
      await openOrRevealFile(view.plugin.app, file, false);
    });
    view.registerDomEvent(group, "mouseenter", () => {
      const itemType = group.getAttribute("data-item-type");
      if (view.currentMode === "gossamer" && itemType !== "Beat") return;
    });
    view.registerDomEvent(group, "mouseleave", () => {
      const itemType = group.getAttribute("data-item-type");
      if (view.currentMode === "gossamer" && itemType !== "Beat") return;
    });
  }
}
function setupAllScenesDelegatedHover(view, container, scenes) {
  var _a, _b;
  const svg = container.querySelector(".radial-timeline-svg");
  if (!svg) return;
  const totalActs = Math.max(3, (_a = view.plugin.settings.actCount) != null ? _a : 3);
  const manager = new SceneInteractionManager(view, svg, totalActs);
  manager.setTitleExpansionEnabled((_b = view.plugin.settings.enableSceneTitleAutoExpand) != null ? _b : true);
  let currentGroup = null;
  let currentSceneId = null;
  let rafId = null;
  const clearSelection = () => {
    manager.onSceneLeave();
    currentGroup = null;
    currentSceneId = null;
  };
  const getSceneIdFromGroup = (group) => {
    const pathEl = group.querySelector(".rt-scene-path");
    return (pathEl == null ? void 0 : pathEl.id) || null;
  };
  view.registerDomEvent(svg, "pointerover", (e) => {
    const svgMode = svg.getAttribute("data-mode");
    if (svgMode === "gossamer") return;
    const g = e.target.closest(".rt-scene-group");
    if (!g || g === currentGroup) return;
    clearSelection();
    const sid = getSceneIdFromGroup(g);
    if (!sid) return;
    svg.classList.add("scene-hover");
    currentGroup = g;
    currentSceneId = sid;
    manager.onSceneHover(g, sid, e);
  });
  view.registerDomEvent(svg, "pointerout", (e) => {
    const svgMode = svg.getAttribute("data-mode");
    if (svgMode === "gossamer") return;
    const toEl = e.relatedTarget;
    if (currentGroup && toEl && currentGroup.contains(toEl)) return;
    svg.classList.remove("scene-hover");
    clearSelection();
  });
  view.registerDomEvent(svg, "pointermove", (e) => {
    if (rafId !== null) return;
    rafId = window.requestAnimationFrame(() => {
      manager.onMouseMove(e);
      rafId = null;
    });
  });
  view.registerDomEvent(svg, "pointerout", () => {
    if (rafId !== null) {
      cancelAnimationFrame(rafId);
      rafId = null;
    }
  });
}
function setupOuterRingDrag(view, svg) {
  var _a;
  const controller = new OuterRingDragController(view, svg, {
    onRefresh: () => {
      var _a2, _b;
      return (_b = (_a2 = view.plugin) == null ? void 0 : _a2.refreshTimelineIfNeeded) == null ? void 0 : _b.call(_a2, null, 0);
    },
    enableDebug: (_a = view.plugin.settings) == null ? void 0 : _a.enableHoverDebugLogging,
    mode: view.currentMode
  });
  controller.attach();
}
var import_obsidian16;
var init_AllScenesMode2 = __esm({
  "src/view/modes/AllScenesMode.ts"() {
    import_obsidian16 = require("obsidian");
    init_fileUtils();
    init_DominantSubplotHandler();
    init_SceneInteractionManager();
    init_OuterRingDragController();
  }
});

// src/view/modes/MainPlotMode.ts
var MainPlotMode_exports = {};
__export(MainPlotMode_exports, {
  setupMainPlotMode: () => setupMainPlotMode
});
function setupMainPlotMode(view, svg) {
  var _a, _b;
  const totalActs = Math.max(3, (_a = view.plugin.settings.actCount) != null ? _a : 3);
  const manager = new SceneInteractionManager(view, svg, totalActs);
  manager.setTitleExpansionEnabled((_b = view.plugin.settings.enableSceneTitleAutoExpand) != null ? _b : true);
  let currentGroup = null;
  let currentSceneId = null;
  let rafId = null;
  const clearSelection = () => {
    manager.onSceneLeave();
    currentGroup = null;
    currentSceneId = null;
  };
  const getSceneIdFromGroup = (group) => {
    const pathEl = group.querySelector(".rt-scene-path");
    return (pathEl == null ? void 0 : pathEl.id) || null;
  };
  view.registerDomEvent(svg, "pointerover", (e) => {
    const g = e.target.closest('.rt-scene-group[data-item-type="Scene"]');
    if (!g || g === currentGroup) return;
    const sid = getSceneIdFromGroup(g);
    if (!sid) return;
    clearSelection();
    svg.classList.add("scene-hover");
    currentGroup = g;
    currentSceneId = sid;
    manager.onSceneHover(g, sid, e);
  });
  view.registerDomEvent(svg, "pointerout", (e) => {
    const toEl = e.relatedTarget;
    if (currentGroup && toEl && currentGroup.contains(toEl)) return;
    svg.classList.remove("scene-hover");
    clearSelection();
  });
  view.registerDomEvent(svg, "pointermove", (e) => {
    if (rafId !== null) return;
    rafId = window.requestAnimationFrame(() => {
      manager.onMouseMove(e);
      rafId = null;
    });
  });
  view.registerDomEvent(svg, "pointerout", () => {
    if (rafId !== null) {
      cancelAnimationFrame(rafId);
      rafId = null;
    }
  });
  view.registerDomEvent(svg, "click", async (e) => {
    const g = e.target.closest('.rt-scene-group[data-item-type="Scene"]');
    if (!g) return;
    e.stopPropagation();
    const encodedPath = g.getAttribute("data-path");
    if (!encodedPath) return;
    const filePath = decodeURIComponent(encodedPath);
    const file = view.plugin.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian17.TFile) {
      await openOrRevealFile(view.plugin.app, file);
    }
  });
}
var import_obsidian17;
var init_MainPlotMode2 = __esm({
  "src/view/modes/MainPlotMode.ts"() {
    import_obsidian17 = require("obsidian");
    init_fileUtils();
    init_SceneInteractionManager();
  }
});

// src/view/modes/GossamerMode.ts
var GossamerMode_exports = {};
__export(GossamerMode_exports, {
  setupGossamerMode: () => setupGossamerMode
});
function setupGossamerMode(view, svg) {
  let currentGroup = null;
  let currentSynopsis = null;
  const findSynopsisForScene = (sceneId) => {
    return svg.querySelector(`.rt-scene-info[data-for-scene="${sceneId}"]`);
  };
  const getSceneIdFromGroup = (group) => {
    const pathEl = group.querySelector(".rt-scene-path");
    return (pathEl == null ? void 0 : pathEl.id) || null;
  };
  const beatSliceOver = (e) => {
    const g = e.target.closest('.rt-scene-group[data-item-type="Beat"]');
    if (!g) return;
    beatSliceEnter(g, e);
  };
  const beatSliceEnter = (g, e) => {
    var _a;
    if (g === currentGroup) return;
    currentGroup = g;
    svg.classList.add("scene-hover");
    const sid = getSceneIdFromGroup(g);
    if (sid) {
      currentSynopsis = findSynopsisForScene(sid);
      if (currentSynopsis) {
        currentSynopsis.classList.add("rt-visible");
        view.plugin.synopsisManager.updatePosition(currentSynopsis, e, svg, sid);
      }
    }
    const encodedPath = g.getAttribute("data-path") || "";
    if (encodedPath) {
      const dotOrScore = svg.querySelector(`.rt-gossamer-dot[data-path="${encodedPath}"], .rt-gossamer-score-text[data-path="${encodedPath}"]`);
      let beatName = null;
      if (dotOrScore) {
        dotOrScore.classList.add("rt-hover");
        beatName = dotOrScore.getAttribute("data-beat");
      }
      if (!beatName) {
        const titleEl = g.querySelector(".rt-storybeat-title");
        if (titleEl) {
          beatName = ((_a = titleEl.textContent) == null ? void 0 : _a.trim()) || null;
        }
      }
      if (beatName) {
        const centerDot = svg.querySelector(`.rt-gossamer-dot-center[data-beat="${beatName}"]`);
        if (centerDot) centerDot.classList.add("rt-hover");
        const spoke = svg.querySelector(`.rt-gossamer-spoke[data-beat="${beatName}"]`);
        if (spoke) spoke.classList.add("rt-gossamer-spoke-hover");
        const beatOutline = svg.querySelector(`.rt-gossamer-beat-outline[data-beat="${beatName}"]`);
        if (beatOutline) beatOutline.classList.add("rt-hover");
        const historicalDots = svg.querySelectorAll(`.rt-gossamer-dot-historical[data-beat="${beatName}"]`);
        historicalDots.forEach((hd) => hd.classList.add("rt-hover"));
        const rangeValues = svg.querySelectorAll(`.rt-gossamer-range-value[data-beat="${beatName}"]`);
        rangeValues.forEach((rv) => rv.classList.add("rt-hidden"));
        g.classList.add("rt-gossamer-hover");
      }
    }
  };
  const beatSliceOut = (e) => {
    var _a;
    if (!currentGroup) return;
    const toEl = e.relatedTarget;
    if (toEl && (currentGroup.contains(toEl) || !!toEl.closest(".rt-gossamer-dot") || !!toEl.closest(".rt-gossamer-score-text"))) return;
    svg.classList.remove("scene-hover");
    if (currentSynopsis) {
      currentSynopsis.classList.remove("rt-visible");
      currentSynopsis = null;
    }
    const encodedPath = currentGroup.getAttribute("data-path") || "";
    if (encodedPath) {
      const dotOrScore = svg.querySelector(`.rt-gossamer-dot[data-path="${encodedPath}"], .rt-gossamer-score-text[data-path="${encodedPath}"]`);
      let beatName = null;
      if (dotOrScore) {
        dotOrScore.classList.remove("rt-hover");
        beatName = dotOrScore.getAttribute("data-beat");
      }
      if (!beatName) {
        const titleEl = currentGroup.querySelector(".rt-storybeat-title");
        if (titleEl) {
          beatName = ((_a = titleEl.textContent) == null ? void 0 : _a.trim()) || null;
        }
      }
      if (beatName) {
        const centerDot = svg.querySelector(`.rt-gossamer-dot-center[data-beat="${beatName}"]`);
        if (centerDot) centerDot.classList.remove("rt-hover");
        const spoke = svg.querySelector(`.rt-gossamer-spoke[data-beat="${beatName}"]`);
        if (spoke) spoke.classList.remove("rt-gossamer-spoke-hover");
        const beatOutline = svg.querySelector(`.rt-gossamer-beat-outline[data-beat="${beatName}"]`);
        if (beatOutline) beatOutline.classList.remove("rt-hover");
        const historicalDots = svg.querySelectorAll(`.rt-gossamer-dot-historical[data-beat="${beatName}"]`);
        historicalDots.forEach((hd) => hd.classList.remove("rt-hover"));
        const rangeValues = svg.querySelectorAll(`.rt-gossamer-range-value[data-beat="${beatName}"]`);
        rangeValues.forEach((rv) => rv.classList.remove("rt-hidden"));
        currentGroup.classList.remove("rt-gossamer-hover");
      }
    }
    currentGroup = null;
  };
  const dotOver = (e) => {
    const dot = e.target.closest(".rt-gossamer-dot, .rt-gossamer-score-text");
    if (!dot) return;
    dot.classList.add("rt-hover");
    const encodedPath = dot.getAttribute("data-path");
    const beatName = dot.getAttribute("data-beat");
    if (!encodedPath) return;
    svg.classList.add("scene-hover");
    if (beatName) {
      const centerDot = svg.querySelector(`.rt-gossamer-dot-center[data-beat="${beatName}"]`);
      if (centerDot) centerDot.classList.add("rt-hover");
      const beatOutline = svg.querySelector(`.rt-gossamer-beat-outline[data-beat="${beatName}"]`);
      if (beatOutline) beatOutline.classList.add("rt-hover");
      const rangeValues = svg.querySelectorAll(`.rt-gossamer-range-value[data-beat="${beatName}"]`);
      rangeValues.forEach((rv) => rv.classList.add("rt-hidden"));
    }
    const beatGroup = svg.querySelector(`.rt-scene-group[data-path="${encodedPath}"]`);
    if (beatGroup) {
      currentGroup = beatGroup;
      beatGroup.classList.add("rt-gossamer-hover");
      const sid = getSceneIdFromGroup(beatGroup);
      if (sid) {
        currentSynopsis = findSynopsisForScene(sid);
        if (currentSynopsis) {
          currentSynopsis.classList.add("rt-visible");
          view.plugin.synopsisManager.updatePosition(currentSynopsis, e, svg, sid);
        }
      }
    }
    if (beatName) {
      const spoke = svg.querySelector(`.rt-gossamer-spoke[data-beat="${beatName}"]`);
      if (spoke) {
        spoke.classList.add("rt-gossamer-spoke-hover");
      }
      const beatOutline = svg.querySelector(`.rt-gossamer-beat-outline[data-beat="${beatName}"]`);
      if (beatOutline) {
        beatOutline.classList.add("rt-hover");
      }
      const historicalDots = svg.querySelectorAll(`.rt-gossamer-dot-historical[data-beat="${beatName}"]`);
      historicalDots.forEach((hd) => hd.classList.add("rt-hover"));
    }
  };
  const dotOut = (e) => {
    const toEl = e.relatedTarget;
    if (toEl && (toEl.closest('.rt-scene-group[data-item-type="Beat"]') || toEl.closest(".rt-gossamer-dot") || toEl.closest(".rt-gossamer-score-text"))) return;
    svg.classList.remove("scene-hover");
    if (currentSynopsis) {
      currentSynopsis.classList.remove("rt-visible");
      currentSynopsis = null;
    }
    if (currentGroup) {
      currentGroup.classList.remove("rt-gossamer-hover");
      currentGroup = null;
    }
    svg.querySelectorAll(".rt-gossamer-spoke-hover").forEach((el) => {
      el.classList.remove("rt-gossamer-spoke-hover");
    });
    svg.querySelectorAll(".rt-gossamer-dot.rt-hover, .rt-gossamer-score-text.rt-hover").forEach((el) => {
      el.classList.remove("rt-hover");
    });
    svg.querySelectorAll(".rt-gossamer-dot-center.rt-hover").forEach((el) => {
      el.classList.remove("rt-hover");
    });
    svg.querySelectorAll(".rt-gossamer-beat-outline.rt-hover").forEach((el) => {
      el.classList.remove("rt-hover");
    });
    svg.querySelectorAll(".rt-gossamer-dot-historical.rt-hover").forEach((hd) => {
      hd.classList.remove("rt-hover");
    });
    svg.querySelectorAll(".rt-gossamer-range-value.rt-hidden").forEach((rv) => {
      rv.classList.remove("rt-hidden");
    });
  };
  const beatSliceClick = async (e) => {
    const g = e.target.closest('.rt-scene-group[data-item-type="Beat"]');
    if (!g) return;
    e.stopPropagation();
    const encodedPath = g.getAttribute("data-path");
    if (!encodedPath) return;
    const filePath = decodeURIComponent(encodedPath);
    const file = view.plugin.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian18.TFile) {
      await openOrRevealFile(view.plugin.app, file);
    }
  };
  const dotClick = async (e) => {
    const dot = e.target.closest(".rt-gossamer-dot, .rt-gossamer-score-text");
    if (!dot) return;
    e.stopPropagation();
    const encodedPath = dot.getAttribute("data-path");
    if (!encodedPath) return;
    const path = decodeURIComponent(encodedPath);
    const file = view.plugin.app.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian18.TFile) {
      await openOrRevealFile(view.plugin.app, file);
    }
  };
  const backgroundClick = (e) => {
    const target = e.target;
    if (target.closest(".rt-gossamer-dot") || target.closest(".rt-gossamer-score-text") || target.closest('.rt-scene-group[data-item-type="Beat"]')) {
      return;
    }
    Promise.resolve().then(() => (init_GossamerCommands(), GossamerCommands_exports)).then(({ toggleGossamerMode: toggleGossamerMode2 }) => {
      toggleGossamerMode2(view.plugin);
    });
  };
  view.registerDomEvent(svg, "click", beatSliceClick);
  view.registerDomEvent(svg, "click", dotClick);
  view.registerDomEvent(svg, "click", backgroundClick);
  view.registerDomEvent(svg, "pointerover", beatSliceOver);
  view.registerDomEvent(svg, "pointerout", beatSliceOut);
  view.registerDomEvent(svg, "pointerover", dotOver);
  view.registerDomEvent(svg, "pointerout", dotOut);
  view.registerGossamerHandler("pointerover::svg", beatSliceOver);
  view.registerGossamerHandler("pointerout::svg", beatSliceOut);
  view.registerGossamerHandler("pointerover::dot::svg", dotOver);
  view.registerGossamerHandler("pointerout::dot::svg", dotOut);
  view.registerGossamerHandler("click::beat::svg", beatSliceClick);
  view.registerGossamerHandler("click::dot::svg", dotClick);
  view.registerGossamerHandler("click::bg::svg", backgroundClick);
  const beatGroups = svg.querySelectorAll('.rt-scene-group[data-item-type="Beat"]');
  beatGroups.forEach((el) => {
    view.registerDomEvent(el, "pointerenter", (ev) => beatSliceEnter(el, ev));
    view.registerDomEvent(el, "pointerleave", (ev) => beatSliceOut(ev));
    view.registerDomEvent(el, "click", (ev) => beatSliceClick(ev));
  });
}
var import_obsidian18;
var init_GossamerMode2 = __esm({
  "src/view/modes/GossamerMode.ts"() {
    import_obsidian18 = require("obsidian");
    init_fileUtils();
  }
});

// src/view/modes/ChronologueMode.ts
var ChronologueMode_exports = {};
__export(ChronologueMode_exports, {
  setupChronologueMode: () => setupChronologueMode
});
function setupChronologueMode(view, svg) {
  if (view.currentMode !== "chronologue") {
    return;
  }
  setupChronologueShiftController(view, svg);
  setupSceneHoverInteractions(view, svg);
  setupSceneClickInteractions(view, svg);
}
function setupSceneHoverInteractions(view, svg) {
  var _a;
  const totalActs = Math.max(3, (_a = view.plugin.settings.actCount) != null ? _a : 3);
  const manager = new SceneInteractionManager(view, svg, totalActs);
  manager.setTitleExpansionEnabled(false);
  const sceneIdCache = /* @__PURE__ */ new WeakMap();
  const getSceneIdFromGroup = (group) => {
    var _a2;
    const cached = sceneIdCache.get(group);
    if (cached) return cached;
    const pathEl = group.querySelector(".rt-scene-path");
    const sceneId = (_a2 = pathEl == null ? void 0 : pathEl.id) != null ? _a2 : null;
    if (sceneId) {
      sceneIdCache.set(group, sceneId);
    }
    return sceneId;
  };
  const synopsisBySceneId = /* @__PURE__ */ new Map();
  svg.querySelectorAll(".rt-scene-info[data-for-scene]").forEach((synopsis) => {
    const sceneId = synopsis.getAttribute("data-for-scene");
    if (sceneId) {
      synopsisBySceneId.set(sceneId, synopsis);
    }
  });
  const numberSquareBySceneId = /* @__PURE__ */ new Map();
  svg.querySelectorAll(".rt-number-square[data-scene-id]").forEach((square) => {
    const sceneId = square.getAttribute("data-scene-id");
    if (sceneId) {
      numberSquareBySceneId.set(sceneId, square);
    }
  });
  const numberTextBySceneId = /* @__PURE__ */ new Map();
  svg.querySelectorAll(".rt-number-text[data-scene-id]").forEach((text) => {
    const sceneId = text.getAttribute("data-scene-id");
    if (sceneId) {
      numberTextBySceneId.set(sceneId, text);
    }
  });
  const sceneElementRefs = /* @__PURE__ */ new Map();
  const scenesByPath = /* @__PURE__ */ new Map();
  svg.querySelectorAll('.rt-scene-group[data-item-type="Scene"], .rt-scene-group[data-item-type="Backdrop"]').forEach((group) => {
    var _a2, _b;
    const sceneId = getSceneIdFromGroup(group);
    if (!sceneId) return;
    const pathEl = group.querySelector(".rt-scene-path");
    const titleEl = group.querySelector(".rt-scene-title");
    sceneElementRefs.set(sceneId, {
      path: pathEl,
      numberSquare: (_a2 = numberSquareBySceneId.get(sceneId)) != null ? _a2 : null,
      numberText: (_b = numberTextBySceneId.get(sceneId)) != null ? _b : null,
      title: titleEl != null ? titleEl : null
    });
    const pathAttr = group.getAttribute("data-path");
    if (pathAttr) {
      if (!scenesByPath.has(pathAttr)) {
        scenesByPath.set(pathAttr, []);
      }
      scenesByPath.get(pathAttr).push(sceneId);
    }
  });
  const fadeTargets = [];
  const seen = /* @__PURE__ */ new Set();
  svg.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title").forEach((el) => {
    if (!seen.has(el)) {
      fadeTargets.push(el);
      seen.add(el);
    }
  });
  let currentHoveredSceneId = null;
  const applyGlobalFade = () => {
    if (svg.classList.contains("rt-global-fade")) return;
    svg.classList.add("rt-global-fade");
  };
  const clearGlobalFade = () => {
    if (!svg.classList.contains("rt-global-fade")) return;
    svg.classList.remove("rt-global-fade");
  };
  const highlightScene = (sceneId) => {
    var _a2;
    const refs = sceneElementRefs.get(sceneId);
    if (!refs) return;
    if (refs.path) {
      refs.path.classList.add("rt-selected");
      refs.path.classList.remove("rt-non-selected");
    }
    if (refs.numberSquare) {
      refs.numberSquare.classList.remove("rt-non-selected");
    }
    if (refs.numberText) {
      refs.numberText.classList.remove("rt-non-selected");
    }
    if (refs.title) {
      refs.title.classList.remove("rt-non-selected");
    }
    const primaryGroup = (_a2 = refs.path) == null ? void 0 : _a2.closest('.rt-scene-group[data-item-type="Scene"]');
    const currentPathAttr = primaryGroup == null ? void 0 : primaryGroup.getAttribute("data-path");
    if (currentPathAttr) {
      const matchingSceneIds = scenesByPath.get(currentPathAttr);
      if (matchingSceneIds) {
        matchingSceneIds.forEach((matchSceneId) => {
          if (matchSceneId === sceneId) return;
          const matchRefs = sceneElementRefs.get(matchSceneId);
          if (!matchRefs) return;
          if (matchRefs.path) {
            matchRefs.path.classList.add("rt-selected");
            matchRefs.path.classList.remove("rt-non-selected");
          }
          if (matchRefs.numberSquare) {
            matchRefs.numberSquare.classList.remove("rt-non-selected");
          }
          if (matchRefs.numberText) {
            matchRefs.numberText.classList.remove("rt-non-selected");
          }
          if (matchRefs.title) {
            matchRefs.title.classList.remove("rt-non-selected");
          }
        });
      }
    }
  };
  const unhighlightScene = (sceneId, keepFaded) => {
    var _a2;
    const refs = sceneElementRefs.get(sceneId);
    if (!refs) return;
    if (refs.path) {
      refs.path.classList.remove("rt-selected");
      if (keepFaded) {
        refs.path.classList.add("rt-non-selected");
      } else {
        refs.path.classList.remove("rt-non-selected");
      }
    }
    const toggleFade = (el) => {
      if (!el) return;
      if (keepFaded) {
        el.classList.add("rt-non-selected");
      } else {
        el.classList.remove("rt-non-selected");
      }
    };
    toggleFade(refs.numberSquare);
    toggleFade(refs.numberText);
    toggleFade(refs.title);
    const primaryGroup = (_a2 = refs.path) == null ? void 0 : _a2.closest('.rt-scene-group[data-item-type="Scene"]');
    const currentPathAttr = primaryGroup == null ? void 0 : primaryGroup.getAttribute("data-path");
    if (currentPathAttr) {
      const matchingSceneIds = scenesByPath.get(currentPathAttr);
      if (matchingSceneIds) {
        matchingSceneIds.forEach((matchSceneId) => {
          if (matchSceneId === sceneId) return;
          const matchRefs = sceneElementRefs.get(matchSceneId);
          if (!matchRefs) return;
          if (matchRefs.path) {
            matchRefs.path.classList.remove("rt-selected");
            if (keepFaded) {
              matchRefs.path.classList.add("rt-non-selected");
            } else {
              matchRefs.path.classList.remove("rt-non-selected");
            }
          }
          toggleFade(matchRefs.numberSquare);
          toggleFade(matchRefs.numberText);
          toggleFade(matchRefs.title);
        });
      }
    }
  };
  view.registerDomEvent(svg, "pointerover", (e) => {
    var _a2;
    if (isShiftModeActive()) {
      return;
    }
    const g = e.target.closest('.rt-scene-group[data-item-type="Scene"], .rt-scene-group[data-item-type="Backdrop"]');
    if (!g) return;
    const sid = (_a2 = sceneIdCache.get(g)) != null ? _a2 : getSceneIdFromGroup(g);
    if (!sid) return;
    if (currentHoveredSceneId === sid) {
      const syn2 = synopsisBySceneId.get(sid);
      if (syn2) {
        view.plugin.synopsisManager.updatePosition(syn2, e, svg, sid);
        updateSynopsisTitleColor(syn2, sid, "chronologue");
        syn2.classList.add("rt-visible");
      }
      if (g.classList.contains("rt-chronologue-warning")) {
        showWhenFieldWarning(svg, g, e);
      } else {
        hideWhenFieldWarning(svg);
      }
      return;
    }
    const previousSceneId = currentHoveredSceneId;
    applyGlobalFade();
    currentHoveredSceneId = sid;
    if (previousSceneId) {
      const previousSynopsis = synopsisBySceneId.get(previousSceneId);
      if (previousSynopsis) {
        previousSynopsis.classList.remove("rt-visible");
      }
      unhighlightScene(previousSceneId, true);
    }
    svg.classList.add("scene-hover");
    const syn = synopsisBySceneId.get(sid);
    if (syn) {
      view.plugin.synopsisManager.updatePosition(syn, e, svg, sid);
      updateSynopsisTitleColor(syn, sid, "chronologue");
      syn.classList.add("rt-visible");
    }
    highlightScene(sid);
    manager.onSceneHover(g, sid);
    if (g.classList.contains("rt-chronologue-warning")) {
      showWhenFieldWarning(svg, g, e);
    } else {
      hideWhenFieldWarning(svg);
    }
  });
  view.registerDomEvent(svg, "pointerout", (e) => {
    var _a2;
    const g = e.target.closest('.rt-scene-group[data-item-type="Scene"], .rt-scene-group[data-item-type="Backdrop"]');
    if (!g) return;
    const sid = (_a2 = sceneIdCache.get(g)) != null ? _a2 : getSceneIdFromGroup(g);
    if (!sid) return;
    const related = e.relatedTarget;
    manager.onSceneLeave();
    if (related == null ? void 0 : related.closest('.rt-scene-group[data-item-type="Scene"], .rt-scene-group[data-item-type="Backdrop"]')) {
      return;
    }
    const syn = synopsisBySceneId.get(sid);
    if (syn) {
      syn.classList.remove("rt-visible");
    }
    if (currentHoveredSceneId) {
      unhighlightScene(currentHoveredSceneId, false);
      currentHoveredSceneId = null;
    }
    svg.classList.remove("scene-hover");
    clearGlobalFade();
    hideWhenFieldWarning(svg);
  });
}
function setupSceneClickInteractions(view, svg) {
  view.registerDomEvent(svg, "click", async (e) => {
    var _a;
    const g = e.target.closest('.rt-scene-group[data-item-type="Scene"], .rt-scene-group[data-item-type="Backdrop"]');
    if (!g) return;
    if (isShiftModeActive()) {
      const handled = (_a = view.handleShiftModeClick) == null ? void 0 : _a.call(view, e, g);
      if (handled) {
        return;
      }
    }
    const scenes = view.sceneData || view.scenes || [];
    if (scenes.length > 0) {
      await handleDominantSubplotSelection(view, g, svg, scenes);
    }
    e.stopPropagation();
    const encodedPath = g.getAttribute("data-path");
    if (!encodedPath) return;
    const filePath = decodeURIComponent(encodedPath);
    if (view.plugin.app) {
      const file = view.plugin.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian19.TFile) {
        await openOrRevealFile(view.plugin.app, file);
      }
    }
  });
}
function showWhenFieldWarning(svg, sceneGroup, event) {
  hideWhenFieldWarning(svg);
  const warning = document.createElementNS("http://www.w3.org/2000/svg", "g");
  warning.setAttribute("class", "rt-when-field-warning");
  const x = event.clientX;
  const y = event.clientY;
  warning.innerHTML = ` // SAFE: innerHTML used for SVG element creation from trusted internal template
        <rect x="${x - 60}" y="${y - 30}" width="120" height="20" 
              rx="4" fill="var(--background-primary)" 
              stroke="var(--text-error)" stroke-width="1"/>
        <text x="${x}" y="${y - 15}" 
              text-anchor="middle" dominant-baseline="middle"
              font-family="var(--font-text)" font-size="10" font-weight="600"
              fill="var(--text-error)">
            Missing When field
        </text>
    `;
  svg.appendChild(warning);
}
function hideWhenFieldWarning(svg) {
  const existingWarning = svg.querySelector(".rt-when-field-warning");
  if (existingWarning) {
    existingWarning.remove();
  }
}
var import_obsidian19;
var init_ChronologueMode2 = __esm({
  "src/view/modes/ChronologueMode.ts"() {
    import_obsidian19 = require("obsidian");
    init_ChronologueShiftController();
    init_fileUtils();
    init_DominantSubplotHandler();
    init_SceneInteractionManager();
    init_SynopsisTitleColorManager();
  }
});

// src/utils/frontmatter.ts
function normalizeFrontmatterKeys(fm, customMappings) {
  const normalized = {};
  const keyMappings = {
    "class": "Class",
    "itemtype": "itemType",
    "plotsystem": "Plot System",
    "beatmodel": "Beat Model",
    "beatsupdate": "Pulse Update",
    "pulseupdate": "Pulse Update",
    "publishstage": "Publish Stage",
    "scenenumber": "Scene Number",
    "subplot": "Subplot",
    "character": "Character",
    "location": "Location",
    "act": "Act",
    "date": "Date",
    "status": "Status",
    "synopsis": "Synopsis",
    "end": "End",
    "description": "Description",
    "range": "Range",
    "words": "Words",
    "totaltime": "Total Time",
    "supportfiles": "Support Files",
    "due": "Due",
    "pendingedits": "Pending Edits",
    "revision": "Revision",
    "pov": "POV",
    "duration": "Duration",
    "type": "Type",
    "shift": "Shift",
    "questions": "Questions",
    "readeremotion": "Reader Emotion",
    "internal": "Internal",
    "gossamer1": "Gossamer1",
    "gossamer2": "Gossamer2",
    "gossamer3": "Gossamer3",
    "gossamer4": "Gossamer4",
    "gossamer5": "Gossamer5",
    "gossamer6": "Gossamer6",
    "gossamer7": "Gossamer7",
    "gossamer8": "Gossamer8",
    "gossamer9": "Gossamer9",
    "gossamer10": "Gossamer10",
    "gossamer11": "Gossamer11",
    "gossamer12": "Gossamer12",
    "gossamer13": "Gossamer13",
    "gossamer14": "Gossamer14",
    "gossamer15": "Gossamer15",
    "gossamer16": "Gossamer16",
    "gossamer17": "Gossamer17",
    "gossamer18": "Gossamer18",
    "gossamer19": "Gossamer19",
    "gossamer20": "Gossamer20",
    "gossamer21": "Gossamer21",
    "gossamer22": "Gossamer22",
    "gossamer23": "Gossamer23",
    "gossamer24": "Gossamer24",
    "gossamer25": "Gossamer25",
    "gossamer26": "Gossamer26",
    "gossamer27": "Gossamer27",
    "gossamer28": "Gossamer28",
    "gossamer29": "Gossamer29",
    "gossamer30": "Gossamer30",
    "1beats": "1beats",
    "2beats": "2beats",
    "3beats": "3beats",
    "beats1": "beats1",
    "beats2": "beats2",
    "beats3": "beats3",
    "beatslastupdated": "Pulse Last Updated",
    "pulselastupdated": "Pulse Last Updated",
    "when": "When",
    "place": "Place"
  };
  if (customMappings) {
    for (const [userKey, canonicalKey] of Object.entries(customMappings)) {
      const normalizedKey = userKey.toLowerCase().replace(/[\s_-]/g, "");
      keyMappings[normalizedKey] = canonicalKey;
    }
  }
  for (const [key, value] of Object.entries(fm)) {
    const normalizedKey = key.toLowerCase().replace(/[\s_-]/g, "");
    const canonicalKey = keyMappings[normalizedKey] || key;
    if (!(canonicalKey in normalized)) {
      normalized[canonicalKey] = value;
    }
  }
  return normalized;
}
var init_frontmatter = __esm({
  "src/utils/frontmatter.ts"() {
  }
});

// src/api/anthropicApi.ts
async function callAnthropicApi(apiKey, modelId, systemPrompt, userPrompt, maxTokens = 4e3) {
  var _a, _b, _c, _d, _e, _f;
  const apiUrl = "https://api.anthropic.com/v1/messages";
  const apiVersion = "2023-06-01";
  if (!apiKey) {
    return { success: false, content: null, responseData: { type: "error", error: { type: "plugin_config_error", message: "Anthropic API key not configured." } }, error: "Anthropic API key not configured." };
  }
  if (!modelId) {
    return { success: false, content: null, responseData: { type: "error", error: { type: "plugin_config_error", message: "Anthropic model ID not configured." } }, error: "Anthropic model ID not configured." };
  }
  const requestBody = { model: modelId, messages: [{ role: "user", content: userPrompt }], max_tokens: maxTokens };
  if (systemPrompt) requestBody.system = systemPrompt;
  let responseData;
  try {
    const response = await (0, import_obsidian35.requestUrl)({
      url: apiUrl,
      method: "POST",
      headers: {
        "anthropic-version": apiVersion,
        "x-api-key": apiKey,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody),
      throw: false
    });
    responseData = response.json;
    if (response.status >= 400) {
      const err = responseData;
      const msg = (_c = (_b = (_a = err == null ? void 0 : err.error) == null ? void 0 : _a.message) != null ? _b : response.text) != null ? _c : `Anthropic error (${response.status})`;
      return { success: false, content: null, responseData, error: msg };
    }
    const success = responseData;
    const content = (_f = (_e = (_d = success == null ? void 0 : success.content) == null ? void 0 : _d[0]) == null ? void 0 : _e.text) == null ? void 0 : _f.trim();
    if (content) return { success: true, content, responseData };
    return { success: false, content: null, responseData, error: "Invalid response structure from Anthropic." };
  } catch (e) {
    const msg = e instanceof Error ? e.message : String(e);
    responseData = { type: "error", error: { type: "network_or_execution_error", message: msg } };
    return { success: false, content: null, responseData, error: msg };
  }
}
async function fetchAnthropicModels(apiKey) {
  if (!apiKey) throw new Error("Anthropic API key is required to fetch models.");
  const response = await (0, import_obsidian35.requestUrl)({
    url: "https://api.anthropic.com/v1/models",
    method: "GET",
    headers: {
      "anthropic-version": "2023-06-01",
      "x-api-key": apiKey
    },
    throw: false
  });
  const data = response.json;
  if (response.status >= 400 || !Array.isArray(data == null ? void 0 : data.models)) {
    throw new Error(`Error fetching Anthropic models (${response.status})`);
  }
  return data.models.sort((a, b) => a.id.localeCompare(b.id));
}
var import_obsidian35;
var init_anthropicApi = __esm({
  "src/api/anthropicApi.ts"() {
    import_obsidian35 = require("obsidian");
  }
});

// src/api/openaiApi.ts
async function callOpenAiApi(apiKey, modelId, systemPrompt, userPrompt, maxTokens = 4e3, baseUrl, responseFormat, temperature, allowFormatFallback = true) {
  var _a, _b, _c, _d, _e, _f, _g;
  let apiUrl = "https://api.openai.com/v1/chat/completions";
  if (baseUrl) {
    const base = baseUrl.replace(/\/$/, "");
    if (base.endsWith("/chat/completions")) {
      apiUrl = base;
    } else {
      apiUrl = `${base}/chat/completions`;
    }
  }
  if (!apiKey && !baseUrl) {
    return { success: false, content: null, responseData: { error: { message: "API key not configured.", type: "plugin_error" } }, error: "OpenAI API key not configured." };
  }
  if (!modelId) {
    return { success: false, content: null, responseData: { error: { message: "Model ID not configured.", type: "plugin_error" } }, error: "OpenAI Model ID not configured." };
  }
  const fullPrompt = systemPrompt ? `${systemPrompt}

${userPrompt}` : userPrompt;
  const messages = [{ role: "user", content: fullPrompt }];
  const requestBody = { model: modelId, messages };
  if (maxTokens !== null) {
    requestBody.max_completion_tokens = maxTokens;
  }
  if (responseFormat) {
    requestBody.response_format = responseFormat;
  }
  if (typeof temperature === "number") {
    requestBody.temperature = temperature;
  }
  let responseData;
  try {
    const response = await (0, import_obsidian36.requestUrl)({
      url: apiUrl,
      method: "POST",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody),
      throw: false
    });
    responseData = response.json;
    if (response.status >= 400) {
      const errorDetails = responseData;
      const msg = (_c = (_b = (_a = errorDetails == null ? void 0 : errorDetails.error) == null ? void 0 : _a.message) != null ? _b : response.text) != null ? _c : `OpenAI error (${response.status})`;
      if (responseFormat && allowFormatFallback && /(response_format|json)/i.test(msg)) {
        console.warn("[OpenAI API] JSON mode not supported by server/model, retrying without enforcement.");
        return callOpenAiApi(apiKey, modelId, systemPrompt, userPrompt, maxTokens, baseUrl, void 0, temperature, false);
      }
      return { success: false, content: null, responseData, error: msg };
    }
    const success = responseData;
    const content = (_g = (_f = (_e = (_d = success == null ? void 0 : success.choices) == null ? void 0 : _d[0]) == null ? void 0 : _e.message) == null ? void 0 : _f.content) == null ? void 0 : _g.trim();
    if (content) return { success: true, content, responseData };
    return { success: false, content: null, responseData, error: "Invalid response structure from OpenAI." };
  } catch (err) {
    const msg = err instanceof Error ? err.message : String(err);
    responseData = { error: { message: msg, type: "network_or_execution_error" } };
    return { success: false, content: null, responseData, error: msg };
  }
}
async function fetchOpenAiModels(apiKey) {
  if (!apiKey) throw new Error("OpenAI API key is required to fetch models.");
  const response = await (0, import_obsidian36.requestUrl)({
    url: "https://api.openai.com/v1/models",
    method: "GET",
    headers: { Authorization: `Bearer ${apiKey}` },
    throw: false
  });
  const data = response.json;
  if (response.status >= 400 || !Array.isArray(data == null ? void 0 : data.data)) {
    throw new Error(`Error fetching models (${response.status})`);
  }
  return data.data.sort((a, b) => a.id.localeCompare(b.id));
}
var import_obsidian36;
var init_openaiApi = __esm({
  "src/api/openaiApi.ts"() {
    import_obsidian36 = require("obsidian");
  }
});

// src/modals/SceneAnalysisProcessingModal.ts
var import_obsidian56, ConfirmationModal, SceneAnalysisProcessingModal;
var init_SceneAnalysisProcessingModal = __esm({
  "src/modals/SceneAnalysisProcessingModal.ts"() {
    import_obsidian56 = require("obsidian");
    init_aiDefaults();
    init_aiOutput();
    init_modelResolver();
    ConfirmationModal = class extends import_obsidian56.Modal {
      constructor(app, message, onConfirm) {
        super(app);
        this.message = message;
        this.onConfirm = onConfirm;
      }
      onOpen() {
        const { contentEl, titleEl, modalEl } = this;
        titleEl.setText("");
        if (modalEl) {
          modalEl.classList.add("rt-modal-shell");
          modalEl.style.width = "520px";
          modalEl.style.maxWidth = "92vw";
        }
        contentEl.addClass("rt-modal-container");
        const header = contentEl.createDiv({ cls: "rt-modal-header" });
        header.createSpan({ cls: "rt-modal-badge", text: "Confirm" });
        header.createDiv({ cls: "rt-modal-title", text: "Confirm action" });
        const card = contentEl.createDiv({ cls: "rt-glass-card" });
        const messageEl = card.createDiv({ cls: "rt-confirmation-message" });
        messageEl.setText(this.message);
        const buttonRow = contentEl.createDiv({ cls: "rt-modal-actions" });
        new import_obsidian56.ButtonComponent(buttonRow).setButtonText("Continue").setCta().onClick(() => {
          this.close();
          this.onConfirm();
        });
        new import_obsidian56.ButtonComponent(buttonRow).setButtonText("Cancel").onClick(() => this.close());
      }
    };
    SceneAnalysisProcessingModal = class extends import_obsidian56.Modal {
      constructor(app, plugin, getSceneCount, onConfirm, resumeCommandId, subplotName, isEntireSubplot) {
        super(app);
        // Track if this is "entire subplot" vs "flagged scenes"
        this.selectedMode = "flagged";
        this.isProcessing = false;
        this.abortController = null;
        this.queueItems = [];
        this.queueData = [];
        this.queueStatus = /* @__PURE__ */ new Map();
        // Statistics
        this.processedCount = 0;
        this.totalCount = 0;
        this.errorCount = 0;
        this.warningCount = 0;
        this.pendingRafId = null;
        this.errorMessages = [];
        this.warningMessages = [];
        this.logAttempts = 0;
        this.plugin = plugin;
        this.getSceneCount = getSceneCount;
        this.onConfirm = onConfirm;
        this.resumeCommandId = resumeCommandId;
        this.subplotName = subplotName;
        this.isEntireSubplot = isEntireSubplot;
      }
      onOpen() {
        const { contentEl, titleEl, modalEl } = this;
        if (modalEl) {
          modalEl.classList.add("rt-modal-shell");
          modalEl.style.width = "720px";
          modalEl.style.maxWidth = "92vw";
          modalEl.style.maxHeight = "92vh";
        }
        contentEl.addClass("rt-modal-container");
        contentEl.addClass("rt-scene-analysis-modal");
        titleEl.setText("");
        if (this.isProcessing) {
          this.showProgressView();
        } else {
          this.showConfirmationView();
        }
      }
      onClose() {
        if (this.pendingRafId !== null) {
          cancelAnimationFrame(this.pendingRafId);
          this.pendingRafId = null;
        }
      }
      /**
       * Override close() to allow minimizing while processing continues
       */
      close() {
        if (this.isProcessing) {
          new import_obsidian56.Notice("Processing continues in background. Use command palette to reopen progress window.");
        }
        super.close();
      }
      ensureModalShell() {
        if (this.modalEl && !this.modalEl.classList.contains("rt-modal-shell")) {
          this.modalEl.classList.add("rt-modal-shell");
        }
        this.contentEl.classList.add("rt-modal-container");
        this.contentEl.classList.add("rt-scene-analysis-modal");
      }
      getProcessingTitle() {
        if (this.subplotName) {
          return this.isEntireSubplot ? `Processing entire subplot: ${this.subplotName}` : `Processing subplot: ${this.subplotName}`;
        }
        return "Scene pulse analysis";
      }
      getModeLabel(mode) {
        if (mode === "unprocessed") {
          return "Scenes missing pulse metadata";
        }
        if (mode === "force-all") {
          return "Reprocessing every completed scene";
        }
        return "Analyze flagged scenes in manuscript order";
      }
      getProcessingSubtitle() {
        if (this.subplotName) {
          return this.isEntireSubplot ? `Analyzing every scene in subplot "${this.subplotName}"` : `Analyzing flagged scenes in subplot "${this.subplotName}"`;
        }
        return this.getModeLabel(this.selectedMode);
      }
      renderProcessingHero(parent, options) {
        var _a, _b;
        const hero = parent.createDiv({ cls: "rt-modal-header" });
        const modelLabel = this.getActiveModelDisplayName();
        const badgeText = modelLabel ? `AI pulse run \xB7 ${modelLabel}` : "AI pulse run";
        hero.createSpan({ text: badgeText, cls: "rt-scene-analysis-badge" });
        hero.createDiv({ text: this.getProcessingTitle(), cls: "rt-modal-title" });
        const subtitleText = (_a = options == null ? void 0 : options.subtitle) != null ? _a : this.getProcessingSubtitle();
        const subtitleEl = hero.createDiv({ cls: "rt-modal-subtitle" });
        subtitleEl.setText(subtitleText);
        if (options == null ? void 0 : options.trackStatus) {
          this.heroStatusEl = subtitleEl;
        } else {
          this.heroStatusEl = void 0;
        }
        const metaItems = (_b = options == null ? void 0 : options.metaItems) != null ? _b : [];
        if (metaItems.length > 0) {
          const metaEl = hero.createDiv({ cls: "rt-scene-analysis-meta" });
          for (const item of metaItems) {
            metaEl.createSpan({ text: item, cls: "rt-scene-analysis-meta-item" });
          }
        }
        return hero;
      }
      setProcessingQueue(queue) {
        this.queueData = queue.slice();
        this.queueStatus.clear();
        this.totalCount = queue.length;
        if (this.isProcessing && this.progressTextEl && queue.length > 0 && this.processedCount === 0) {
          this.progressTextEl.setText(`0 / ${queue.length} scenes (0%)`);
        }
        this.renderQueueItems();
      }
      renderQueueItems() {
        var _a, _b;
        if (!this.queueTrackEl) return;
        this.queueTrackEl.empty();
        this.queueItems = [];
        if (this.queueData.length === 0) {
          this.queueTrackEl.createSpan({ cls: "rt-pulse-ruler-empty", text: "Queue builds once eligible scenes are found..." });
          return;
        }
        for (const item of this.queueData) {
          const entry = this.queueTrackEl.createDiv({ cls: "rt-pulse-ruler-item" });
          entry.setAttr("data-queue-id", item.id);
          const primaryLabel = ((_a = item.label) == null ? void 0 : _a.trim()) || "\u2014";
          entry.createSpan({ cls: "rt-pulse-ruler-value", text: primaryLabel });
          const secondary = (_b = item.detail) == null ? void 0 : _b.trim();
          if (secondary && secondary !== primaryLabel) {
            entry.createSpan({ cls: "rt-pulse-ruler-label", text: secondary });
          }
          const state = this.queueStatus.get(item.id);
          if (state) {
            this.applyQueueStatus(entry, state);
          }
          this.queueItems.push(entry);
        }
        this.updateQueueHighlight();
      }
      updateQueueHighlight(activeId) {
        if (activeId) {
          this.queueActiveId = activeId;
        }
        if (!this.queueTrackEl || !this.queueScrollEl) return;
        const activeIndex = this.queueActiveId ? this.queueData.findIndex((item) => item.id === this.queueActiveId) : -1;
        this.queueItems.forEach((itemEl, index) => {
          itemEl.toggleClass("rt-is-active", index === activeIndex);
          itemEl.toggleClass("rt-is-complete", activeIndex !== -1 && index < activeIndex);
        });
        if (activeIndex >= 0) {
          const activeEl = this.queueItems[activeIndex];
          const container = this.queueScrollEl;
          if (activeEl && container) {
            const target = Math.max(0, activeEl.offsetLeft - (container.clientWidth / 2 - activeEl.clientWidth / 2));
            container.scrollTo({ left: target, behavior: "smooth" });
          }
        }
      }
      markQueueStatus(queueId, status) {
        if (!queueId) return;
        this.queueStatus.set(queueId, status);
        const entry = this.queueItems.find((item) => item.getAttribute("data-queue-id") === queueId);
        if (entry) {
          this.applyQueueStatus(entry, status);
        }
      }
      applyQueueStatus(entry, status) {
        entry.removeClass("rt-status-success", "rt-status-error");
        entry.addClass(status === "success" ? "rt-status-success" : "rt-status-error");
      }
      setTripletNote(prevNum, currentNum, nextNum) {
        if (!this.queueNoteEl) return;
        this.queueNoteEl.empty();
        const boundaryLabel = this.subplotName ? "subplot" : "manuscript";
        const chips = [
          { label: "Previous", value: prevNum, fallback: `Start of ${boundaryLabel}` },
          { label: "Current", value: currentNum, fallback: "Unnumbered scene" },
          { label: "Next", value: nextNum, fallback: `End of ${boundaryLabel}` }
        ];
        for (const chip of chips) {
          const chipEl = this.queueNoteEl.createSpan({ cls: "rt-pulse-ruler-chip" });
          chipEl.createSpan({ cls: "rt-pulse-ruler-chip-label", text: chip.label });
          chipEl.createSpan({ cls: "rt-pulse-ruler-chip-value", text: this.formatTripletValue(chip.value, chip.fallback) });
        }
      }
      formatTripletValue(value, fallback) {
        const normalized = value == null ? void 0 : value.trim();
        if (!normalized || normalized === "N/A") {
          return fallback;
        }
        return normalized.startsWith("#") ? normalized : `#${normalized}`;
      }
      findQueueIdForScene(value) {
        if (!value) return void 0;
        const cleaned = value.replace(/^#/, "").trim();
        const found = this.queueData.find((item) => item.label.replace(/^#/, "").trim() === cleaned);
        return found == null ? void 0 : found.id;
      }
      showConfirmationView() {
        const { contentEl, modalEl, titleEl } = this;
        contentEl.empty();
        this.ensureModalShell();
        titleEl.setText("");
        if (modalEl) {
          modalEl.style.width = "720px";
          modalEl.style.maxWidth = "92vw";
        }
        this.renderProcessingHero(contentEl);
        const modesSection = contentEl.createDiv({ cls: "rt-pulse-modes rt-glass-card" });
        const mode1 = this.createModeOption(
          modesSection,
          "flagged",
          "Process flagged scenes (Recommended)",
          "Processes scenes with Pulse Update: Yes and Status: Working or Complete. Use when you've revised scenes and want to update their pulse.",
          true
        );
        const mode2 = this.createModeOption(
          modesSection,
          "unprocessed",
          "Process unprocessed scenes",
          "Processes scenes with Status: Complete or Working that don't have pulse yet. Perfect for resuming after interruptions. Ignores Pulse Update flag.",
          false
        );
        const mode3 = this.createModeOption(
          modesSection,
          "force-all",
          "Reprocess ALL scenes",
          "Reprocesses ALL scenes with Status: Complete or Working, even if they already have pulse. Use when changing AI templates or doing complete reanalysis. WARNING: May be expensive!",
          false
        );
        const countSection = contentEl.createDiv({ cls: "rt-pulse-count rt-glass-card" });
        const countEl = countSection.createDiv({ cls: "rt-pulse-count-number" });
        countEl.setText("Calculating...");
        const updateCount = async () => {
          countEl.empty();
          countEl.setText("Calculating...");
          try {
            const count = await this.getSceneCount(this.selectedMode);
            const estimatedMinutes = Math.ceil(count * 0.1);
            countEl.empty();
            const countText = countEl.createDiv({ cls: "rt-pulse-count-text" });
            countText.createSpan({ text: "Scenes to process: ", cls: "rt-pulse-label" });
            countText.createSpan({ text: `${count}`, cls: "rt-pulse-number" });
            const timeText = countEl.createDiv({ cls: "rt-pulse-time-text" });
            timeText.createSpan({ text: "Estimated time: ", cls: "rt-pulse-label" });
            timeText.createSpan({ text: `~${estimatedMinutes} minutes`, cls: "rt-pulse-number" });
            if (count > 50) {
              const warning = countEl.createDiv({ cls: "rt-pulse-warning" });
              warning.setText("Large batch processing may take significant time and API costs.");
            }
          } catch (error) {
            countEl.empty();
            countEl.setText(`Error calculating scene count: ${error instanceof Error ? error.message : String(error)}`);
          }
        };
        const rafId = requestAnimationFrame(() => {
          updateCount();
        });
        this.pendingRafId = rafId;
        [mode1, mode2, mode3].forEach((radio) => {
          radio.addEventListener("change", () => updateCount());
        });
        const buttonRow = contentEl.createDiv({ cls: "rt-modal-actions" });
        new import_obsidian56.ButtonComponent(buttonRow).setButtonText("Start processing").setCta().onClick(async () => {
          try {
            const count = await this.getSceneCount(this.selectedMode);
            if (count === 0) {
              new import_obsidian56.Notice("No scenes to process with the selected mode.");
              return;
            }
            if (count > 50 || this.selectedMode === "force-all" || this.selectedMode === "unprocessed") {
              const confirmModal = new ConfirmationModal(
                this.app,
                `You are about to process ${count} scenes. This may take ${Math.ceil(count * 0.1)} minutes and incur API costs. Continue?`,
                async () => {
                  await this.startProcessing();
                }
              );
              confirmModal.open();
              return;
            }
            await this.startProcessing();
          } catch (error) {
            new import_obsidian56.Notice(`Error: ${error instanceof Error ? error.message : String(error)}`);
          }
        });
        new import_obsidian56.ButtonComponent(buttonRow).setButtonText("Purge all pulse").setWarning().onClick(async () => {
          try {
            const { purgeBeatsByManuscriptOrder: purgeBeatsByManuscriptOrder2 } = await Promise.resolve().then(() => (init_SceneAnalysisCommands(), SceneAnalysisCommands_exports));
            this.close();
            await purgeBeatsByManuscriptOrder2(this.plugin, this.plugin.app.vault);
          } catch (error) {
            new import_obsidian56.Notice(`Error: ${error instanceof Error ? error.message : String(error)}`);
          }
        });
        new import_obsidian56.ButtonComponent(buttonRow).setButtonText("Cancel").onClick(() => this.close());
      }
      createModeOption(container, mode, title, description, isDefault) {
        const optionEl = container.createDiv({ cls: "rt-pulse-mode-option" });
        const radioEl = optionEl.createEl("input", {
          type: "radio",
          attr: { name: "processing-mode", value: mode }
        });
        radioEl.checked = isDefault;
        if (isDefault) this.selectedMode = mode;
        radioEl.addEventListener("change", () => {
          if (radioEl.checked) {
            this.selectedMode = mode;
          }
        });
        const labelContainer = optionEl.createDiv({ cls: "rt-pulse-mode-label" });
        const titleEl = labelContainer.createDiv({ cls: "rt-pulse-mode-title" });
        titleEl.setText(title);
        const descEl = labelContainer.createDiv({ cls: "rt-pulse-mode-desc" });
        descEl.setText(description);
        optionEl.addEventListener("click", () => {
          radioEl.checked = true;
          this.selectedMode = mode;
          radioEl.dispatchEvent(new Event("change"));
        });
        return radioEl;
      }
      async startProcessing() {
        this.isProcessing = true;
        this.abortController = new AbortController();
        this.processedCount = 0;
        this.errorCount = 0;
        this.warningCount = 0;
        this.errorMessages = [];
        this.warningMessages = [];
        this.logAttempts = 0;
        this.plugin.activeBeatsModal = this;
        this.plugin.showBeatsStatusBar(0, 0);
        this.showProgressView();
        try {
          await this.onConfirm(this.selectedMode);
          if (this.abortController && this.abortController.signal.aborted) {
            this.showCompletionSummary("Processing aborted");
          } else {
            this.showCompletionSummary("Processing completed successfully!");
          }
        } catch (error) {
          if (!this.abortController.signal.aborted) {
            this.addError(`Fatal error: ${error instanceof Error ? error.message : String(error)}`);
            this.showCompletionSummary("Processing stopped due to error");
          } else {
            this.showCompletionSummary("Processing aborted");
          }
        } finally {
          this.isProcessing = false;
          this.abortController = null;
          this.plugin.activeBeatsModal = null;
          this.plugin.hideBeatsStatusBar();
        }
      }
      showProgressView() {
        const { contentEl, titleEl } = this;
        contentEl.empty();
        this.ensureModalShell();
        titleEl.setText("");
        this.renderProcessingHero(contentEl, {
          trackStatus: true,
          metaItems: [
            `Model: ${this.getActiveModelDisplayName()}`,
            this.subplotName ? this.isEntireSubplot ? "Entire subplot batch" : "Flagged subplot scenes" : this.getModeLabel(this.selectedMode)
          ]
        });
        const bodyEl = contentEl.createDiv({ cls: "rt-pulse-progress-body" });
        const progressCard = bodyEl.createDiv({ cls: "rt-pulse-progress-card rt-glass-card" });
        const progressContainer = progressCard.createDiv({ cls: "rt-pulse-progress-container" });
        const progressBg = progressContainer.createDiv({ cls: "rt-pulse-progress-bg" });
        this.progressBarEl = progressBg.createDiv({ cls: "rt-pulse-progress-bar" });
        this.progressBarEl.style.setProperty("--progress-width", "25%");
        this.progressTextEl = progressCard.createDiv({ cls: "rt-pulse-progress-text" });
        this.progressTextEl.setText("Initializing\u2026 preparing first scene (0%)");
        this.statusTextEl = progressCard.createDiv({ cls: "rt-pulse-status-text" });
        this.statusTextEl.setText("Initializing pipeline...");
        const rulerBlock = progressCard.createDiv({ cls: "rt-pulse-ruler-block" });
        rulerBlock.createDiv({ cls: "rt-pulse-ruler-title", text: "Scene queue" });
        this.queueScrollEl = rulerBlock.createDiv({ cls: "rt-pulse-ruler-scroll" });
        this.queueTrackEl = this.queueScrollEl.createDiv({ cls: "rt-pulse-ruler-track" });
        this.queueItems = [];
        this.queueActiveId = void 0;
        this.renderQueueItems();
        this.queueNoteEl = rulerBlock.createDiv({ cls: "rt-pulse-ruler-note" });
        this.queueNoteEl.setText("Triplets animate as the AI advances - starts, endings, and missing scenes handled automatically.");
        this.errorListEl = bodyEl.createDiv({ cls: "rt-pulse-error-list rt-glass-card rt-hidden" });
        this.actionButtonContainer = contentEl.createDiv({ cls: "rt-modal-actions" });
        this.abortButtonEl = new import_obsidian56.ButtonComponent(this.actionButtonContainer).setButtonText("Abort processing").setWarning().onClick(() => this.abortProcessing());
      }
      abortProcessing() {
        if (!this.abortController) return;
        const confirmModal = new ConfirmationModal(
          this.app,
          "Are you sure you want to abort processing? Progress will be saved up to the current scene.",
          () => {
            var _a, _b, _c;
            (_a = this.abortController) == null ? void 0 : _a.abort();
            (_b = this.statusTextEl) == null ? void 0 : _b.setText("Aborting... Please wait.");
            (_c = this.abortButtonEl) == null ? void 0 : _c.setDisabled(true);
            new import_obsidian56.Notice("Processing aborted by user");
          }
        );
        confirmModal.open();
      }
      updateProgress(current, total, sceneName) {
        if (!this.isProcessing) return;
        this.processedCount = current;
        this.totalCount = total;
        const percentage = total > 0 ? Math.round(current / total * 100) : 0;
        this.plugin.showBeatsStatusBar(current, total);
        if (this.progressBarEl) {
          this.progressBarEl.style.setProperty("--progress-width", `${percentage}%`);
        }
        if (this.progressTextEl) {
          this.progressTextEl.setText(`${current} / ${total} scenes (${percentage}%)`);
        }
        if (this.statusTextEl) {
          this.statusTextEl.setText(`Processing: ${sceneName}`);
        }
        if (this.heroStatusEl) {
          this.heroStatusEl.setText(`Processing ${sceneName}`);
        }
      }
      addError(message) {
        if (!this.errorListEl) return;
        this.errorCount++;
        const normalizedMessage = (message == null ? void 0 : message.trim()) || "Unknown error";
        const hint = this.deriveErrorHint(normalizedMessage);
        this.errorMessages.push({ message: normalizedMessage, hint: hint != null ? hint : void 0 });
        if (this.errorListEl.hasClass("rt-hidden")) {
          this.errorListEl.removeClass("rt-hidden");
          const header = this.errorListEl.createDiv({ cls: "rt-pulse-error-header" });
          header.setText("Errors encountered:");
        }
        const errorItem = this.errorListEl.createDiv({ cls: "rt-pulse-error-item" });
        errorItem.setText(normalizedMessage);
        if (hint) {
          errorItem.createDiv({ cls: "rt-pulse-error-hint", text: hint });
        }
      }
      setTripletInfo(prevNum, currentNum, nextNum, queueId, sceneLabel) {
        this.setTripletNote(prevNum, currentNum, nextNum);
        if (this.queueData.length > 0) {
          const targetId = queueId != null ? queueId : this.findQueueIdForScene(currentNum);
          this.updateQueueHighlight(targetId);
        }
        if (sceneLabel) {
          if (this.heroStatusEl) {
            this.heroStatusEl.setText(`Processing ${sceneLabel}`);
          }
          if (this.statusTextEl) {
            this.statusTextEl.setText(`Processing: ${sceneLabel}`);
          }
        }
      }
      addWarning(message) {
        if (!this.errorListEl) return;
        this.warningCount++;
        const normalizedMessage = (message == null ? void 0 : message.trim()) || "Warning encountered";
        this.warningMessages.push(normalizedMessage);
        if (this.errorListEl.hasClass("rt-hidden")) {
          this.errorListEl.removeClass("rt-hidden");
          const header = this.errorListEl.createDiv({ cls: "rt-pulse-error-header" });
          header.setText("Issues encountered:");
        }
        const warningItem = this.errorListEl.createDiv({ cls: "rt-pulse-error-item rt-pulse-warning-item" });
        warningItem.setText(message);
      }
      showCompletionSummary(statusMessage) {
        var _a;
        const { contentEl, titleEl } = this;
        titleEl.setText("");
        if (this.progressBarEl) {
          this.progressBarEl.style.setProperty("--progress-width", "100%");
          this.progressBarEl.removeClass("rt-progress-complete", "rt-progress-error");
          if (this.errorCount > 0) {
            this.progressBarEl.addClass("rt-progress-error");
          } else {
            this.progressBarEl.addClass("rt-progress-complete");
          }
        }
        const successCount = Math.max(0, this.processedCount);
        const hasErrors = this.errorCount > 0;
        const hasWarnings = this.warningCount > 0;
        const hasIssues = hasErrors || hasWarnings;
        const remainingScenes = Math.max(0, this.totalCount - this.processedCount);
        const progressSummary = this.totalCount > 0 ? `${successCount} / ${this.totalCount} scenes updated` : `${successCount} scene${successCount === 1 ? "" : "s"} updated`;
        if (this.progressTextEl) {
          this.progressTextEl.setText(progressSummary);
        }
        const statusParts = [];
        if (hasErrors) statusParts.push(`${this.errorCount} failed`);
        if (hasWarnings) statusParts.push(`${this.warningCount} skipped`);
        if (this.statusTextEl) {
          const statusText = statusParts.join(" | ");
          this.statusTextEl.setText(statusText);
          this.statusTextEl.removeClass("rt-error-text", "rt-warning-text", "rt-success-text");
          if (statusText) {
            if (hasErrors && successCount === 0) {
              this.statusTextEl.addClass("rt-error-text");
            } else {
              this.statusTextEl.addClass("rt-warning-text");
            }
          }
        }
        if (this.heroStatusEl) {
          this.heroStatusEl.setText(statusMessage);
        }
        if (this.errorListEl) {
          this.errorListEl.addClass("rt-hidden");
          this.errorListEl.empty();
        }
        contentEl.querySelectorAll(".rt-pulse-summary").forEach((el) => el.remove());
        if (hasIssues) {
          const summaryContainer = contentEl.createDiv({ cls: "rt-pulse-summary rt-glass-card" });
          summaryContainer.createEl("h3", { text: "Processing details", cls: "rt-pulse-summary-title" });
          const summaryStats = summaryContainer.createDiv({ cls: "rt-pulse-summary-stats" });
          if (hasErrors) {
            summaryStats.createDiv({
              cls: "rt-pulse-summary-row rt-pulse-summary-error",
              text: `Errors: ${this.errorCount}`
            });
          }
          if (hasWarnings) {
            summaryStats.createDiv({
              cls: "rt-pulse-summary-row rt-pulse-summary-warning",
              text: `Warnings: ${this.warningCount} (skipped due to validation)`
            });
          }
          if (hasErrors && this.errorMessages.length > 0) {
            const errorDetails = summaryContainer.createDiv({ cls: "rt-pulse-summary-list" });
            this.errorMessages.forEach(({ message, hint }) => {
              const item = errorDetails.createDiv({ cls: "rt-pulse-summary-item rt-pulse-summary-item-error" });
              item.createSpan({ text: message });
              if (hint) {
                item.createDiv({ cls: "rt-pulse-summary-hint", text: `Possible fix: ${hint}` });
              }
            });
          }
          if (hasWarnings && this.warningMessages.length > 0) {
            const warningDetails = summaryContainer.createDiv({ cls: "rt-pulse-summary-list" });
            this.warningMessages.forEach((warning) => {
              const item = warningDetails.createDiv({ cls: "rt-pulse-summary-item rt-pulse-summary-item-warning" });
              item.createSpan({ text: warning });
            });
          }
        }
        contentEl.querySelectorAll(".rt-pulse-summary-tip").forEach((el) => el.remove());
        if (this.plugin.settings.logApiInteractions) {
          const logNoteEl = contentEl.createDiv({ cls: "rt-pulse-summary-tip" });
          logNoteEl.createEl("strong", { text: "Logs: " });
          const isLocal = (this.plugin.settings.defaultAiProvider || "openai") === "local";
          const pulsesBypassed = isLocal && ((_a = this.plugin.settings.localSendPulseToAiReport) != null ? _a : true);
          const pulseRouting = pulsesBypassed ? "Triplet pulse updates bypassed scene yaml and were saved to the AI report." : "Triplet pulse updates were written to scene yaml.";
          if (this.logAttempts > 0) {
            const aiFolder = resolveAiOutputFolder(this.plugin);
            logNoteEl.appendText(`Detailed AI interaction logs were saved to ${aiFolder}. ${pulseRouting}`);
          } else {
            logNoteEl.appendText(`Logging is enabled, but no AI request reached the server. ${pulseRouting}`);
          }
        }
        if (this.actionButtonContainer) {
          this.actionButtonContainer.empty();
          if (remainingScenes > 0 && (this.resumeCommandId || this.subplotName)) {
            new import_obsidian56.ButtonComponent(this.actionButtonContainer).setButtonText(`Resume (${remainingScenes} remaining)`).setCta().onClick(async () => {
              this.close();
              if (this.subplotName) {
                const subplotName = this.subplotName;
                const isEntireSubplot = this.isEntireSubplot;
                window.setTimeout(async () => {
                  const { processBySubplotNameWithModal: processBySubplotNameWithModal2, processEntireSubplotWithModal: processEntireSubplotWithModal2 } = await Promise.resolve().then(() => (init_SceneAnalysisCommands(), SceneAnalysisCommands_exports));
                  if (isEntireSubplot) {
                    await processEntireSubplotWithModal2(this.plugin, this.plugin.app.vault, subplotName, true);
                  } else {
                    await processBySubplotNameWithModal2(this.plugin, this.plugin.app.vault, subplotName);
                  }
                }, 100);
              } else if (this.resumeCommandId) {
                this.plugin.settings._isResuming = true;
                await this.plugin.saveSettings();
                window.setTimeout(() => {
                  this.app.commands.executeCommandById(this.resumeCommandId);
                }, 100);
              }
            });
          }
          new import_obsidian56.ButtonComponent(this.actionButtonContainer).setButtonText("Close").onClick(() => this.close());
        }
      }
      isAborted() {
        var _a, _b;
        return (_b = (_a = this.abortController) == null ? void 0 : _a.signal.aborted) != null ? _b : false;
      }
      getAbortSignal() {
        var _a, _b;
        return (_b = (_a = this.abortController) == null ? void 0 : _a.signal) != null ? _b : null;
      }
      noteLogAttempt() {
        this.logAttempts++;
      }
      /**
       * Programmatically abort processing (e.g., due to rate limiting)
       * Unlike abortProcessing(), this doesn't show a confirmation dialog
       */
      abort() {
        var _a, _b;
        if (!this.abortController) return;
        this.abortController.abort();
        (_a = this.statusTextEl) == null ? void 0 : _a.setText("Processing stopped due to error");
        (_b = this.abortButtonEl) == null ? void 0 : _b.setDisabled(true);
      }
      getActiveModelDisplayName() {
        const provider = this.plugin.settings.defaultAiProvider || "openai";
        let modelId;
        if (provider === "anthropic") {
          modelId = this.plugin.settings.anthropicModelId || "claude-sonnet-4-5-20250929";
        } else if (provider === "gemini") {
          modelId = this.plugin.settings.geminiModelId || DEFAULT_GEMINI_MODEL_ID;
        } else if (provider === "local") {
          modelId = this.plugin.settings.localModelId || "local-model";
        } else {
          modelId = this.plugin.settings.openaiModelId || "gpt-4o";
        }
        return getModelDisplayName(modelId);
      }
      deriveErrorHint(message) {
        const normalized = message.toLowerCase();
        if (normalized.includes("temperature") && normalized.includes("default (1)")) {
          return "This model only accepts its default temperature. Remove the custom temperature override in Settings \u2192 AI Providers.";
        }
        if (normalized.includes("model") && normalized.includes("not found")) {
          return "Verify that the model is downloaded locally (use `ollama list`) and update the Local Model ID in settings to match exactly.";
        }
        if (normalized.includes("ollama server not responding") || normalized.includes("could not find ollama")) {
          return "Launch Ollama (`ollama serve`) and confirm the Local Base URL points to the running server.";
        }
        if (normalized.includes("connection refused") || normalized.includes("timed out")) {
          return "The plugin could not contact the local server. Check that it is running and that Obsidian has network permission.";
        }
        if (normalized.includes("schema") && normalized.includes("json")) {
          return "The response was not valid JSON. Try switching to a larger or more instruction-following model.";
        }
        return null;
      }
    };
  }
});

// src/sceneAnalysis/data.ts
function extractSceneNumber(filename) {
  const match = filename.match(/^(\d+(\.\d+)?)/);
  return match ? parseFloat(match[1]) : null;
}
function compareScenesByOrder(a, b) {
  const parse = (name) => {
    const m = name.match(/^(\d+)(?:\.(\d+))?/);
    if (!m) return { major: Number.POSITIVE_INFINITY, minor: Number.POSITIVE_INFINITY };
    const major = parseInt(m[1], 10);
    const minor = typeof m[2] !== "undefined" ? parseInt(m[2], 10) : -1;
    return { major, minor };
  };
  const A = parse(a.file.name);
  const B = parse(b.file.name);
  if (A.major !== B.major) return A.major - B.major;
  return A.minor - B.minor;
}
function getSubplotNamesFromFM(fm) {
  var _a;
  const value = (_a = fm == null ? void 0 : fm.Subplot) != null ? _a : fm == null ? void 0 : fm.subplot;
  if (typeof value === "string" && value.trim()) {
    return [value.trim()];
  }
  if (Array.isArray(value)) {
    return value.map((v) => String(v).trim()).filter(Boolean);
  }
  return [];
}
function getPulseUpdateFlag(fm) {
  if (!fm) return void 0;
  const keys = [
    "Pulse Update",
    "PulseUpdate",
    "pulseupdate",
    "Beats Update",
    "BeatsUpdate",
    "beatsupdate",
    "Review Update",
    "ReviewUpdate",
    "reviewupdate"
  ];
  for (const key of keys) {
    if (Object.prototype.hasOwnProperty.call(fm, key)) {
      return fm[key];
    }
  }
  return void 0;
}
function hasWordsContent(fm) {
  const w1 = fm == null ? void 0 : fm.words;
  const w2 = fm["Words"];
  const parseWords = (val) => {
    if (typeof val === "number") return val;
    if (typeof val === "string") {
      const cleaned = val.replace(/,/g, "");
      const parsed = parseFloat(cleaned);
      return isNaN(parsed) ? void 0 : parsed;
    }
    return void 0;
  };
  const n1 = parseWords(w1);
  const n2 = parseWords(w2);
  const n = typeof n1 === "number" ? n1 : typeof n2 === "number" ? n2 : void 0;
  return typeof n === "number" && n > 0;
}
function hasProcessableContent(fm) {
  if (!fm) return false;
  const status = fm.Status || fm.status;
  const statusArray = Array.isArray(status) ? status : [status];
  const normalizedStatus = statusArray.map((value) => typeof value === "string" ? value.toLowerCase() : "").filter(Boolean);
  if (normalizedStatus.some((s) => s === "working" || s === "complete")) return true;
  if (hasWordsContent(fm)) return true;
  return false;
}
function wasProcessedToday(frontmatter) {
  var _a;
  if (!frontmatter) return false;
  const pulseLastUpdated = (_a = frontmatter["Pulse Last Updated"]) != null ? _a : frontmatter["Beats Last Updated"];
  if (!pulseLastUpdated || typeof pulseLastUpdated !== "string") return false;
  const match = pulseLastUpdated.match(/^(.+?)\s+by\s+/);
  if (!match) return false;
  try {
    const timestampDate = new Date(match[1]);
    if (isNaN(timestampDate.getTime())) return false;
    const today = /* @__PURE__ */ new Date();
    return timestampDate.toDateString() === today.toDateString();
  } catch (e) {
    return false;
  }
}
function hasBeenProcessedForBeats(frontmatter, options = {}) {
  var _a;
  if (!frontmatter) return false;
  const hasTimestamp = !!((_a = frontmatter["Pulse Last Updated"]) != null ? _a : frontmatter["Beats Last Updated"]);
  const hasAnalysis = !!frontmatter["previousSceneAnalysis"] || !!frontmatter["currentSceneAnalysis"] || !!frontmatter["nextSceneAnalysis"];
  if (!hasTimestamp && !hasAnalysis) return false;
  if (options.todayOnly) {
    return hasTimestamp && wasProcessedToday(frontmatter);
  }
  return hasTimestamp || hasAnalysis;
}
async function getAllSceneData(plugin, vault) {
  const sourcePath = plugin.settings.sourcePath.trim();
  const allFiles = vault.getMarkdownFiles();
  const filesInPath = allFiles.filter((file) => {
    if (sourcePath === "") return true;
    return file.path.startsWith(sourcePath + "/") || file.path === sourcePath;
  });
  const sceneDataPromises = filesInPath.map(async (file) => {
    var _a, _b, _c;
    try {
      const content = await vault.read(file);
      const fmInfo = (0, import_obsidian57.getFrontMatterInfo)(content);
      if (!fmInfo || !fmInfo.exists) {
        return null;
      }
      let frontmatter = {};
      try {
        const fmText = (_a = fmInfo.frontmatter) != null ? _a : "";
        const rawFrontmatter = fmText ? (0, import_obsidian57.parseYaml)(fmText) || {} : {};
        const mappings = plugin.settings.enableCustomMetadataMapping ? plugin.settings.frontmatterMappings : void 0;
        frontmatter = normalizeFrontmatterKeys(rawFrontmatter, mappings);
      } catch (e) {
        return null;
      }
      const fileClass = frontmatter == null ? void 0 : frontmatter.Class;
      if (typeof fileClass !== "string" || fileClass.toLowerCase() !== "scene") {
        return null;
      }
      const sceneNumber = extractSceneNumber(file.name);
      const endOffset = (_c = (_b = fmInfo.position) == null ? void 0 : _b.end) == null ? void 0 : _c.offset;
      let body = "";
      if (typeof endOffset === "number" && endOffset >= 0) {
        body = content.slice(endOffset).trim();
      } else {
        body = content.replace(/^---[\s\S]*?\n---/, "").trim();
      }
      body = stripObsidianComments(body);
      return { file, frontmatter, sceneNumber, body };
    } catch (e) {
      return null;
    }
  });
  const results = await Promise.all(sceneDataPromises);
  return results.filter((item) => item !== null);
}
async function calculateSceneCount(plugin, vault, mode) {
  const isResuming = plugin.settings._isResuming || false;
  const allScenes = await getAllSceneData(plugin, vault);
  allScenes.sort(compareScenesByOrder);
  const processableScenes = allScenes.filter((scene) => {
    if (mode === "flagged") {
      const pulseUpdateFlag = getPulseUpdateFlag(scene.frontmatter);
      return normalizeBooleanValue(pulseUpdateFlag) && hasProcessableContent(scene.frontmatter);
    }
    return hasProcessableContent(scene.frontmatter);
  });
  if (mode === "flagged") {
    return processableScenes.length;
  }
  if (mode === "force-all") {
    if (isResuming) {
      return processableScenes.filter(
        (scene) => !hasBeenProcessedForBeats(scene.frontmatter, { todayOnly: true })
      ).length;
    }
    return processableScenes.length;
  }
  if (mode === "unprocessed") {
    if (isResuming) {
      return processableScenes.filter(
        (scene) => !hasBeenProcessedForBeats(scene.frontmatter, { todayOnly: true })
      ).length;
    }
    return processableScenes.filter(
      (scene) => !hasBeenProcessedForBeats(scene.frontmatter)
    ).length;
  }
  return 0;
}
async function calculateFlaggedCount(plugin, vault, mode) {
  const allScenes = await getAllSceneData(plugin, vault);
  allScenes.sort(compareScenesByOrder);
  const isFlagged = (scene) => normalizeBooleanValue(getPulseUpdateFlag(scene.frontmatter));
  if (mode === "flagged") {
    return allScenes.filter(isFlagged).length;
  }
  if (mode === "force-all") return allScenes.length;
  if (mode === "unprocessed") {
    return allScenes.filter((s) => hasProcessableContent(s.frontmatter) && !hasBeenProcessedForBeats(s.frontmatter)).length;
  }
  return 0;
}
async function getDistinctSubplotNames(plugin, vault) {
  const scenes = await getAllSceneData(plugin, vault);
  const subplotCounts = /* @__PURE__ */ new Map();
  scenes.forEach((scene) => {
    const subplotList = getSubplotNamesFromFM(scene.frontmatter);
    subplotList.forEach((subplot) => {
      if (subplot) {
        subplotCounts.set(subplot, (subplotCounts.get(subplot) || 0) + 1);
      }
    });
  });
  const subplotArray = Array.from(subplotCounts.entries()).map(([subplot, count]) => ({
    subplot,
    count
  }));
  subplotArray.sort((a, b) => {
    if (a.subplot === "Main Plot" || !a.subplot) return -1;
    if (b.subplot === "Main Plot" || !b.subplot) return 1;
    if (a.count !== b.count) return b.count - a.count;
    return a.subplot.localeCompare(b.subplot);
  });
  return subplotArray.map((item) => item.subplot);
}
var import_obsidian57;
var init_data = __esm({
  "src/sceneAnalysis/data.ts"() {
    import_obsidian57 = require("obsidian");
    init_frontmatter();
    init_text();
    init_sceneHelpers();
  }
});

// src/sceneAnalysis/TripletBuilder.ts
function buildTripletsByIndex(contextList, targets, keyFn) {
  const ctxIndexByKey = /* @__PURE__ */ new Map();
  contextList.forEach((item, idx) => ctxIndexByKey.set(keyFn(item), idx));
  const triplets = [];
  for (const current of targets) {
    const key = keyFn(current);
    const idx = ctxIndexByKey.get(key);
    if (typeof idx !== "number") {
      triplets.push({ prev: null, current, next: null });
      continue;
    }
    const prev = idx > 0 ? contextList[idx - 1] : null;
    const next = idx < contextList.length - 1 ? contextList[idx + 1] : null;
    triplets.push({ prev, current, next });
  }
  return triplets;
}
var init_TripletBuilder = __esm({
  "src/sceneAnalysis/TripletBuilder.ts"() {
  }
});

// src/sceneAnalysis/FileUpdater.ts
async function updateSceneAnalysis(vault, file, parsedAnalysis, plugin, modelIdUsed) {
  try {
    const toArray = (block) => block.split("\n").map((s) => s.replace(/^\s*-\s*/, "").trim()).filter(Boolean);
    await plugin.app.fileManager.processFrontMatter(file, (fm) => {
      var _a, _b, _c;
      const fmObj = fm;
      delete fmObj["previousSceneAnalysis"];
      delete fmObj["currentSceneAnalysis"];
      delete fmObj["nextSceneAnalysis"];
      const now = /* @__PURE__ */ new Date();
      const timestamp = now.toLocaleString(void 0, {
        year: "numeric",
        month: "short",
        day: "numeric",
        hour: "numeric",
        minute: "2-digit",
        hour12: true
      });
      fmObj["Pulse Last Updated"] = `${timestamp}${modelIdUsed ? ` by ${modelIdUsed}` : " by Unknown Model"}`;
      const pulseKeys = [
        "Pulse Update",
        "PulseUpdate",
        "pulseupdate",
        "Beats Update",
        "BeatsUpdate",
        "beatsupdate",
        "Review Update",
        "ReviewUpdate",
        "reviewupdate"
      ];
      let updatedFlag = false;
      for (const key of pulseKeys) {
        if (Object.prototype.hasOwnProperty.call(fmObj, key)) {
          fmObj[key] = false;
          updatedFlag = true;
        }
      }
      if (!updatedFlag) fmObj["Pulse Update"] = false;
      const b1 = (_a = parsedAnalysis["previousSceneAnalysis"]) == null ? void 0 : _a.trim();
      const b2 = (_b = parsedAnalysis["currentSceneAnalysis"]) == null ? void 0 : _b.trim();
      const b3 = (_c = parsedAnalysis["nextSceneAnalysis"]) == null ? void 0 : _c.trim();
      if (b1) fmObj["previousSceneAnalysis"] = toArray(b1);
      if (b2) fmObj["currentSceneAnalysis"] = toArray(b2);
      if (b3) fmObj["nextSceneAnalysis"] = toArray(b3);
    });
    return true;
  } catch (e) {
    console.error("[updateSceneBeats] Error updating file:", e);
    return false;
  }
}
async function markPulseProcessed(vault, file, plugin, modelIdUsed) {
  try {
    await plugin.app.fileManager.processFrontMatter(file, (fm) => {
      const fmObj = fm;
      const now = /* @__PURE__ */ new Date();
      const timestamp = now.toLocaleString(void 0, {
        year: "numeric",
        month: "short",
        day: "numeric",
        hour: "numeric",
        minute: "2-digit",
        hour12: true
      });
      fmObj["Pulse Last Updated"] = `${timestamp}${modelIdUsed ? ` by ${modelIdUsed}` : " by Unknown Model"}`;
      const pulseKeys = [
        "Pulse Update",
        "PulseUpdate",
        "pulseupdate",
        "Beats Update",
        "BeatsUpdate",
        "beatsupdate",
        "Review Update",
        "ReviewUpdate",
        "reviewupdate"
      ];
      let updatedFlag = false;
      for (const key of pulseKeys) {
        if (Object.prototype.hasOwnProperty.call(fmObj, key)) {
          fmObj[key] = false;
          updatedFlag = true;
        }
      }
      if (!updatedFlag) fmObj["Pulse Update"] = false;
    });
    return true;
  } catch (e) {
    console.error("[markPulseProcessed] Error updating pulse flag:", e);
    return false;
  }
}
var init_FileUpdater = __esm({
  "src/sceneAnalysis/FileUpdater.ts"() {
  }
});

// src/sceneAnalysis/RequestRunner.ts
function createAiRunner(plugin, vault, callAiProvider2) {
  return (userPrompt, subplotName, commandContext, sceneName, tripletInfo) => callAiProvider2(plugin, vault, userPrompt, subplotName, commandContext, sceneName, tripletInfo);
}
var init_RequestRunner = __esm({
  "src/sceneAnalysis/RequestRunner.ts"() {
  }
});

// src/ai/prompts/sceneAnalysis.ts
function getSceneAnalysisJsonSchema() {
  return SCENE_ANALYSIS_JSON_SCHEMA;
}
function getSceneAnalysisSystemPrompt() {
  return `You are Radial Timeline's scene-analysis assistant.`;
}
function buildSceneAnalysisPrompt(prevBody, currentBody, nextBody, prevNum, currentNum, nextNum, contextPrompt, extraInstructions) {
  let contextPrefix = (contextPrompt == null ? void 0 : contextPrompt.trim()) ? `${contextPrompt.trim()}

` : "You are a developmental editor for fiction.\n\n";
  if (extraInstructions == null ? void 0 : extraInstructions.trim()) {
    contextPrefix = `${extraInstructions.trim()}

${contextPrefix}`;
  }
  const isPrevAvailable = !!prevBody;
  const isNextAvailable = !!nextBody;
  if (!isPrevAvailable && !isNextAvailable) {
    return `${contextPrefix}Evaluate the single scene below. Return ONLY valid JSON matching this structure:

{
  "currentSceneAnalysis": [
    {
      "scene": "${currentNum}",
      "title": "Overall Scene Grade",
      "grade": "A" or "B" or "C",
      "comment": "Instructions on how to improve it (max 15 words)"
    },
    {
      "scene": "${currentNum}",
      "title": "Pulse point title",
      "grade": "+" or "-" or "?",
      "comment": "Concise editorial comment (max 10 words)"
    }
    // ... 3-5 more pulse points
  ]
}

Rules:
- Output ONLY valid JSON. No markdown code blocks, no preamble, no commentary.
- First item in currentSceneAnalysis must have grade A/B/C (overall scene quality).
- Subsequent items use +/-/? for connection strength.
- Keep comments concise (first item max 15 words, others max 10 words).
- Never use letter grades (A/B/C) outside that first item; use only "+", "-", or "?" afterwards.

${SCENE_ANALYSIS_EXAMPLE_SECTION}

Scene ${currentNum}:
${currentBody || "N/A"}
`;
  }
  if (!isPrevAvailable && isNextAvailable) {
    return `${contextPrefix}Evaluate the first scene in context of the following scene. Return ONLY valid JSON matching this structure:

{
  "currentSceneAnalysis": [
    {
      "scene": "${currentNum}",
      "title": "Overall Scene Grade",
      "grade": "A" or "B" or "C",
      "comment": "Instructions on how to improve it (max 15 words)"
    },
    {
      "scene": "${currentNum}",
      "title": "Pulse point title",
      "grade": "+" or "-" or "?",
      "comment": "Editorial comment (max 10 words)"
    }
    // ... 3-5 more pulse points
  ],
  "nextSceneAnalysis": [
    {
      "scene": "${nextNum}",
      "title": "Pulse point title",
      "grade": "+" or "-" or "?",
      "comment": "Editorial comment (max 10 words)"
    }
    // ... 3-5 more pulse points analyzing next scene
  ]
}

Rules:
- Output ONLY valid JSON. No markdown code blocks, no preamble.
- First currentSceneAnalysis item: grade A/B/C (overall quality). Others: +/-/? (connection strength).
- nextSceneAnalysis items: +/-/? showing how next scene builds on current.
- Never use letter grades (A/B/C) outside that first item; use only "+", "-", or "?" afterwards.
- For nextSceneAnalysis entries, grades must be "+", "-", or "?" only.

${SCENE_ANALYSIS_EXAMPLE_SECTION}

Scene ${currentNum}:
${currentBody || "N/A"}

Scene ${nextNum}:
${nextBody != null ? nextBody : "N/A"}
`;
  }
  if (isPrevAvailable && !isNextAvailable) {
    return `${contextPrefix}Evaluate the last scene in context of the previous scene. Return ONLY valid JSON matching this structure:

{
  "previousSceneAnalysis": [
    {
      "scene": "${prevNum}",
      "title": "Pulse point title",
      "grade": "+" or "-" or "?",
      "comment": "Editorial comment (max 10 words)"
    }
    // ... 3-5 more pulse points analyzing previous scene
  ],
  "currentSceneAnalysis": [
    {
      "scene": "${currentNum}",
      "title": "Overall Scene Grade",
      "grade": "A" or "B" or "C",
      "comment": "Instructions on how to improve it (max 15 words)"
    },
    {
      "scene": "${currentNum}",
      "title": "Pulse point title",
      "grade": "+" or "-" or "?",
      "comment": "Editorial comment (max 10 words)"
    }
    // ... 3-5 more pulse points
  ]
}

Rules:
- Output ONLY valid JSON. No markdown code blocks, no preamble.
- previousSceneAnalysis items: +/-/? showing how previous scene sets up current.
- First currentSceneAnalysis item: grade A/B/C (overall quality). Others: +/-/? (connection strength).
- Never use letter grades (A/B/C) outside that first item; use only "+", "-", or "?" afterwards.
- For previousSceneAnalysis entries, grades must be "+", "-", or "?" only.

${SCENE_ANALYSIS_EXAMPLE_SECTION}

Scene ${prevNum}:
${prevBody != null ? prevBody : "N/A"}

Scene ${currentNum}:
${currentBody || "N/A"}
`;
  }
  return `${contextPrefix}For each of the three scenes below, generate concise narrative pulse points from the perspective of the middle scene (${currentNum}), showing connections between previous (${prevNum}) and next (${nextNum}) scenes. Return ONLY valid JSON matching this structure:

{
  "previousSceneAnalysis": [
    {
      "scene": "${prevNum}",
      "title": "Pulse point title",
      "grade": "+" or "-" or "?",
      "comment": "Editorial comment (max 10 words)"
    }
    // ... 3-5 more pulse points analyzing how previous scene sets up current
  ],
  "currentSceneAnalysis": [
    {
      "scene": "${currentNum}",
      "title": "Overall Scene Grade",
      "grade": "A" or "B" or "C",
      "comment": "Instructions on how to improve it (max 15 words)"
    },
    {
      "scene": "${currentNum}",
      "title": "Pulse point title",
      "grade": "+" or "-" or "?",
      "comment": "Editorial comment (max 10 words)"
    }
    // ... 3-5 more pulse points analyzing current scene
  ],
  "nextSceneAnalysis": [
    {
      "scene": "${nextNum}",
      "title": "Pulse point title",
      "grade": "+" or "-" or "?",
      "comment": "Editorial comment (max 10 words)"
    }
    // ... 3-5 more pulse points analyzing how next scene builds on current
  ]
}

Rules:
- Output ONLY valid JSON. No markdown code blocks (no \`\`\`json), no preamble, no commentary.
- First currentSceneAnalysis item must have grade A/B/C (A=nearly perfect, C=needs improvement).
- All other items use +/-/?: "+" for strong connections, "-" for weak, "?" for neutral.
- Keep comments concise (first currentSceneAnalysis max 15 words, all others max 10 words).
- Never use letter grades (A/B/C) outside that first item; use only "+", "-", or "?" afterwards.
- previousSceneAnalysis and nextSceneAnalysis entries must use "+", "-", or "?".

${SCENE_ANALYSIS_EXAMPLE_SECTION}

Scene ${prevNum}:
${prevBody != null ? prevBody : "N/A"}

Scene ${currentNum}:
${currentBody || "N/A"}

Scene ${nextNum}:
${nextBody != null ? nextBody : "N/A"}
`;
}
var SCENE_ANALYSIS_JSON_SCHEMA, SCENE_ANALYSIS_JSON_EXAMPLE, SCENE_ANALYSIS_EXAMPLE_SECTION;
var init_sceneAnalysis = __esm({
  "src/ai/prompts/sceneAnalysis.ts"() {
    SCENE_ANALYSIS_JSON_SCHEMA = {
      type: "object",
      properties: {
        "previousSceneAnalysis": {
          type: "array",
          items: {
            type: "object",
            properties: {
              scene: { type: "string", description: "Scene number" },
              title: { type: "string", description: "Short analysis title" },
              grade: { type: "string", enum: ["+", "-", "?"], description: "Connection strength" },
              comment: { type: "string", description: "Editorial comment (max 10 words)" }
            },
            required: ["scene", "title", "grade", "comment"]
          }
        },
        "currentSceneAnalysis": {
          type: "array",
          items: {
            type: "object",
            properties: {
              scene: { type: "string", description: "Scene number" },
              title: { type: "string", description: "Short analysis title or grade (A/B/C for first item)" },
              grade: { type: "string", enum: ["+", "-", "?", "A", "B", "C"], description: "Grade or connection strength" },
              comment: { type: "string", description: "Editorial comment (max 15 words for first item, 10 for others)" }
            },
            required: ["scene", "title", "grade", "comment"]
          }
        },
        "nextSceneAnalysis": {
          type: "array",
          items: {
            type: "object",
            properties: {
              scene: { type: "string", description: "Scene number" },
              title: { type: "string", description: "Short analysis title" },
              grade: { type: "string", enum: ["+", "-", "?"], description: "Connection strength" },
              comment: { type: "string", description: "Editorial comment (max 10 words)" }
            },
            required: ["scene", "title", "grade", "comment"]
          }
        }
      },
      required: ["currentSceneAnalysis"]
    };
    SCENE_ANALYSIS_JSON_EXAMPLE = `{
  "previousSceneAnalysis": [
    { "scene": "23", "title": "First-rescue echo", "grade": "+", "comment": "Chae\u2019s compassion parallels Shail\u2019s later desperation" },
    { "scene": "23", "title": "Implant mystery", "grade": "?", "comment": "Tech anomalies foreshadow later biological puzzles" }
  ],
  "currentSceneAnalysis": [
    { "scene": "24", "title": "Overall Scene Grade", "grade": "B", "comment": "Tighten pacing and reduce repetition in survival beats" },
    { "scene": "24", "title": "Harsh environment pressure", "grade": "+", "comment": "Strongly escalates physical and emotional stakes" }
  ],
  "nextSceneAnalysis": [
    { "scene": "25", "title": "Tech\u2013bio tension", "grade": "+", "comment": "Survival biology echoes Diga genetic stakes" },
    { "scene": "25", "title": "Trust and secrecy", "grade": "+", "comment": "Shail\u2019s reliance reflects Chae\u2013Trisan disclosure themes" }
  ]
}`;
    SCENE_ANALYSIS_EXAMPLE_SECTION = `Example of valid JSON (do not copy verbatim; adapt to the scenes below):
${SCENE_ANALYSIS_JSON_EXAMPLE}
`;
  }
});

// src/sceneAnalysis/responseParsing.ts
function formatBeatLines(items, section) {
  if (!Array.isArray(items) || items.length === 0) return "";
  return items.map((item, index) => {
    const sceneNumber = typeof item.scene === "string" ? item.scene.trim() : "";
    const title = typeof item.title === "string" ? item.title.trim() : "";
    const grade = typeof item.grade === "string" ? item.grade.trim() : "";
    const comment = typeof item.comment === "string" ? item.comment.trim() : "";
    let lineCore = "";
    if (section === "current" && index === 0) {
      lineCore = [sceneNumber, grade.toUpperCase()].filter(Boolean).join(" ").trim();
    } else {
      const pieces = [];
      if (index === 0 && sceneNumber) pieces.push(sceneNumber);
      if (title) pieces.push(title);
      if (grade) pieces.push(grade);
      lineCore = pieces.join(" ").trim();
    }
    if (!lineCore && comment) lineCore = comment;
    const commentSegment = comment ? ` / ${comment}` : "";
    return `- ${lineCore}${commentSegment}`.trim();
  }).join("\n");
}
function validateSceneAnalysisPayload(payload) {
  if (!Array.isArray(payload.currentSceneAnalysis) || payload.currentSceneAnalysis.length === 0) {
    throw new Error("currentSceneAnalysis must include at least one item with the overall A/B/C grade.");
  }
  const [firstCurrent, ...restCurrent] = payload.currentSceneAnalysis;
  if (!firstCurrent || !MAIN_GRADE_VALUES.has(firstCurrent.grade)) {
    if (firstCurrent && LINK_GRADE_VALUES.has(firstCurrent.grade)) {
      if (firstCurrent.grade === "+") firstCurrent.grade = "A";
      else if (firstCurrent.grade === "?") firstCurrent.grade = "B";
      else if (firstCurrent.grade === "-") firstCurrent.grade = "C";
    } else {
      throw new Error("The first currentSceneAnalysis item must use grade A, B, or C.");
    }
  }
  const ensureLinkGrades = (items, label) => {
    if (!items) return;
    items.forEach((item, index) => {
      if (MAIN_GRADE_VALUES.has(item.grade) && !LINK_GRADE_VALUES.has(item.grade)) {
        if (item.grade === "A" || item.grade === "B") item.grade = "+";
        else if (item.grade === "C") item.grade = "-";
      }
      if (!LINK_GRADE_VALUES.has(item.grade)) {
        item.grade = "?";
      }
    });
  };
  ensureLinkGrades(payload.previousSceneAnalysis, "previousSceneAnalysis");
  ensureLinkGrades(payload.nextSceneAnalysis, "nextSceneAnalysis");
  if (restCurrent.length > 0) {
    ensureLinkGrades(restCurrent, "currentSceneAnalysis (subsequent items)");
  }
}
function sanitizeJsonControlCharacters(input) {
  return input.replace(/[\u0000-\u001F]/g, (char) => {
    if (char === "\n" || char === "\r" || char === "	") {
      return char;
    }
    return " ";
  });
}
function parseJsonBeatsResponse(jsonResult, plugin) {
  try {
    let parsed;
    try {
      parsed = JSON.parse(jsonResult);
    } catch (error) {
      if (error instanceof SyntaxError) {
        const sanitized = sanitizeJsonControlCharacters(jsonResult);
        if (sanitized !== jsonResult) {
          parsed = JSON.parse(sanitized);
        } else {
          throw error;
        }
      } else {
        throw error;
      }
    }
    validateSceneAnalysisPayload(parsed);
    plugin.lastAnalysisError = "";
    return {
      previousSceneAnalysis: formatBeatLines(parsed.previousSceneAnalysis, "previous"),
      currentSceneAnalysis: formatBeatLines(parsed.currentSceneAnalysis, "current"),
      nextSceneAnalysis: formatBeatLines(parsed.nextSceneAnalysis, "next")
    };
  } catch (error) {
    console.error("[parseJsonBeatsResponse] Error parsing JSON beats response:", error);
    plugin.lastAnalysisError = String(error);
    return null;
  }
}
function parseGptResult(gptResult, plugin) {
  try {
    if (!gptResult || typeof gptResult !== "string") {
      throw new Error("LLM returned empty result.");
    }
    let trimmed = gptResult.trim();
    if (trimmed.startsWith("```")) {
      trimmed = trimmed.replace(/^```[a-zA-Z0-9_-]*\s*/i, "");
      if (trimmed.endsWith("```")) {
        trimmed = trimmed.slice(0, -3);
      }
      trimmed = trimmed.trim();
    }
    if (!trimmed.startsWith("{")) {
      throw new Error("LLM response was not valid JSON.");
    }
    const jsonResult = parseJsonBeatsResponse(trimmed, plugin);
    if (jsonResult) {
      plugin.lastAnalysisError = "";
      return jsonResult;
    }
    return null;
  } catch (error) {
    console.error("[parseGptResult] Error parsing beats response:", error);
    plugin.lastAnalysisError = String(error);
    return null;
  }
}
var MAIN_GRADE_VALUES, LINK_GRADE_VALUES;
var init_responseParsing = __esm({
  "src/sceneAnalysis/responseParsing.ts"() {
    MAIN_GRADE_VALUES = /* @__PURE__ */ new Set(["A", "B", "C"]);
    LINK_GRADE_VALUES = /* @__PURE__ */ new Set(["+", "-", "?"]);
  }
});

// src/constants/tokenLimits.ts
function getSceneAnalysisTokenLimit(provider) {
  return PROVIDER_MAX_OUTPUT_TOKENS[provider];
}
var PROVIDER_MAX_OUTPUT_TOKENS;
var init_tokenLimits = __esm({
  "src/constants/tokenLimits.ts"() {
    PROVIDER_MAX_OUTPUT_TOKENS = {
      // Gemini 3 Pro: 65,536 (from API)
      // We use most of it since thinking tokens are separate in newer models
      gemini: 32e3,
      // Claude 4.x: 8,192 base, up to 64K with extended thinking
      // Extended thinking models use separate "thinking" budget
      anthropic: 16e3,
      // GPT-5.x: 16,384 for most models
      // Reasoning tokens counted separately in o-series
      openai: 16e3,
      // Local LLMs vary widely, use conservative default
      local: 4e3
    };
  }
});

// src/sceneAnalysis/aiProvider.ts
async function logApiInteractionToFile(plugin, vault, provider, modelId, requestData, responseData, subplotName, commandContext, sceneName, tripletInfo, analysis, options) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
  const forceLog = (options == null ? void 0 : options.force) === true;
  if (!plugin.settings.logApiInteractions && !forceLog) {
    return;
  }
  const logFolder = "AI";
  const timestamp = (/* @__PURE__ */ new Date()).toLocaleString(void 0, {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
    timeZoneName: "short"
  }).replace(/\//g, "-").replace(/(\d{1,2}):(\d{2}):(\d{2})\s*(AM|PM)\s*([A-Z]{3,})/g, "at $1.$2.$3 $4 $5").replace(/[\s,]+/g, " ").trim();
  const friendlyModelForFilename = (() => {
    const mid = (modelId || "").toLowerCase();
    if (provider === "anthropic") {
      if (mid.includes("sonnet-4-5") || mid.includes("sonnet-4.5")) return "Claude Sonnet 4.5";
      if (mid.includes("opus-4-1") || mid.includes("opus-4.1")) return "Claude Opus 4.1";
      if (mid.includes("sonnet-4")) return "Claude Sonnet 4";
      if (mid.includes("opus-4")) return "Claude Opus 4";
    } else if (provider === "gemini") {
      if (mid.includes("3-pro")) return "Gemini 3 Pro";
      if (mid.includes("2.5-pro") || mid.includes("2-5-pro")) return "Gemini Legacy";
    } else if (provider === "openai") {
      if (mid.includes("gpt-4.1") || mid.includes("gpt-4-1")) return "GPT-4.1";
    }
    return modelId;
  })();
  const sanitizeSegment = (value) => {
    if (!value) return "";
    return value.replace(/[<>:"/\\|?*]+/g, "-").replace(/\s+/g, " ").replace(/-+/g, "-").trim().replace(/^-+|-+$/g, "");
  };
  const safeModelSegment = sanitizeSegment(friendlyModelForFilename) || "local-model";
  const safeTimestamp = sanitizeSegment(timestamp) || (/* @__PURE__ */ new Date()).getTime().toString();
  let fileName;
  if (sceneName) {
    const cleanSceneName = sanitizeSegment(sceneName) || "Scene";
    fileName = `${cleanSceneName} \u2014 ${safeModelSegment} \u2014 ${safeTimestamp}.md`;
  } else {
    fileName = `${provider}-log-${safeTimestamp}.md`;
  }
  const filePath = `${logFolder}/${fileName}`;
  const isObject = (data) => {
    return typeof data === "object" && data !== null;
  };
  const safeRequestData = isObject(requestData) ? requestData : null;
  const requestJson = JSON.stringify(requestData, null, 2);
  const responseJson = JSON.stringify(responseData, null, 2);
  let usageString = "**Usage:** N/A";
  try {
    if (responseData && typeof responseData === "object") {
      const rd = responseData;
      if (provider === "openai" && "usage" in rd) {
        const u = rd.usage;
        if (u && (typeof u.prompt_tokens === "number" || typeof u.completion_tokens === "number")) {
          usageString = `**Usage (OpenAI):** prompt=${(_a = u.prompt_tokens) != null ? _a : "n/a"}, output=${(_b = u.completion_tokens) != null ? _b : "n/a"}`;
        }
      } else if (provider === "anthropic" && "usage" in rd) {
        const u = rd.usage;
        if (u && (typeof u.input_tokens === "number" || typeof u.output_tokens === "number")) {
          usageString = `**Usage (Anthropic):** input=${(_c = u.input_tokens) != null ? _c : "n/a"}, output=${(_d = u.output_tokens) != null ? _d : "n/a"}`;
        }
      } else if (provider === "gemini" && "usageMetadata" in rd) {
        const u = rd.usageMetadata;
        usageString = `**Usage (Gemini):** total=${(_e = u == null ? void 0 : u.totalTokenCount) != null ? _e : "n/a"}, prompt=${(_f = u == null ? void 0 : u.promptTokenCount) != null ? _f : "n/a"}, output=${(_g = u == null ? void 0 : u.candidatesTokenCount) != null ? _g : "n/a"}`;
      } else if (provider === "local" && "usage" in rd) {
        const u = rd.usage;
        if (u && (typeof u.prompt_tokens === "number" || typeof u.completion_tokens === "number")) {
          usageString = `**Usage (Local):** prompt=${(_h = u.prompt_tokens) != null ? _h : "n/a"}, output=${(_i = u.completion_tokens) != null ? _i : "n/a"}`;
        }
      }
    }
  } catch (e) {
  }
  let outcomeSection = "### Outcome\n\n";
  if (responseData && typeof responseData === "object") {
    const responseAsRecord = responseData;
    if (responseAsRecord.error) {
      outcomeSection += `**Status:** Failed
`;
      const errObj = responseAsRecord.error;
      outcomeSection += `**Error Type:** ${String((_j = errObj == null ? void 0 : errObj.type) != null ? _j : "Unknown")}
`;
      outcomeSection += `**Message:** ${String((_k = errObj == null ? void 0 : errObj.message) != null ? _k : "No message provided")}
`;
      if (typeof (errObj == null ? void 0 : errObj.status) !== "undefined") {
        outcomeSection += `**Status Code:** ${String(errObj.status)}
`;
      }
      outcomeSection += "\n";
    } else {
      let success = false;
      let contentForCheck = null;
      if (provider === "openai") {
        const choices = responseAsRecord.choices;
        if (Array.isArray(choices) && choices[0] && typeof choices[0] === "object") {
          const msg = choices[0].message;
          const content = msg == null ? void 0 : msg.content;
          contentForCheck = content;
        }
        success = !!contentForCheck;
      } else if (provider === "local") {
        const choices = responseAsRecord.choices;
        if (Array.isArray(choices) && choices[0] && typeof choices[0] === "object") {
          const msg = choices[0].message;
          const content = msg == null ? void 0 : msg.content;
          contentForCheck = content;
        }
        success = !!contentForCheck;
      } else if (provider === "anthropic") {
        const contentArr = responseAsRecord.content;
        if (Array.isArray(contentArr) && contentArr[0] && typeof contentArr[0] === "object") {
          const text = contentArr[0].text;
          contentForCheck = text != null ? text : responseData.content;
        }
        success = !!contentForCheck;
      } else if (provider === "gemini") {
        const candidates = responseAsRecord.candidates;
        if (Array.isArray(candidates) && candidates[0] && typeof candidates[0] === "object") {
          const content = candidates[0].content;
          const parts = content == null ? void 0 : content.parts;
          contentForCheck = parts == null ? void 0 : parts.map((p) => p.text).filter(Boolean).join("\n");
        }
        success = !!contentForCheck;
      }
      outcomeSection += `**Status:** ${success ? "Success" : "Failure"}
`;
      if (success) {
        outcomeSection += `**Tokens returned:** ${(_l = contentForCheck == null ? void 0 : contentForCheck.length) != null ? _l : 0}

`;
      } else {
        outcomeSection += `**Details:** Model returned no content.

`;
      }
    }
  }
  let subplotSection = "";
  if (subplotName) {
    subplotSection = `
**Subplot:** ${subplotName}
`;
  }
  const tripletSection = tripletInfo ? `
**Context Triplet:**
- Prev: ${tripletInfo.prev}
- Current: ${tripletInfo.current}
- Next: ${tripletInfo.next}
` : "";
  let promptContent = "";
  if (safeRequestData) {
    if (typeof safeRequestData.userPrompt === "string") {
      promptContent = safeRequestData.userPrompt;
    } else if (Array.isArray(safeRequestData.messages) && safeRequestData.messages[0] && typeof safeRequestData.messages[safeRequestData.messages.length - 1].content === "string") {
      promptContent = safeRequestData.messages[safeRequestData.messages.length - 1].content;
    }
  }
  const formatAnalysisSection = (header, content) => {
    if (!content || !content.trim()) return `${header}:
  - Not available`;
    const lines = content.split("\n").map((line) => line.trim()).filter(Boolean).map((line) => line.startsWith("-") ? line : `- ${line}`);
    return `${header}:
${lines.map((line) => `  ${line}`).join("\n")}`;
  };
  const systemPromptForLog = (_m = options == null ? void 0 : options.systemPrompt) == null ? void 0 : _m.trim();
  const supplementalLocalPrompt = (_n = options == null ? void 0 : options.supplementalLocalInstructions) == null ? void 0 : _n.trim();
  const promptSectionParts = [];
  promptSectionParts.push("## Prompt\n\n");
  if (systemPromptForLog) {
    promptSectionParts.push(`**System prompt:**
\`\`\`
${systemPromptForLog}
\`\`\`

`);
  }
  promptSectionParts.push(`**User prompt:**
\`\`\`
${promptContent || "N/A"}
\`\`\`
`);
  if (supplementalLocalPrompt) {
    promptSectionParts.push(`
**Supplemental local instructions:**
\`\`\`
${supplementalLocalPrompt}
\`\`\`
`);
  }
  const promptSection = promptSectionParts.join("");
  const sentPackageSection = `## Sent package
\`\`\`json
${requestJson}
\`\`\`
`;
  const returnedPackageSection = `## Returned package
\`\`\`
${(_o = options == null ? void 0 : options.rawTextResult) != null ? _o : "[no text content returned]"}
\`\`\`
`;
  const returnJsonSection = `## Return JSON
\`\`\`json
${responseJson}
\`\`\`
`;
  const structuredAnalysisSection = analysis ? `## Scene analysis

${formatAnalysisSection("previousSceneAnalysis", analysis.previousSceneAnalysis)}

${formatAnalysisSection("currentSceneAnalysis", analysis.currentSceneAnalysis)}

${formatAnalysisSection("nextSceneAnalysis", analysis.nextSceneAnalysis)}

` : "";
  const metadataSection = `## Metadata

**Provider:** ${provider}
**Model:** ${modelId}
**Scene:** ${sceneName != null ? sceneName : "N/A"}
**Command:** ${commandContext}
${subplotSection}${tripletSection}
${usageString}

${outcomeSection}`;
  const fileContent = `# AI Report \u2014 ${(/* @__PURE__ */ new Date()).toLocaleString()}

` + promptSection + sentPackageSection + returnedPackageSection + returnJsonSection + structuredAnalysisSection + metadataSection;
  const shouldEmitRawOnly = provider === "local" && ((_p = plugin.settings.localSendPulseToAiReport) != null ? _p : true) && !!(options == null ? void 0 : options.rawTextResult);
  const rawFileContent = shouldEmitRawOnly ? `# AI Raw Response \u2014 ${(/* @__PURE__ */ new Date()).toLocaleString()}

**Provider:** ${provider}
**Model:** ${modelId}
**Scene:** ${sceneName != null ? sceneName : "N/A"}
**Command:** ${commandContext}
` + (subplotSection ? `${subplotSection}
` : "") + (tripletSection ? `${tripletSection}
` : "") + `
## Raw JSON
\`\`\`json
${options.rawTextResult}
\`\`\`
` : "";
  try {
    const folderExists = vault.getAbstractFileByPath(logFolder);
    if (!folderExists) {
      await vault.createFolder(logFolder);
    }
    const existing = vault.getAbstractFileByPath(filePath);
    if (existing) {
      await vault.modify(existing, fileContent.trim());
    } else {
      await vault.create(filePath, fileContent.trim());
    }
    if (shouldEmitRawOnly) {
      const rawFilePath = `${logFolder}/RAW \u2014 ${fileName}`;
      const rawExisting = vault.getAbstractFileByPath(rawFilePath);
      if (rawExisting) {
        await vault.modify(rawExisting, rawFileContent.trim());
      } else {
        await vault.create(rawFilePath, rawFileContent.trim());
      }
    }
  } catch (error) {
    console.error(`[BeatsCommands] Error logging API interaction to file ${filePath}:`, error);
    new import_obsidian58.Notice(`Failed to write AI log to ${filePath}. Check console.`);
  }
}
async function retryWithBackoff(fn, maxRetries = 3, baseDelayMs = 5e3) {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const isRateLimitError = errorMessage.toLowerCase().includes("rate limit") || errorMessage.toLowerCase().includes("overloaded") || errorMessage.toLowerCase().includes("too many requests");
      if (isRateLimitError && attempt < maxRetries) {
        const delayMs = baseDelayMs * Math.pow(2, attempt);
        new import_obsidian58.Notice(`Rate limit reached. Waiting ${delayMs / 1e3}s before retry (${attempt + 1}/${maxRetries})...`, 3e3);
        await new Promise((resolve) => window.setTimeout(resolve, delayMs));
        continue;
      }
      throw error;
    }
  }
  throw new Error("Retry logic exhausted without success");
}
async function callAiProvider(plugin, vault, userPrompt, subplotName, commandContext, sceneName, tripletInfo) {
  var _a, _b, _c, _d, _e;
  const provider = plugin.settings.defaultAiProvider || "openai";
  const forceLocalReport = provider === "local" && ((_a = plugin.settings.localSendPulseToAiReport) != null ? _a : true);
  const supplementalLocalInstructions = provider === "local" ? plugin.settings.localLlmInstructions : void 0;
  let apiKey;
  let modelId;
  let requestBodyForLog = null;
  let responseDataForLog;
  let result = null;
  let apiErrorMsg;
  let systemPrompt = null;
  try {
    const normalizeModelId = (prov, id) => {
      if (!id) return id;
      switch (prov) {
        case "anthropic": {
          const legacyIds = /* @__PURE__ */ new Set([
            "claude-opus-4-1",
            "claude-4.1-opus",
            "claude-opus-4-1@20250805",
            "claude-opus-4-1-20250805",
            "claude-opus-4-0",
            "claude-3-opus-20240229",
            "claude-opus-4-20250514"
          ]);
          const sonnetLegacyIds = /* @__PURE__ */ new Set([
            "claude-sonnet-4-1",
            "claude-4-sonnet",
            "claude-sonnet-4-1@20250805",
            "claude-sonnet-4-0",
            "claude-3-7-sonnet-20250219",
            "claude-sonnet-4-20250514"
          ]);
          if (legacyIds.has(id)) return "claude-opus-4-5-20251101";
          if (sonnetLegacyIds.has(id)) return DEFAULT_ANTHROPIC_MODEL_ID;
          return id;
        }
        case "openai": {
          const legacyIds = /* @__PURE__ */ new Set(["gpt-5", "o3", "gpt-4o", "gpt-4.1", "gpt-4-turbo"]);
          if (legacyIds.has(id)) return DEFAULT_OPENAI_MODEL_ID;
          return id;
        }
        case "gemini": {
          const cleaned = id.trim().replace(/^models\//, "");
          const legacyIds = /* @__PURE__ */ new Set([
            "gemini-2.5-pro",
            "gemini-2.0-flash-exp",
            "gemini-ultra",
            "gemini-creative",
            "gemini-1.0-pro",
            "gemini-1.5-pro",
            "gemini-3-pro-preview"
          ]);
          if (legacyIds.has(cleaned)) return DEFAULT_GEMINI_MODEL_ID;
          return cleaned;
        }
        default:
          return id;
      }
    };
    const jsonSchema = getSceneAnalysisJsonSchema();
    systemPrompt = getSceneAnalysisSystemPrompt();
    if (provider === "anthropic") {
      const maxTokens = getSceneAnalysisTokenLimit("anthropic");
      apiKey = plugin.settings.anthropicApiKey;
      modelId = normalizeModelId("anthropic", plugin.settings.anthropicModelId) || DEFAULT_ANTHROPIC_MODEL_ID;
      if (!apiKey || !modelId) {
        apiErrorMsg = "Anthropic API key or Model ID not configured in settings.";
        responseDataForLog = { error: { message: apiErrorMsg, type: "plugin_config_error" } };
        throw new Error(apiErrorMsg);
      }
      requestBodyForLog = {
        model: modelId,
        system: systemPrompt || void 0,
        userPrompt,
        max_tokens: maxTokens
      };
      const apiResponse = await retryWithBackoff(
        () => callAnthropicApi(apiKey, modelId, systemPrompt, userPrompt, maxTokens)
      );
      responseDataForLog = apiResponse.responseData;
      if (!apiResponse.success || !apiResponse.content) {
        apiErrorMsg = (_b = apiResponse.error) != null ? _b : "Anthropic API returned no content.";
        throw new Error(apiErrorMsg);
      }
      result = apiResponse.content;
    } else if (provider === "openai") {
      const maxTokens = getSceneAnalysisTokenLimit("openai");
      apiKey = plugin.settings.openaiApiKey;
      modelId = normalizeModelId("openai", plugin.settings.openaiModelId) || DEFAULT_OPENAI_MODEL_ID;
      if (!apiKey || !modelId) {
        apiErrorMsg = "OpenAI API key or Model ID not configured in settings.";
        responseDataForLog = { error: { message: apiErrorMsg, type: "plugin_config_error" } };
        throw new Error(apiErrorMsg);
      }
      requestBodyForLog = {
        model: modelId,
        messages: [{ role: "user", content: systemPrompt ? `${systemPrompt}

${userPrompt}` : userPrompt }],
        max_completion_tokens: maxTokens,
        response_format: {
          type: "json_schema",
          json_schema: {
            name: "scene_analysis",
            schema: jsonSchema
          }
        }
      };
      const apiResponse = await retryWithBackoff(
        () => callOpenAiApi(
          apiKey,
          modelId,
          systemPrompt,
          userPrompt,
          maxTokens,
          void 0,
          { type: "json_schema", json_schema: { name: "scene_analysis", schema: jsonSchema } }
        )
      );
      responseDataForLog = apiResponse.responseData;
      if (!apiResponse.success || !apiResponse.content) {
        apiErrorMsg = (_c = apiResponse.error) != null ? _c : "OpenAI API returned no content.";
        throw new Error(apiErrorMsg);
      }
      result = apiResponse.content;
      if (isLatestAlias(modelId)) {
        const responseObj = apiResponse.responseData;
        const resolvedVersion = responseObj == null ? void 0 : responseObj.model;
        if (resolvedVersion) {
          cacheResolvedModel(modelId, resolvedVersion);
        }
      }
    } else if (provider === "gemini") {
      const maxTokens = getSceneAnalysisTokenLimit("gemini");
      apiKey = plugin.settings.geminiApiKey;
      modelId = normalizeModelId("gemini", plugin.settings.geminiModelId) || DEFAULT_GEMINI_MODEL_ID;
      if (!apiKey || !modelId) {
        apiErrorMsg = "Gemini API key or Model ID not configured in settings.";
        responseDataForLog = { error: { message: apiErrorMsg, type: "plugin_config_error" } };
        throw new Error(apiErrorMsg);
      }
      requestBodyForLog = {
        system_instruction: systemPrompt || void 0,
        userPrompt,
        temperature: 0.2,
        maxOutputTokens: maxTokens,
        response_schema: jsonSchema
      };
      const apiResponse = await retryWithBackoff(
        () => callGeminiApi(apiKey, modelId, systemPrompt, userPrompt, maxTokens, 0.2, jsonSchema, true)
      );
      responseDataForLog = apiResponse.responseData;
      if (!apiResponse.success || !apiResponse.content) {
        apiErrorMsg = (_d = apiResponse.error) != null ? _d : "Gemini API returned no content.";
        throw new Error(apiErrorMsg);
      }
      result = apiResponse.content;
      if (isLatestAlias(modelId)) {
        const responseObj = apiResponse.responseData;
        const resolvedVersion = responseObj == null ? void 0 : responseObj.modelVersion;
        if (resolvedVersion) {
          cacheResolvedModel(modelId, resolvedVersion);
        }
      }
    } else if (provider === "local") {
      const maxTokens = getSceneAnalysisTokenLimit("local");
      const localBaseUrl = plugin.settings.localBaseUrl || "http://localhost:11434/v1";
      modelId = plugin.settings.localModelId || "llama3";
      apiKey = plugin.settings.localApiKey || "";
      if (!localBaseUrl || !modelId) {
        apiErrorMsg = "Local Base URL or Model ID not configured in settings.";
        responseDataForLog = { error: { message: apiErrorMsg, type: "plugin_config_error" } };
        throw new Error(apiErrorMsg);
      }
      requestBodyForLog = {
        model: modelId,
        temperature: 0.1,
        messages: [{ role: "user", content: systemPrompt ? `${systemPrompt}

${userPrompt}` : userPrompt }],
        max_completion_tokens: maxTokens,
        response_format: {
          type: "json_schema",
          json_schema: {
            name: "scene_analysis",
            schema: jsonSchema
          }
        }
      };
      const apiResponse = await retryWithBackoff(
        () => callOpenAiApi(
          apiKey,
          modelId,
          systemPrompt,
          userPrompt,
          maxTokens,
          localBaseUrl,
          { type: "json_schema", json_schema: { name: "scene_analysis", schema: jsonSchema } },
          0.1
        )
      );
      responseDataForLog = apiResponse.responseData;
      if (!apiResponse.success || !apiResponse.content) {
        apiErrorMsg = (_e = apiResponse.error) != null ? _e : "Local API returned no content.";
        throw new Error(apiErrorMsg);
      }
      result = apiResponse.content;
    } else {
      throw new Error(`Unsupported AI provider: ${provider}`);
    }
    const parsedForLog = result ? parseGptResult(result, plugin) : null;
    await logApiInteractionToFile(
      plugin,
      vault,
      provider,
      modelId,
      requestBodyForLog,
      responseDataForLog,
      subplotName,
      commandContext,
      sceneName,
      tripletInfo,
      parsedForLog,
      {
        force: forceLocalReport,
        supplementalLocalInstructions,
        rawTextResult: result,
        systemPrompt
      }
    );
    return { result, modelIdUsed: modelId };
  } catch (error) {
    const detailedMessage = error instanceof Error ? error.message : String(error);
    if (apiErrorMsg) {
      new import_obsidian58.Notice(`${apiErrorMsg}

${detailedMessage}`, 8e3);
    } else {
      console.error(`[API][BeatsCommands][callAiProvider] Error during ${provider} API call:`, error);
      new import_obsidian58.Notice(`Error calling ${provider} API:
${detailedMessage}`, 8e3);
    }
    await logApiInteractionToFile(
      plugin,
      vault,
      provider,
      modelId || "unknown",
      requestBodyForLog,
      responseDataForLog,
      subplotName,
      commandContext,
      sceneName,
      tripletInfo,
      null,
      {
        force: forceLocalReport,
        supplementalLocalInstructions,
        rawTextResult: result,
        systemPrompt
      }
    );
    throw error instanceof Error ? error : new Error(String(error));
  }
}
var import_obsidian58;
var init_aiProvider = __esm({
  "src/sceneAnalysis/aiProvider.ts"() {
    import_obsidian58 = require("obsidian");
    init_aiDefaults();
    init_tokenLimits();
    init_anthropicApi();
    init_openaiApi();
    init_geminiApi();
    init_sceneAnalysis();
    init_responseParsing();
    init_modelResolver();
  }
});

// src/sceneAnalysis/Processor.ts
function buildQueueItem(scene) {
  var _a, _b;
  const rawTitle = typeof ((_a = scene.frontmatter) == null ? void 0 : _a.Title) === "string" ? scene.frontmatter.Title : scene.file.basename.replace(/\.md$/i, "");
  const parsed = parseSceneTitle(rawTitle, (_b = scene.sceneNumber) != null ? _b : void 0);
  const label = parsed.number || (scene.sceneNumber != null ? String(scene.sceneNumber) : "") || rawTitle;
  const detail = decodeHtmlEntities(parsed.text || rawTitle);
  return {
    id: scene.file.path,
    label,
    detail
  };
}
async function processWithModal(plugin, vault, mode, modal) {
  var _a, _b, _c, _d;
  const isResuming = plugin.settings._isResuming || false;
  if (isResuming) {
    plugin.settings._isResuming = false;
    await plugin.saveSettings();
  }
  const allScenes = await getAllSceneData(plugin, vault);
  allScenes.sort(compareScenesByOrder);
  if (allScenes.length < 1) {
    throw new Error("No valid scenes found in the specified source path.");
  }
  const processableScenes = allScenes.filter((scene) => {
    if (mode === "flagged") {
      const pulseUpdateFlag = getPulseUpdateFlag(scene.frontmatter);
      return normalizeBooleanValue(pulseUpdateFlag);
    }
    return hasProcessableContent(scene.frontmatter);
  });
  const processableContentScenes = allScenes.filter((scene) => hasProcessableContent(scene.frontmatter));
  const triplets = buildTripletsByIndex(processableContentScenes, processableScenes, (s) => s.file.path);
  const tasks = triplets.map((triplet) => {
    const pulseUpdateFlag = getPulseUpdateFlag(triplet.current.frontmatter);
    const isFlagged = normalizeBooleanValue(pulseUpdateFlag);
    let shouldProcess = false;
    if (mode === "flagged") {
      shouldProcess = isFlagged;
    } else if (mode === "force-all") {
      shouldProcess = isResuming ? !hasBeenProcessedForBeats(triplet.current.frontmatter, { todayOnly: true }) : true;
    } else if (mode === "unprocessed") {
      shouldProcess = isResuming ? !hasBeenProcessedForBeats(triplet.current.frontmatter, { todayOnly: true }) : !hasBeenProcessedForBeats(triplet.current.frontmatter);
    }
    return { triplet, shouldProcess };
  });
  const queueItems = tasks.filter((task) => task.shouldProcess).map((task) => buildQueueItem(task.triplet.current));
  if (modal && typeof modal.setProcessingQueue === "function") {
    modal.setProcessingQueue(queueItems);
  }
  const totalToProcess = queueItems.length;
  let processedCount = 0;
  const sendPulseToAiReportOnly = plugin.settings.defaultAiProvider === "local" && ((_a = plugin.settings.localSendPulseToAiReport) != null ? _a : true);
  for (const { triplet, shouldProcess } of tasks) {
    if (modal.isAborted()) {
      await plugin.saveSettings();
      throw new Error("Processing aborted by user");
    }
    if (!shouldProcess) continue;
    const prevBody = triplet.prev ? triplet.prev.body : null;
    const currentBody = triplet.current.body;
    const nextBody = triplet.next ? triplet.next.body : null;
    const prevNum = triplet.prev ? String((_b = triplet.prev.sceneNumber) != null ? _b : "N/A") : "N/A";
    const currentNum = String((_c = triplet.current.sceneNumber) != null ? _c : "N/A");
    const nextNum = triplet.next ? String((_d = triplet.next.sceneNumber) != null ? _d : "N/A") : "N/A";
    if (modal && typeof modal.setTripletInfo === "function") {
      modal.setTripletInfo(prevNum, currentNum, nextNum, triplet.current.file.path, triplet.current.file.basename);
    }
    const contextPrompt = getActiveContextPrompt(plugin);
    const extraInstructions = plugin.settings.defaultAiProvider === "local" ? plugin.settings.localLlmInstructions : void 0;
    const userPrompt = buildSceneAnalysisPrompt(prevBody, currentBody, nextBody, prevNum, currentNum, nextNum, contextPrompt, extraInstructions);
    const sceneNameForLog = triplet.current.file.basename;
    const tripletForLog = { prev: prevNum, current: currentNum, next: nextNum };
    const queueId = triplet.current.file.path;
    const markQueueStatus = (status) => {
      if (modal && typeof modal.markQueueStatus === "function") {
        modal.markQueueStatus(queueId, status);
      }
    };
    const runAi = createAiRunner(plugin, vault, callAiProvider);
    try {
      const aiResult = await runAi(userPrompt, null, "processByManuscriptOrder", sceneNameForLog, tripletForLog);
      if (aiResult.result) {
        const parsedAnalysis = parseGptResult(aiResult.result, plugin);
        if (parsedAnalysis) {
          if (!triplet.prev) parsedAnalysis["previousSceneAnalysis"] = "";
          if (!triplet.next) parsedAnalysis["nextSceneAnalysis"] = "";
          if (sendPulseToAiReportOnly) {
            const flagCleared = await markPulseProcessed(vault, triplet.current.file, plugin, aiResult.modelIdUsed);
            if (flagCleared) {
              processedCount++;
              modal.updateProgress(processedCount, totalToProcess, triplet.current.file.basename);
              markQueueStatus("success");
            } else {
              markQueueStatus("error");
              modal.addError(`Failed to update pulse flag for scene ${triplet.current.sceneNumber}: ${triplet.current.file.path}`);
            }
            continue;
          }
          const success = await updateSceneAnalysis(vault, triplet.current.file, parsedAnalysis, plugin, aiResult.modelIdUsed);
          if (success) {
            processedCount++;
            modal.updateProgress(processedCount, totalToProcess, triplet.current.file.basename);
            markQueueStatus("success");
            await plugin.saveSettings();
          } else {
            markQueueStatus("error");
            modal.addError(`Failed to update file for scene ${triplet.current.sceneNumber}: ${triplet.current.file.path}`);
          }
        } else {
          markQueueStatus("error");
          const detail = plugin.lastAnalysisError;
          const reason = detail ? ` (${detail})` : "";
          modal.addError(`Failed to parse AI response for scene ${triplet.current.sceneNumber}: ${triplet.current.file.path}${reason}`);
        }
      } else {
        markQueueStatus("error");
        modal.addError(`AI processing failed for scene ${triplet.current.sceneNumber}: ${triplet.current.file.path}`);
      }
    } catch (sceneError) {
      markQueueStatus("error");
      const detail = sceneError instanceof Error ? sceneError.message : String(sceneError);
      modal.addError(`Fatal error while processing scene ${triplet.current.sceneNumber}: ${triplet.current.file.path}
${detail}`);
    } finally {
      modal.noteLogAttempt();
    }
  }
  await plugin.saveSettings();
  plugin.refreshTimelineIfNeeded(null);
}
async function processBySubplotOrder(plugin, vault) {
  var _a, _b, _c, _d;
  const notice = new import_obsidian59.Notice("Processing Subplot: Getting scene data...", 0);
  try {
    const allScenes = await getAllSceneData(plugin, vault);
    if (allScenes.length < 1) {
      new import_obsidian59.Notice("No valid scenes found in the specified source path.");
      notice.hide();
      return;
    }
    const scenesBySubplot = {};
    allScenes.forEach((scene) => {
      const subplotList = getSubplotNamesFromFM(scene.frontmatter);
      subplotList.forEach((subplotKey) => {
        if (!subplotKey) return;
        if (!scenesBySubplot[subplotKey]) scenesBySubplot[subplotKey] = [];
        if (!scenesBySubplot[subplotKey].some((s) => s.file.path === scene.file.path)) {
          scenesBySubplot[subplotKey].push(scene);
        }
      });
    });
    const subplotNames = Object.keys(scenesBySubplot);
    if (subplotNames.length === 0) {
      new import_obsidian59.Notice("No scenes with subplots found.");
      notice.hide();
      return;
    }
    let totalProcessedCount = 0;
    let totalTripletsAcrossSubplots = 0;
    const sendPulseToAiReportOnly = plugin.settings.defaultAiProvider === "local" && ((_a = plugin.settings.localSendPulseToAiReport) != null ? _a : true);
    subplotNames.forEach((subplotName) => {
      const scenes = scenesBySubplot[subplotName];
      scenes.sort(compareScenesByOrder);
      const validScenes = scenes.filter((scene) => {
        var _a2;
        const pulseUpdate = getPulseUpdateFlag(scene.frontmatter);
        if (normalizeBooleanValue(pulseUpdate) && !hasProcessableContent(scene.frontmatter)) {
          const msg = `Scene ${(_a2 = scene.sceneNumber) != null ? _a2 : scene.file.basename} (subplot ${subplotName}) has Pulse Update set but Status is not working/complete. Skipping.`;
          new import_obsidian59.Notice(msg, 6e3);
        }
        return hasProcessableContent(scene.frontmatter) && normalizeBooleanValue(pulseUpdate);
      });
      totalTripletsAcrossSubplots += validScenes.length;
    });
    notice.setMessage(`Analyzing ${totalTripletsAcrossSubplots} scenes for subplot order...`);
    for (const subplotName of subplotNames) {
      const scenes = scenesBySubplot[subplotName];
      scenes.sort(compareScenesByOrder);
      const orderedScenes = scenes.slice().sort(compareScenesByOrder);
      const processableContentScenes = orderedScenes.filter((scene) => hasProcessableContent(scene.frontmatter));
      const flaggedInOrder = orderedScenes.filter(
        (s) => hasProcessableContent(s.frontmatter) && normalizeBooleanValue(getPulseUpdateFlag(s.frontmatter))
      );
      const triplets = buildTripletsByIndex(processableContentScenes, flaggedInOrder, (s) => s.file.path);
      for (const triplet of triplets) {
        const pulseUpdateFlag = getPulseUpdateFlag(triplet.current.frontmatter);
        if (!normalizeBooleanValue(pulseUpdateFlag)) {
          continue;
        }
        notice.setMessage(`Processing scene ${triplet.current.sceneNumber} (${totalProcessedCount + 1}/${totalTripletsAcrossSubplots}) - Subplot: '${subplotName}'...`);
        const prevBody = triplet.prev ? triplet.prev.body : null;
        const currentBody = triplet.current.body;
        const nextBody = triplet.next ? triplet.next.body : null;
        const prevNum = triplet.prev ? String((_b = triplet.prev.sceneNumber) != null ? _b : "N/A") : "N/A";
        const currentNum = String((_c = triplet.current.sceneNumber) != null ? _c : "N/A");
        const nextNum = triplet.next ? String((_d = triplet.next.sceneNumber) != null ? _d : "N/A") : "N/A";
        const contextPrompt = getActiveContextPrompt(plugin);
        const extraInstructions = plugin.settings.defaultAiProvider === "local" ? plugin.settings.localLlmInstructions : void 0;
        const userPrompt = buildSceneAnalysisPrompt(prevBody, currentBody, nextBody, prevNum, currentNum, nextNum, contextPrompt, extraInstructions);
        const sceneNameForLog = triplet.current.file.basename;
        const tripletForLog = { prev: prevNum, current: currentNum, next: nextNum };
        const runAi = createAiRunner(plugin, vault, callAiProvider);
        const aiResult = await runAi(userPrompt, subplotName, "processBySubplotOrder", sceneNameForLog, tripletForLog);
        if (aiResult.result) {
          const parsedAnalysis = parseGptResult(aiResult.result, plugin);
          if (parsedAnalysis) {
            if (!triplet.prev) parsedAnalysis["previousSceneAnalysis"] = "";
            if (!triplet.next) parsedAnalysis["nextSceneAnalysis"] = "";
            if (!sendPulseToAiReportOnly) {
              const updated = await updateSceneAnalysis(vault, triplet.current.file, parsedAnalysis, plugin, aiResult.modelIdUsed);
              if (updated) {
                await plugin.saveSettings();
              }
            } else {
              await markPulseProcessed(vault, triplet.current.file, plugin, aiResult.modelIdUsed);
            }
          }
        }
        totalProcessedCount++;
        notice.setMessage(`Progress: ${totalProcessedCount}/${totalTripletsAcrossSubplots} scenes processed...`);
        await new Promise((resolve) => window.setTimeout(resolve, 200));
      }
    }
    await plugin.saveSettings();
    notice.hide();
    new import_obsidian59.Notice(`Subplot order processing complete: ${totalProcessedCount}/${totalTripletsAcrossSubplots} triplets processed.`);
    plugin.refreshTimelineIfNeeded(null);
  } catch (error) {
    console.error("[API Beats][processBySubplotOrder] Error during processing:", error);
    notice.hide();
    new import_obsidian59.Notice("Error processing subplots. Check console for details.");
  }
}
async function processSubplotWithModal(plugin, vault, subplotName, modal) {
  var _a, _b, _c, _d;
  const allScenes = await getAllSceneData(plugin, vault);
  if (allScenes.length < 1) {
    throw new Error("No valid scenes found in the specified source path.");
  }
  const filtered = allScenes.filter((scene) => getSubplotNamesFromFM(scene.frontmatter).includes(subplotName));
  if (filtered.length === 0) {
    throw new Error(`No scenes found for subplot "${subplotName}".`);
  }
  filtered.sort(compareScenesByOrder);
  const validScenes = filtered.filter((scene) => {
    const pulseUpdate = getPulseUpdateFlag(scene.frontmatter);
    return hasProcessableContent(scene.frontmatter) && normalizeBooleanValue(pulseUpdate);
  });
  if (validScenes.length === 0) {
    throw new Error(`No flagged scenes (Pulse Update: Yes/True/1) with content found for "${subplotName}".`);
  }
  const contextScenes = filtered.filter((scene) => hasProcessableContent(scene.frontmatter));
  const triplets = buildTripletsByIndex(contextScenes, validScenes, (s) => s.file.path);
  const isResuming = plugin.settings._isResuming || false;
  if (isResuming) {
    plugin.settings._isResuming = false;
    await plugin.saveSettings();
  }
  const subplotTasks = triplets.map((triplet) => {
    const alreadyProcessed = hasBeenProcessedForBeats(triplet.current.frontmatter, { todayOnly: true });
    const shouldProcess = isResuming ? !alreadyProcessed : true;
    return { triplet, shouldProcess };
  });
  const queueItems = subplotTasks.filter((task) => task.shouldProcess).map((task) => buildQueueItem(task.triplet.current));
  if (modal && typeof modal.setProcessingQueue === "function") {
    modal.setProcessingQueue(queueItems);
  }
  const total = queueItems.length;
  let processedCount = 0;
  const sendPulseToAiReportOnly = plugin.settings.defaultAiProvider === "local" && ((_a = plugin.settings.localSendPulseToAiReport) != null ? _a : true);
  for (const { triplet, shouldProcess } of subplotTasks) {
    if (modal.isAborted()) {
      await plugin.saveSettings();
      throw new Error("Processing aborted by user");
    }
    if (!shouldProcess) continue;
    const sceneName = triplet.current.file.basename;
    const queueId = triplet.current.file.path;
    const markQueueStatus = (status) => {
      if (modal && typeof modal.markQueueStatus === "function") {
        modal.markQueueStatus(queueId, status);
      }
    };
    const prevBody = triplet.prev ? triplet.prev.body : null;
    const currentBody = triplet.current.body;
    const nextBody = triplet.next ? triplet.next.body : null;
    const prevNum = triplet.prev ? String((_b = triplet.prev.sceneNumber) != null ? _b : "N/A") : "N/A";
    const currentNum = String((_c = triplet.current.sceneNumber) != null ? _c : "N/A");
    const nextNum = triplet.next ? String((_d = triplet.next.sceneNumber) != null ? _d : "N/A") : "N/A";
    if (modal && typeof modal.setTripletInfo === "function") {
      modal.setTripletInfo(prevNum, currentNum, nextNum, triplet.current.file.path, sceneName);
    }
    const contextPrompt = getActiveContextPrompt(plugin);
    const extraInstructions = plugin.settings.defaultAiProvider === "local" ? plugin.settings.localLlmInstructions : void 0;
    const userPrompt = buildSceneAnalysisPrompt(prevBody, currentBody, nextBody, prevNum, currentNum, nextNum, contextPrompt, extraInstructions);
    const sceneNameForLog = triplet.current.file.basename;
    const tripletForLog = { prev: prevNum, current: currentNum, next: nextNum };
    const runAi = createAiRunner(plugin, vault, callAiProvider);
    try {
      const aiResult = await runAi(userPrompt, subplotName, "processBySubplotOrder", sceneNameForLog, tripletForLog);
      if (aiResult.result) {
        const parsedAnalysis = parseGptResult(aiResult.result, plugin);
        if (parsedAnalysis) {
          if (!triplet.prev) parsedAnalysis["previousSceneAnalysis"] = "";
          if (!triplet.next) parsedAnalysis["nextSceneAnalysis"] = "";
          if (sendPulseToAiReportOnly) {
            const flagCleared = await markPulseProcessed(vault, triplet.current.file, plugin, aiResult.modelIdUsed);
            if (flagCleared) {
              processedCount++;
              modal.updateProgress(processedCount, total, sceneName);
              markQueueStatus("success");
            } else {
              markQueueStatus("error");
              modal.addError(`Failed to update pulse flag for scene ${triplet.current.sceneNumber}: ${triplet.current.file.path}`);
            }
          } else {
            const success = await updateSceneAnalysis(vault, triplet.current.file, parsedAnalysis, plugin, aiResult.modelIdUsed);
            if (success) {
              processedCount++;
              modal.updateProgress(processedCount, total, sceneName);
              markQueueStatus("success");
            } else {
              markQueueStatus("error");
              modal.addError(`Failed to update file for scene ${triplet.current.sceneNumber}: ${triplet.current.file.path}`);
            }
          }
        } else {
          markQueueStatus("error");
          const detail = plugin.lastAnalysisError;
          const reason = detail ? ` (${detail})` : "";
          modal.addError(`Failed to parse AI response for scene ${triplet.current.sceneNumber}: ${triplet.current.file.path}${reason}`);
        }
      } else {
        markQueueStatus("error");
        modal.addError(`AI processing failed for scene ${triplet.current.sceneNumber}: ${triplet.current.file.path}`);
      }
    } catch (sceneError) {
      markQueueStatus("error");
      const detail = sceneError instanceof Error ? sceneError.message : String(sceneError);
      modal.addError(`Fatal error while processing scene ${triplet.current.sceneNumber}: ${triplet.current.file.path}
${detail}`);
    } finally {
      modal.noteLogAttempt();
    }
  }
  await plugin.saveSettings();
  plugin.refreshTimelineIfNeeded(null);
}
async function processEntireSubplotWithModalInternal(plugin, vault, subplotName, modal) {
  var _a, _b, _c, _d;
  const allScenes = await getAllSceneData(plugin, vault);
  if (allScenes.length < 1) {
    throw new Error("No valid scenes found in the specified source path.");
  }
  const filtered = allScenes.filter((scene) => getSubplotNamesFromFM(scene.frontmatter).includes(subplotName));
  if (filtered.length === 0) {
    throw new Error(`No scenes found for subplot "${subplotName}".`);
  }
  filtered.sort(compareScenesByOrder);
  const isResuming = plugin.settings._isResuming || false;
  if (isResuming) {
    plugin.settings._isResuming = false;
    await plugin.saveSettings();
  }
  const triplets = [];
  for (let i = 0; i < filtered.length; i++) {
    const currentScene = filtered[i];
    const prevScene = i > 0 ? filtered[i - 1] : null;
    const nextScene = i < filtered.length - 1 ? filtered[i + 1] : null;
    triplets.push({ prev: prevScene, current: currentScene, next: nextScene });
  }
  const subplotTasks = triplets.map((triplet) => {
    const alreadyProcessed = hasBeenProcessedForBeats(triplet.current.frontmatter, { todayOnly: true });
    const shouldProcess = isResuming ? !alreadyProcessed : true;
    return { triplet, shouldProcess };
  });
  const queueItems = subplotTasks.filter((task) => task.shouldProcess).map((task) => buildQueueItem(task.triplet.current));
  if (modal && typeof modal.setProcessingQueue === "function") {
    modal.setProcessingQueue(queueItems);
  }
  const total = queueItems.length;
  let processedCount = 0;
  const sendPulseToAiReportOnly = plugin.settings.defaultAiProvider === "local" && ((_a = plugin.settings.localSendPulseToAiReport) != null ? _a : true);
  for (const { triplet, shouldProcess } of subplotTasks) {
    if (modal.isAborted()) {
      await plugin.saveSettings();
      throw new Error("Processing aborted by user");
    }
    if (!shouldProcess) continue;
    const sceneName = triplet.current.file.basename;
    const queueId = triplet.current.file.path;
    const markQueueStatus = (status) => {
      if (modal && typeof modal.markQueueStatus === "function") {
        modal.markQueueStatus(queueId, status);
      }
    };
    const prevBody = triplet.prev ? triplet.prev.body : null;
    const currentBody = triplet.current.body;
    const nextBody = triplet.next ? triplet.next.body : null;
    const prevNum = triplet.prev ? String((_b = triplet.prev.sceneNumber) != null ? _b : "N/A") : "N/A";
    const currentNum = String((_c = triplet.current.sceneNumber) != null ? _c : "N/A");
    const nextNum = triplet.next ? String((_d = triplet.next.sceneNumber) != null ? _d : "N/A") : "N/A";
    if (modal && typeof modal.setTripletInfo === "function") {
      modal.setTripletInfo(prevNum, currentNum, nextNum, triplet.current.file.path, sceneName);
    }
    const contextPrompt = getActiveContextPrompt(plugin);
    const extraInstructions = plugin.settings.defaultAiProvider === "local" ? plugin.settings.localLlmInstructions : void 0;
    const userPrompt = buildSceneAnalysisPrompt(prevBody, currentBody, nextBody, prevNum, currentNum, nextNum, contextPrompt, extraInstructions);
    const sceneNameForLog = triplet.current.file.basename;
    const tripletForLog = { prev: prevNum, current: currentNum, next: nextNum };
    const runAi = createAiRunner(plugin, vault, callAiProvider);
    try {
      const aiResult = await runAi(userPrompt, subplotName, "processEntireSubplot", sceneNameForLog, tripletForLog);
      if (aiResult.result) {
        const parsedAnalysis = parseGptResult(aiResult.result, plugin);
        if (parsedAnalysis) {
          if (!triplet.prev) parsedAnalysis["previousSceneAnalysis"] = "";
          if (!triplet.next) parsedAnalysis["nextSceneAnalysis"] = "";
          if (sendPulseToAiReportOnly) {
            const flagCleared = await markPulseProcessed(vault, triplet.current.file, plugin, aiResult.modelIdUsed);
            if (flagCleared) {
              processedCount++;
              modal.updateProgress(processedCount, total, sceneName);
              markQueueStatus("success");
            } else {
              markQueueStatus("error");
              modal.addError(`Failed to update pulse flag for scene ${triplet.current.sceneNumber}: ${triplet.current.file.path}`);
            }
          } else {
            const success = await updateSceneAnalysis(vault, triplet.current.file, parsedAnalysis, plugin, aiResult.modelIdUsed);
            if (success) {
              processedCount++;
              modal.updateProgress(processedCount, total, sceneName);
              markQueueStatus("success");
            } else {
              markQueueStatus("error");
              modal.addError(`Failed to update file for scene ${triplet.current.sceneNumber}: ${triplet.current.file.path}`);
            }
          }
        } else {
          markQueueStatus("error");
          const detail = plugin.lastAnalysisError;
          const reason = detail ? ` (${detail})` : "";
          modal.addError(`Failed to parse AI response for scene ${triplet.current.sceneNumber}: ${triplet.current.file.path}${reason}`);
        }
      } else {
        markQueueStatus("error");
        modal.addError(`AI processing failed for scene ${triplet.current.sceneNumber}: ${triplet.current.file.path}`);
      }
    } catch (sceneError) {
      markQueueStatus("error");
      const detail = sceneError instanceof Error ? sceneError.message : String(sceneError);
      modal.addError(`Fatal error while processing scene ${triplet.current.sceneNumber}: ${triplet.current.file.path}
${detail}`);
    } finally {
      modal.noteLogAttempt();
    }
  }
  await plugin.saveSettings();
  plugin.refreshTimelineIfNeeded(null);
}
function getActiveContextPrompt(plugin) {
  const templates = plugin.settings.aiContextTemplates || [];
  const activeId = plugin.settings.activeAiContextTemplateId;
  const active = templates.find((t2) => t2.id === activeId);
  return active == null ? void 0 : active.prompt;
}
var import_obsidian59;
var init_Processor = __esm({
  "src/sceneAnalysis/Processor.ts"() {
    import_obsidian59 = require("obsidian");
    init_TripletBuilder();
    init_FileUpdater();
    init_RequestRunner();
    init_data();
    init_sceneHelpers();
    init_sceneAnalysis();
    init_responseParsing();
    init_aiProvider();
    init_text();
  }
});

// src/sceneAnalysis/Maintenance.ts
async function updateSceneFile(vault, scene, parsedAnalysis, plugin, modelIdUsed) {
  try {
    const toArray = (block) => {
      return block.split("\n").map((s) => s.replace(/^\s*-\s*/, "").trim()).filter(Boolean);
    };
    await plugin.app.fileManager.processFrontMatter(scene.file, (fm) => {
      var _a, _b, _c;
      const fmObj = fm;
      delete fmObj["1beats"];
      delete fmObj["2beats"];
      delete fmObj["3beats"];
      const now = /* @__PURE__ */ new Date();
      const timestamp = now.toLocaleString(void 0, {
        year: "numeric",
        month: "short",
        day: "numeric",
        hour: "numeric",
        minute: "2-digit",
        hour12: true
      });
      const updatedValue = `${timestamp}${modelIdUsed ? ` by ${modelIdUsed}` : " by Unknown Model"}`;
      fmObj["Pulse Last Updated"] = updatedValue;
      const pulseKeys = [
        "Pulse Update",
        "PulseUpdate",
        "pulseupdate",
        "Beats Update",
        "BeatsUpdate",
        "beatsupdate",
        "Review Update",
        "ReviewUpdate",
        "reviewupdate"
      ];
      let updatedFlag = false;
      for (const key of pulseKeys) {
        if (Object.prototype.hasOwnProperty.call(fmObj, key)) {
          fmObj[key] = false;
          updatedFlag = true;
        }
      }
      if (!updatedFlag) {
        fmObj["Pulse Update"] = false;
      }
      const b1 = (_a = parsedAnalysis["previousSceneAnalysis"]) == null ? void 0 : _a.trim();
      const b2 = (_b = parsedAnalysis["currentSceneAnalysis"]) == null ? void 0 : _b.trim();
      const b3 = (_c = parsedAnalysis["nextSceneAnalysis"]) == null ? void 0 : _c.trim();
      if (b1) fmObj["previousSceneAnalysis"] = toArray(b1);
      if (b2) fmObj["currentSceneAnalysis"] = toArray(b2);
      if (b3) fmObj["nextSceneAnalysis"] = toArray(b3);
    });
    return true;
  } catch (error) {
    console.error(`[updateSceneFile] Error updating file:`, error);
    new import_obsidian60.Notice(`Error saving updates to ${scene.file.basename}`);
    return false;
  }
}
async function testYamlUpdateFormatting(plugin, vault) {
  var _a, _b, _c;
  const dummyFilePath = "AITestDummyScene.md";
  const dummyBody = "This is the body text of the dummy scene.\nIt has multiple lines.";
  const dummyInitialFrontmatter = {
    Class: "Scene",
    Synopsis: "Dummy synopsis for testing YAML update.",
    Subplot: ["Test Arc"],
    When: "2024-01-01",
    Words: 10,
    "Pulse Update": "Yes"
  };
  new import_obsidian60.Notice(`Starting YAML update test on ${dummyFilePath}...`);
  try {
    let file = vault.getAbstractFileByPath(dummyFilePath);
    if (!(file instanceof import_obsidian60.TFile)) {
      const initialContent = `---
${(0, import_obsidian60.stringifyYaml)(dummyInitialFrontmatter)}---
${dummyBody}`;
      await vault.create(dummyFilePath, initialContent);
      file = vault.getAbstractFileByPath(dummyFilePath);
    }
    if (!(file instanceof import_obsidian60.TFile)) {
      new import_obsidian60.Notice(`Error: Could not get TFile for ${dummyFilePath}`);
      return;
    }
    const currentContent = await vault.read(file);
    const fmInfo = (0, import_obsidian60.getFrontMatterInfo)(currentContent);
    if (!fmInfo || !fmInfo.exists) {
      new import_obsidian60.Notice(`Error: Dummy file ${dummyFilePath} is missing frontmatter.`);
      return;
    }
    const fmText = (_a = fmInfo.frontmatter) != null ? _a : "";
    const currentFrontmatter = fmText ? (0, import_obsidian60.parseYaml)(fmText) || {} : {};
    let currentBody = currentContent;
    const endOffset = (_c = (_b = fmInfo.position) == null ? void 0 : _b.end) == null ? void 0 : _c.offset;
    if (typeof endOffset === "number" && endOffset >= 0 && endOffset <= currentContent.length) {
      currentBody = currentContent.slice(endOffset).trim();
    } else {
      currentBody = currentContent.replace(/^---[\s\S]*?\n---/, "").trim();
    }
    const dummySceneData = {
      file,
      frontmatter: currentFrontmatter,
      sceneNumber: 999,
      body: currentBody
    };
    const parsedAnalysis = parseGptResult(DUMMY_API_RESPONSE, plugin);
    if (!parsedAnalysis) {
      new import_obsidian60.Notice("Error: Failed to parse dummy API response data.");
      return;
    }
    const success = await updateSceneFile(vault, dummySceneData, parsedAnalysis, plugin, null);
    if (success) {
      new import_obsidian60.Notice(`Successfully updated YAML in ${dummyFilePath}. Please check the file formatting.`);
    } else {
      new import_obsidian60.Notice(`Failed to update YAML in ${dummyFilePath}. Check console for errors.`);
    }
  } catch (error) {
    console.error("Error during YAML update test:", error);
    new import_obsidian60.Notice("Error during YAML update test. Check console.");
  }
}
async function purgeScenesBeats(plugin, vault, scenes) {
  let purgedCount = 0;
  for (const scene of scenes) {
    try {
      await plugin.app.fileManager.processFrontMatter(scene.file, (fm) => {
        const fmObj = fm;
        const hadPrevious = fmObj["previousSceneAnalysis"] !== void 0;
        const hadCurrent = fmObj["currentSceneAnalysis"] !== void 0;
        const hadNext = fmObj["nextSceneAnalysis"] !== void 0;
        const hadTimestamp = fmObj["Pulse Last Updated"] !== void 0 || fmObj["Beats Last Updated"] !== void 0;
        delete fmObj["previousSceneAnalysis"];
        delete fmObj["currentSceneAnalysis"];
        delete fmObj["nextSceneAnalysis"];
        delete fmObj["Pulse Last Updated"];
        delete fmObj["Beats Last Updated"];
        if (hadPrevious || hadCurrent || hadNext || hadTimestamp) {
          purgedCount++;
        }
      });
    } catch (error) {
      console.error(`[purgeScenesBeats] Error purging beats from ${scene.file.path}:`, error);
    }
  }
  return purgedCount;
}
async function purgeBeatsByManuscriptOrder(plugin, vault) {
  try {
    const allScenes = await getAllSceneData(plugin, vault);
    if (allScenes.length === 0) {
      new import_obsidian60.Notice("No scenes found in manuscript.");
      return;
    }
    const modal = new PurgeConfirmationModal(
      plugin.app,
      `Purge ALL beats from ${allScenes.length} scene${allScenes.length !== 1 ? "s" : ""} in your manuscript?`,
      [
        "`previousSceneAnalysis`, `currentSceneAnalysis`, `nextSceneAnalysis` fields",
        "`Pulse Update` timestamp"
      ],
      async () => {
        const notice = new import_obsidian60.Notice("Purging beats from all scenes...", 0);
        const purgedCount = await purgeScenesBeats(plugin, vault, allScenes);
        notice.hide();
        await plugin.saveSettings();
        plugin.refreshTimelineIfNeeded(null);
        new import_obsidian60.Notice(`Purged beats from ${purgedCount} of ${allScenes.length} scene${allScenes.length !== 1 ? "s" : ""}.`);
      }
    );
    modal.open();
  } catch (error) {
    console.error("[purgeBeatsByManuscriptOrder] Error:", error);
    new import_obsidian60.Notice("Error purging beats. Check console for details.");
  }
}
async function purgeBeatsBySubplotName(plugin, vault, subplotName) {
  try {
    const allScenes = await getAllSceneData(plugin, vault);
    const filtered = allScenes.filter((scene) => getSubplotNamesFromFM(scene.frontmatter).includes(subplotName));
    if (filtered.length === 0) {
      new import_obsidian60.Notice(`No scenes found for subplot "${subplotName}".`);
      return;
    }
    const modal = new PurgeConfirmationModal(
      plugin.app,
      `Purge beats from ${filtered.length} scene${filtered.length !== 1 ? "s" : ""} in subplot "${subplotName}"?`,
      [
        "`previousSceneAnalysis`, `currentSceneAnalysis`, `nextSceneAnalysis` fields",
        "`Pulse Last Updated` timestamps"
      ],
      async () => {
        const notice = new import_obsidian60.Notice(`Purging beats from "${subplotName}"...`, 0);
        const purgedCount = await purgeScenesBeats(plugin, vault, filtered);
        notice.hide();
        await plugin.saveSettings();
        plugin.refreshTimelineIfNeeded(null);
        new import_obsidian60.Notice(`Purged beats from ${purgedCount} of ${filtered.length} scene${filtered.length !== 1 ? "s" : ""} in subplot "${subplotName}".`);
      }
    );
    modal.open();
  } catch (error) {
    console.error(`[purgeBeatsBySubplotName] Error purging subplot "${subplotName}":`, error);
    new import_obsidian60.Notice("Error purging beats. Check console for details.");
  }
}
var import_obsidian60, DUMMY_API_RESPONSE, PurgeConfirmationModal;
var init_Maintenance = __esm({
  "src/sceneAnalysis/Maintenance.ts"() {
    import_obsidian60 = require("obsidian");
    init_data();
    init_responseParsing();
    DUMMY_API_RESPONSE = `previousSceneAnalysis:
 - 33.2 Trisan Inner Turmoil - / Lacks clarity
 - Chae Ban Hesitation ? / Uncertain decision
 - Entiat Reflection ? / Needs clearer link: should explore motive
 - Chae Ban Plan + / Strengthens connection to currentSceneAnalysis choices
 - Meeting Entiat + / Sets up tension
currentSceneAnalysis:
 - 33.5 B / Scene will be stronger by making Entiat motivations clearer. Clarify: imminent threat
 - Entiat Adoption Reflections ? / Lacks tension link to events in previousSceneAnalysis
 - Chae Ban Escape News + / Advances plot
 - Entiat Internal Conflict + / Highlights dilemma: how to handle the situation from previousSceneAnalysis
 - Connection to nextSceneAnalysis + / Sets up the coming conflict
nextSceneAnalysis:
 - 34 Teco Routine Disruption - / Needs purpose
 - Entiat Unexpected Visit ? / Confusing motivation: clarify intention here
 - Sasha Defense and Defeat + / Builds on tension from currentSceneAnalysis
 - Teco Escape Decision + / Strong transition
 - Final Choice + / Resolves arc started in previousSceneAnalysis`;
    PurgeConfirmationModal = class extends import_obsidian60.Modal {
      constructor(app, message, details, onConfirm) {
        super(app);
        this.message = message;
        this.details = details;
        this.onConfirm = onConfirm;
      }
      onOpen() {
        const { contentEl, modalEl, titleEl } = this;
        titleEl.setText("");
        contentEl.empty();
        if (modalEl) {
          modalEl.classList.add("rt-modal-shell");
          modalEl.style.width = "760px";
          modalEl.style.maxWidth = "92vw";
          modalEl.style.maxHeight = "92vh";
        }
        contentEl.addClass("rt-modal-container");
        contentEl.addClass("rt-purge-confirm-modal");
        const hero = contentEl.createDiv({ cls: "rt-modal-header" });
        hero.createSpan({ text: "Warning", cls: "rt-modal-badge" });
        hero.createDiv({ text: "Confirm purge beats", cls: "rt-modal-title" });
        hero.createDiv({ text: "This action cannot be undone.", cls: "rt-modal-subtitle" });
        const card = contentEl.createDiv({ cls: "rt-glass-card rt-purge-confirm-card" });
        const messageEl = card.createDiv({ cls: "rt-purge-message" });
        messageEl.setText(this.message);
        const detailsEl = card.createDiv({ cls: "rt-purge-details" });
        detailsEl.createEl("div", { text: "This will permanently delete:", cls: "rt-purge-danger" });
        const listEl = detailsEl.createEl("ul", { cls: "rt-purge-list" });
        this.details.forEach((detail) => {
          const li = listEl.createEl("li");
          detail.split(/(`[^`]+`)/g).filter(Boolean).forEach((part) => {
            if (part.startsWith("`") && part.endsWith("`")) {
              li.createEl("code", { text: part.slice(1, -1) });
            } else {
              li.appendText(part);
            }
          });
        });
        const warningEl = card.createDiv({ cls: "rt-purge-warning" });
        warningEl.setText("Are you sure you want to proceed?");
        const buttonRow = contentEl.createDiv({ cls: "rt-modal-actions" });
        new import_obsidian60.ButtonComponent(buttonRow).setButtonText("Purge beats").setWarning().onClick(() => {
          this.close();
          this.onConfirm();
        });
        new import_obsidian60.ButtonComponent(buttonRow).setButtonText("Cancel").onClick(() => this.close());
      }
    };
  }
});

// src/SceneAnalysisCommands.ts
var SceneAnalysisCommands_exports = {};
__export(SceneAnalysisCommands_exports, {
  calculateFlaggedCount: () => calculateFlaggedCount,
  calculateSceneCount: () => calculateSceneCount,
  getDistinctSubplotNames: () => getDistinctSubplotNames,
  processByManuscriptOrder: () => processByManuscriptOrder,
  processBySubplotNameWithModal: () => processBySubplotNameWithModal,
  processBySubplotOrder: () => processBySubplotOrder,
  processEntireSubplotWithModal: () => processEntireSubplotWithModal,
  purgeBeatsByManuscriptOrder: () => purgeBeatsByManuscriptOrder,
  purgeBeatsBySubplotName: () => purgeBeatsBySubplotName,
  testYamlUpdateFormatting: () => testYamlUpdateFormatting
});
async function processByManuscriptOrder(plugin, vault) {
  const modal = new SceneAnalysisProcessingModal(
    plugin.app,
    plugin,
    (mode) => calculateSceneCount(plugin, vault, mode),
    async (mode) => {
      await processWithModal(plugin, vault, mode, modal);
    },
    "radial-timeline:update-beats-manuscript-order"
    // pass command ID for resume functionality
  );
  modal.open();
}
async function processEntireSubplotWithModal(plugin, vault, subplotName, isResuming = false) {
  if (plugin.activeBeatsModal && plugin.activeBeatsModal.isProcessing) {
    plugin.activeBeatsModal.open();
    new import_obsidian61.Notice("Reopening active processing session...");
    return;
  }
  const getSceneCount = async () => {
    try {
      const allScenes = await getAllSceneData(plugin, vault);
      const filtered = allScenes.filter((scene) => getSubplotNamesFromFM(scene.frontmatter).includes(subplotName));
      const validScenes = filtered.filter((scene) => hasProcessableContent(scene.frontmatter));
      if (isResuming) {
        const unprocessedToday = validScenes.filter(
          (scene) => !hasBeenProcessedForBeats(scene.frontmatter, { todayOnly: true })
        );
        return unprocessedToday.length;
      } else {
        return validScenes.length;
      }
    } catch (error) {
      return 0;
    }
  };
  const sceneCount = await getSceneCount();
  if (sceneCount === 0) {
    const reason = isResuming ? `No remaining scenes to process for subplot "${subplotName}" (all may have been processed today).` : `No scenes with content found for subplot "${subplotName}".`;
    new import_obsidian61.Notice(reason);
    return;
  }
  const modal = new SceneAnalysisProcessingModal(
    plugin.app,
    plugin,
    getSceneCount,
    async () => {
      await processEntireSubplotWithModalInternal(plugin, vault, subplotName, modal);
    },
    void 0,
    // no resumeCommandId for subplot processing
    subplotName,
    // pass subplot name for resume functionality
    true
    // isEntireSubplot = true
  );
  const originalOnOpen = modal.onOpen.bind(modal);
  modal.onOpen = function() {
    const { contentEl, titleEl, modalEl } = this;
    titleEl.setText("");
    if (modalEl) {
      modalEl.classList.add("rt-modal-shell");
      modalEl.style.width = "720px";
      modalEl.style.maxWidth = "92vw";
      modalEl.style.maxHeight = "92vh";
    }
    contentEl.addClass("rt-modal-container", "rt-scene-analysis-modal");
    this.showProgressView();
    this.isProcessing = true;
    this.abortController = new AbortController();
    plugin.activeBeatsModal = this;
    plugin.showBeatsStatusBar(0, 0);
    (async () => {
      try {
        await processEntireSubplotWithModalInternal(plugin, vault, subplotName, modal);
        if (this.abortController && this.abortController.signal.aborted) {
          this.showCompletionSummary("Processing aborted by user or rate limit");
        } else {
          this.showCompletionSummary("Processing completed successfully!");
        }
      } catch (error) {
        if (!this.abortController.signal.aborted) {
          this.addError(`Fatal error: ${error instanceof Error ? error.message : String(error)}`);
          this.showCompletionSummary("Processing stopped due to error");
        } else {
          this.showCompletionSummary("Processing aborted by user or rate limit");
        }
      } finally {
        this.isProcessing = false;
        this.abortController = null;
        plugin.activeBeatsModal = null;
        plugin.hideBeatsStatusBar();
      }
    })();
  };
  modal.open();
}
async function processBySubplotNameWithModal(plugin, vault, subplotName) {
  if (plugin.activeBeatsModal && plugin.activeBeatsModal.isProcessing) {
    plugin.activeBeatsModal.open();
    new import_obsidian61.Notice("Reopening active processing session...");
    return;
  }
  const getSceneCount = async () => {
    try {
      const allScenes = await getAllSceneData(plugin, vault);
      const filtered = allScenes.filter((scene) => getSubplotNamesFromFM(scene.frontmatter).includes(subplotName));
      const validScenes = filtered.filter((scene) => {
        const pulseUpdate = getPulseUpdateFlag(scene.frontmatter);
        return hasProcessableContent(scene.frontmatter) && normalizeBooleanValue(pulseUpdate);
      });
      return validScenes.length;
    } catch (error) {
      return 0;
    }
  };
  const sceneCount = await getSceneCount();
  if (sceneCount === 0) {
    new import_obsidian61.Notice(`No flagged scenes (Pulse Update: Yes) with content found for subplot "${subplotName}".`);
    return;
  }
  const modal = new SceneAnalysisProcessingModal(
    plugin.app,
    plugin,
    getSceneCount,
    async () => {
      await processSubplotWithModal(plugin, vault, subplotName, modal);
    },
    void 0,
    // no resumeCommandId for subplot processing
    subplotName,
    // pass subplot name for resume functionality
    false
    // isEntireSubplot = false (flagged scenes only)
  );
  const originalOnOpen = modal.onOpen.bind(modal);
  modal.onOpen = function() {
    const { contentEl, titleEl, modalEl } = this;
    titleEl.setText("");
    if (modalEl) {
      modalEl.classList.add("rt-modal-shell");
      modalEl.style.width = "720px";
      modalEl.style.maxWidth = "92vw";
      modalEl.style.maxHeight = "92vh";
    }
    contentEl.addClass("rt-modal-container", "rt-scene-analysis-modal");
    this.showProgressView();
    this.isProcessing = true;
    this.abortController = new AbortController();
    plugin.activeBeatsModal = this;
    plugin.showBeatsStatusBar(0, 0);
    (async () => {
      try {
        await processSubplotWithModal(plugin, vault, subplotName, modal);
        if (this.abortController && this.abortController.signal.aborted) {
          this.showCompletionSummary("Processing aborted by user or rate limit");
        } else {
          this.showCompletionSummary("Processing completed successfully!");
        }
      } catch (error) {
        if (!this.abortController.signal.aborted) {
          this.addError(`Fatal error: ${error instanceof Error ? error.message : String(error)}`);
          this.showCompletionSummary("Processing stopped due to error");
        } else {
          this.showCompletionSummary("Processing aborted by user or rate limit");
        }
      } finally {
        this.isProcessing = false;
        this.abortController = null;
        plugin.activeBeatsModal = null;
        plugin.hideBeatsStatusBar();
      }
    })();
  };
  modal.open();
}
var import_obsidian61;
var init_SceneAnalysisCommands = __esm({
  "src/SceneAnalysisCommands.ts"() {
    import_obsidian61 = require("obsidian");
    init_SceneAnalysisProcessingModal();
    init_sceneHelpers();
    init_data();
    init_Processor();
    init_data();
    init_Processor();
    init_Maintenance();
  }
});

// src/services/SearchService.ts
var SearchService_exports = {};
__export(SearchService_exports, {
  SearchService: () => SearchService
});
var import_obsidian64, SearchService;
var init_SearchService = __esm({
  "src/services/SearchService.ts"() {
    import_obsidian64 = require("obsidian");
    init_planetaryTime();
    SearchService = class {
      constructor(app, plugin) {
        this.app = app;
        this.plugin = plugin;
      }
      openSearchPrompt() {
        const modal = new import_obsidian64.Modal(this.app);
        const { modalEl, contentEl } = modal;
        modalEl.classList.add("rt-modal-shell");
        contentEl.empty();
        contentEl.addClass("rt-modal-container", "rt-search-modal");
        const header = contentEl.createDiv({ cls: "rt-modal-header" });
        header.createSpan({ text: "Find", cls: "rt-modal-badge" });
        header.createDiv({ text: "Search timeline", cls: "rt-modal-title" });
        header.createDiv({ text: "Search scenes by title, synopsis, characters, dates, and more.", cls: "rt-modal-subtitle" });
        const searchContainer = contentEl.createDiv({ cls: "rt-search-input-container" });
        const searchInput = new import_obsidian64.TextComponent(searchContainer);
        searchInput.setPlaceholder("Enter search term (min 3 letters)");
        searchInput.inputEl.classList.add("rt-search-input");
        if (this.plugin.searchActive && this.plugin.searchTerm) searchInput.setValue(this.plugin.searchTerm);
        const validateInput = () => {
          const term = searchInput.getValue().trim();
          if (term.length > 0 && term.length < 3) {
            searchInput.inputEl.classList.add("rt-input-error");
            return false;
          } else {
            searchInput.inputEl.classList.remove("rt-input-error");
            return true;
          }
        };
        searchInput.inputEl.addEventListener("blur", () => {
          validateInput();
        });
        const buttonContainer = contentEl.createDiv({ cls: "rt-modal-actions" });
        new import_obsidian64.ButtonComponent(buttonContainer).setButtonText("Search").setCta().onClick(() => {
          const term = searchInput.getValue().trim();
          if (term.length >= 3) {
            searchInput.inputEl.classList.remove("rt-input-error");
            this.performSearch(term);
            modal.close();
          } else {
            searchInput.inputEl.classList.add("rt-input-error");
            new import_obsidian64.Notice("Please enter at least 3 letters to search");
          }
        });
        new import_obsidian64.ButtonComponent(buttonContainer).setButtonText("Reset").onClick(() => {
          searchInput.setValue("");
          searchInput.inputEl.classList.remove("rt-input-error");
          this.clearSearch();
          modal.close();
        });
        searchInput.inputEl.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            const term = searchInput.getValue().trim();
            if (term.length >= 3) {
              searchInput.inputEl.classList.remove("rt-input-error");
              this.performSearch(term);
              modal.close();
            } else {
              searchInput.inputEl.classList.add("rt-input-error");
              new import_obsidian64.Notice("Please enter at least 3 letters to search");
            }
          }
        });
        modal.open();
        window.setTimeout(() => searchInput.inputEl.focus(), 50);
      }
      performSearch(term) {
        if (!term || term.trim().length === 0) {
          this.clearSearch();
          return;
        }
        this.plugin.searchTerm = term;
        this.plugin.searchActive = true;
        this.plugin.searchResults.clear();
        const containsWholePhrase = (haystack, phrase, isDate = false) => {
          if (!haystack || !phrase || typeof haystack !== "string") return false;
          const h = haystack.toLowerCase();
          const p = phrase.toLowerCase();
          if (isDate && h.includes("/")) {
            const datePattern = new RegExp(p.replace(/\//g, "\\/") + "(?:\\/|$)", "i");
            return datePattern.test(h);
          }
          return h.includes(p);
        };
        const formatDateForDisplay = (when) => {
          if (!when || !(when instanceof Date)) return "";
          try {
            const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const month = months[when.getMonth()];
            const day = when.getDate();
            const year = when.getFullYear();
            const hours = when.getHours();
            const minutes = when.getMinutes();
            let dateStr = `${month} ${day}, ${year}`;
            if (hours === 0 && minutes === 0) {
              dateStr += ` @ Midnight`;
            } else if (hours === 12 && minutes === 0) {
              dateStr += ` @ Noon`;
            } else {
              const period = hours >= 12 ? "PM" : "AM";
              const displayHours = hours % 12 === 0 ? 12 : hours % 12;
              if (minutes === 0) {
                dateStr += ` @ ${displayHours}${period}`;
              } else {
                dateStr += ` @ ${displayHours}:${String(minutes).padStart(2, "0")}${period}`;
              }
            }
            return dateStr;
          } catch (e) {
            return "";
          }
        };
        const planetaryProfile = getActivePlanetaryProfile(this.plugin.settings);
        this.plugin.getSceneData().then((scenes) => {
          scenes.forEach((scene) => {
            var _a;
            const povText = scene.pov ? String(scene.pov) : "";
            const textFields = [
              scene.title,
              scene.synopsis,
              ...scene.Character || [],
              scene.subplot,
              scene.location,
              povText,
              scene.Duration,
              scene["currentSceneAnalysis"],
              scene["previousSceneAnalysis"],
              scene["nextSceneAnalysis"]
            ];
            if (planetaryProfile && scene.when) {
              const conversion = convertFromEarth(scene.when, planetaryProfile);
              if (conversion) {
                const label = (planetaryProfile.label || "LOCAL").toUpperCase();
                textFields.push(`${label}: ${conversion.formatted}`);
              }
            }
            const textMatched = textFields.some((f) => containsWholePhrase(f, term, false));
            const dateFieldNumeric = (_a = scene.when) == null ? void 0 : _a.toLocaleDateString();
            const dateFieldDisplay = formatDateForDisplay(scene.when);
            const dateMatched = containsWholePhrase(dateFieldNumeric, term, true) || containsWholePhrase(dateFieldDisplay, term, false);
            if (textMatched || dateMatched) {
              if (scene.path) this.plugin.searchResults.add(scene.path);
            }
          });
          const timelineViews = this.plugin.getTimelineViews();
          timelineViews.forEach((view) => view.refreshTimeline());
        });
      }
      clearSearch() {
        this.plugin.searchActive = false;
        this.plugin.searchTerm = "";
        this.plugin.searchResults.clear();
        const timelineViews = this.plugin.getTimelineViews();
        timelineViews.forEach((view) => view.refreshTimeline());
      }
    };
  }
});

// src/services/FileTrackingService.ts
var FileTrackingService_exports = {};
__export(FileTrackingService_exports, {
  FileTrackingService: () => FileTrackingService
});
var import_obsidian65, FileTrackingService;
var init_FileTrackingService = __esm({
  "src/services/FileTrackingService.ts"() {
    import_obsidian65 = require("obsidian");
    FileTrackingService = class {
      constructor(plugin) {
        this.plugin = plugin;
      }
      updateOpenFilesTracking() {
        const previousOpenFiles = new Set(this.plugin.openScenePaths);
        const openFilePaths = /* @__PURE__ */ new Set();
        const openFilesList = [];
        const leaves = this.plugin.app.workspace.getLeavesOfType("markdown");
        leaves.forEach((leaf) => {
          const view = leaf.view;
          if (view instanceof import_obsidian65.MarkdownView && view.file) {
            openFilePaths.add(view.file.path);
            openFilesList.push(view.file.path);
          }
        });
        const activeFile = this.plugin.app.workspace.getActiveFile();
        if (activeFile && !openFilesList.includes(activeFile.path)) {
          openFilePaths.add(activeFile.path);
          openFilesList.push(activeFile.path);
        }
        try {
          const layout = this.plugin.app.workspace.getLayout();
          if (layout && layout.leaves) {
            const leafIds = Object.keys(layout.leaves);
            leafIds.forEach((id) => {
              const leafData = layout.leaves[id];
              if (leafData && leafData.type === "markdown" && leafData.state && leafData.state.file) {
                const filePath = leafData.state.file;
                if (!openFilesList.includes(filePath)) {
                  openFilePaths.add(filePath);
                  openFilesList.push(filePath);
                }
              }
            });
          }
        } catch (error) {
          console.error("[Radial Timeline] Error accessing workspace layout:", error);
        }
        let hasChanged = previousOpenFiles.size !== openFilePaths.size;
        if (!hasChanged) {
          for (const path of openFilePaths) {
            if (!previousOpenFiles.has(path)) {
              hasChanged = true;
              break;
            }
          }
        }
        if (!hasChanged) return;
        this.plugin.openScenePaths = openFilePaths;
        this.plugin.getTimelineViews().forEach((v) => v.refreshTimeline());
      }
      registerWorkspaceListeners() {
        this.plugin.app.workspace.onLayoutReady(() => {
          this.plugin.setCSSColorVariables();
          this.updateOpenFilesTracking();
        });
        this.plugin.registerEvent(this.plugin.app.workspace.on("layout-change", () => {
          if (this.isModalOpen()) {
            window.setTimeout(() => {
              if (!this.isModalOpen()) {
                this.updateOpenFilesTracking();
                this.plugin.refreshTimelineIfNeeded(null);
              }
            }, 200);
            return;
          }
          this.updateOpenFilesTracking();
          this.plugin.refreshTimelineIfNeeded(null);
        }));
        this.plugin.registerEvent(this.plugin.app.vault.on("delete", (file) => this.plugin.refreshTimelineIfNeeded(file)));
        this.plugin.registerEvent(this.plugin.app.vault.on("rename", (file, oldPath) => this.handleFileRename(file, oldPath)));
        this.plugin.registerEvent(this.plugin.app.workspace.on("css-change", () => {
          this.plugin.setCSSColorVariables();
          try {
            const views = this.plugin.getTimelineViews();
            views.forEach((v) => {
              var _a, _b;
              const svg = (_b = (_a = v == null ? void 0 : v.containerEl) == null ? void 0 : _a.querySelector) == null ? void 0 : _b.call(_a, ".radial-timeline-svg");
              if (svg) {
                this.plugin.getRendererService().updateProgressAndTicks(v);
                if (v.currentMode === "gossamer") {
                  this.plugin.getRendererService().updateGossamerLayer(v);
                }
              }
            });
          } catch (e) {
            this.plugin.refreshTimelineIfNeeded(null);
          }
        }));
      }
      handleFileRename(file, oldPath) {
        if (this.plugin.openScenePaths.has(oldPath)) {
          this.plugin.openScenePaths.delete(oldPath);
          if (file instanceof import_obsidian65.TFile && this.plugin.isSceneFile(file.path)) {
            this.plugin.openScenePaths.add(file.path);
          }
        }
        this.plugin.refreshTimelineIfNeeded(file);
      }
      /**
       * Heuristic: detect if any Obsidian modal is currently mounted.
       * This prevents timeline refreshes while a modal is visible, which causes UI flicker.
       * Checks multiple selectors to catch settings modal, plugins modal, and standard modals.
       */
      isModalOpen() {
        try {
          const modalContainer = document.body.querySelector(".modal-container");
          if (modalContainer && modalContainer.childElementCount > 0) return true;
          const modalBg = document.body.querySelector(".modal-bg");
          if (modalBg) return true;
          const modal = document.body.querySelector(".modal");
          if (modal) return true;
          return false;
        } catch (e) {
          return false;
        }
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  TIMELINE_VIEW_TYPE: () => TIMELINE_VIEW_TYPE2,
  default: () => RadialTimelinePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian66 = require("obsidian");

// src/services/TimelineService.ts
var import_obsidian24 = require("obsidian");

// src/view/TimeLineView.ts
var import_obsidian23 = require("obsidian");

// src/utils/svgDom.ts
function renderSvgFromString(svgContent, container, registerCleanup = () => {
}) {
  try {
    const svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    const parser = new DOMParser();
    const svgDoc = parser.parseFromString(svgContent, "image/svg+xml");
    const parserError = svgDoc.querySelector("parsererror");
    if (parserError) {
      console.error("Error parsing SVG content:", parserError.textContent);
      const fallbackDoc = new DOMParser().parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${svgContent}</svg>`, "image/svg+xml");
      if (!fallbackDoc.querySelector("parsererror")) {
        const fallbackSvg = fallbackDoc.documentElement;
        while (fallbackSvg.firstChild) {
          svgElement.appendChild(fallbackSvg.firstChild);
        }
        setCriticalAttributes(svgElement, fallbackSvg.getAttribute("viewBox"));
        container.appendChild(wrapInFragment(svgElement));
        return svgElement;
      }
      return null;
    }
    const sourceSvg = svgDoc.documentElement;
    copyAttributes(sourceSvg, svgElement);
    setCriticalAttributes(svgElement, sourceSvg.getAttribute("viewBox"));
    while (sourceSvg.firstChild) {
      svgElement.appendChild(sourceSvg.firstChild);
    }
    container.appendChild(wrapInFragment(svgElement));
    return svgElement;
  } catch (error) {
    console.error("Error creating SVG element:", error);
    return buildFallbackSvg(svgContent, container, registerCleanup);
  }
}
function wrapInFragment(node) {
  const fragment = document.createDocumentFragment();
  fragment.appendChild(node);
  return fragment;
}
function copyAttributes(source, target) {
  Array.from(source.attributes).forEach((attr) => {
    if (attr.name !== "xmlns" && attr.name !== "class") {
      target.setAttribute(attr.name, attr.value);
    }
  });
  target.classList.add(...Array.from(source.classList));
}
function setCriticalAttributes(svgElement, viewBox) {
  svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
  svgElement.setAttribute("width", "100%");
  svgElement.setAttribute("height", "100%");
  svgElement.setAttribute("viewBox", viewBox || "-800 -800 1600 1600");
  svgElement.setAttribute("preserveAspectRatio", "xMidYMid meet");
  svgElement.setAttribute("class", "radial-timeline-svg");
}
function buildFallbackSvg(svgContent, container, registerCleanup) {
  try {
    const fallbackSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    setCriticalAttributes(fallbackSvg, null);
    const svgBodyMatch = svgContent.match(/<svg[^>]*>([\s\S]*)<\/svg>/i);
    if (svgBodyMatch && svgBodyMatch[1]) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${svgBodyMatch[1]}</svg>`, "image/svg+xml");
      if (!doc.querySelector("parsererror")) {
        const svgDoc = doc.documentElement;
        const elementNodes = Array.from(svgDoc.querySelectorAll("*"));
        let pendingTimeout = null;
        const processNodes = (nodes, startIdx, callback) => {
          const CHUNK_SIZE = 100;
          const endIdx = Math.min(startIdx + CHUNK_SIZE, nodes.length);
          for (let i = startIdx; i < endIdx; i++) {
            const element = nodes[i];
            const newElement = document.createElementNS("http://www.w3.org/2000/svg", element.tagName.toLowerCase());
            Array.from(element.attributes).forEach((attr) => newElement.setAttribute(attr.name, attr.value));
            newElement.textContent = element.textContent;
            fallbackSvg.appendChild(newElement);
          }
          if (endIdx < nodes.length) {
            const timeoutId = window.setTimeout(() => {
              pendingTimeout = null;
              processNodes(nodes, endIdx, callback);
            }, 0);
            pendingTimeout = timeoutId;
            registerCleanup(() => window.clearTimeout(timeoutId));
          } else {
            callback();
          }
        };
        if (elementNodes.length > 100) {
          const loadingText = document.createElementNS("http://www.w3.org/2000/svg", "text");
          loadingText.setAttribute("x", "0");
          loadingText.setAttribute("y", "0");
          loadingText.setAttribute("class", "loading-message");
          loadingText.setAttribute("font-size", "24");
          loadingText.setAttribute("text-anchor", "middle");
          loadingText.textContent = "Loading timeline...";
          fallbackSvg.appendChild(loadingText);
          container.appendChild(wrapInFragment(fallbackSvg));
          processNodes(elementNodes, 0, () => {
            if (pendingTimeout !== null) {
              window.clearTimeout(pendingTimeout);
              pendingTimeout = null;
            }
            loadingText.remove();
          });
        } else {
          elementNodes.forEach((element) => {
            const newElement = document.createElementNS("http://www.w3.org/2000/svg", element.tagName.toLowerCase());
            Array.from(element.attributes).forEach((attr) => newElement.setAttribute(attr.name, attr.value));
            newElement.textContent = element.textContent;
            fallbackSvg.appendChild(newElement);
          });
          container.appendChild(wrapInFragment(fallbackSvg));
        }
        return fallbackSvg;
      }
    }
    container.appendChild(wrapInFragment(fallbackSvg));
    return fallbackSvg;
  } catch (innerError) {
    console.error("All SVG parsing approaches failed:", innerError);
    return null;
  }
}

// src/view/interactions/RotationController.ts
function setupRotationController(view, svg) {
  const rotatable = svg.querySelector("#timeline-rotatable");
  const toggle = svg.querySelector("#rotation-toggle");
  const arrowUp = svg.querySelector("#rotation-arrow-up");
  const arrowDown = svg.querySelector("#rotation-arrow-down");
  if (!rotatable || !toggle || !arrowUp || !arrowDown) {
    return;
  }
  let rotated = view.getRotationState();
  const applyRotation = () => {
    const numActs = parseInt(svg.getAttribute("data-num-acts") || "3", 10);
    const angle = numActs > 0 ? 360 / numActs : 120;
    if (rotated) {
      rotatable.setAttribute("transform", `rotate(-${angle})`);
      arrowUp.classList.add("is-hidden");
      arrowDown.classList.remove("is-hidden");
    } else {
      rotatable.removeAttribute("transform");
      arrowUp.classList.remove("is-hidden");
      arrowDown.classList.add("is-hidden");
    }
    svg.setAttribute("data-rotated", rotated ? "true" : "false");
    view.applyRotationToNumberSquares(svg, rotated);
    const counterSelectors = [
      ".color-key-center",
      ".estimated-date-tick",
      ".estimated-date-dot",
      ".target-date-tick",
      ".target-date-marker",
      ".estimation-date-label",
      ".target-date-tick",
      ".target-date-marker"
    ];
    counterSelectors.forEach((sel) => {
      const nodes = svg.querySelectorAll(sel);
      nodes.forEach((node) => {
        const el = node;
        if (!el.closest("#timeline-rotatable")) return;
        const t2 = el.getAttribute("transform") || "";
        const base = t2.replace(/\s*rotate\([^)]*\)/g, "").trim();
        if (rotated) {
          el.setAttribute("transform", `${base} rotate(${angle})`.trim());
        } else {
          el.setAttribute("transform", base);
        }
      });
    });
  };
  applyRotation();
  const clickHandler = (e) => {
    e.stopPropagation();
    if (view.currentMode === "gossamer") {
      return;
    }
    rotated = !rotated;
    view.setRotationState(rotated);
    applyRotation();
  };
  view.registerDomEvent(toggle, "click", clickHandler);
}

// src/view/interactions/SearchInteractions.ts
init_regex();
function cssEscape(value) {
  if (typeof window.CSS !== "undefined" && window.CSS.escape) {
    return window.CSS.escape(value);
  }
  return value.replace(/[^a-zA-Z0-9_\-]/g, "\\$&");
}
function setupSearchControls(view) {
  const clearSearchBtn = view.contentEl.querySelector(".rt-clear-search-btn");
  if (clearSearchBtn) {
    view.registerDomEvent(clearSearchBtn, "click", () => {
      view.plugin.clearSearch();
    });
  }
}
function addHighlightRectangles(view) {
  if (!view.plugin.searchActive) return;
  const searchTerm = view.plugin.searchTerm;
  const escapedPattern = escapeRegExp(searchTerm);
  const svg = view.contentEl.querySelector(".radial-timeline-svg");
  const highlightTspan = (tspan, originalText, fillColor) => {
    while (tspan.firstChild) tspan.removeChild(tspan.firstChild);
    const regex = new RegExp(`(${escapedPattern})`, "gi");
    let lastIndex = 0;
    let match;
    while ((match = regex.exec(originalText)) !== null) {
      if (match.index > lastIndex) {
        tspan.appendChild(document.createTextNode(originalText.substring(lastIndex, match.index)));
      }
      const highlightSpan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      highlightSpan.setAttribute("class", "rt-search-term");
      if (fillColor) highlightSpan.setAttribute("fill", fillColor);
      highlightSpan.textContent = match[0];
      tspan.appendChild(highlightSpan);
      lastIndex = match.index + match[0].length;
    }
    if (lastIndex < originalText.length) {
      tspan.appendChild(document.createTextNode(originalText.substring(lastIndex)));
    }
  };
  view.contentEl.querySelectorAll('tspan[data-item-type="subplot"]').forEach((tspan) => {
    const originalText = tspan.textContent || "";
    if (!originalText || !originalText.match(new RegExp(escapedPattern, "i"))) return;
    const fillColor = tspan.getAttribute("fill");
    highlightTspan(tspan, originalText, fillColor);
  });
  view.contentEl.querySelectorAll('tspan[data-item-type="character"]').forEach((tspan) => {
    const originalText = tspan.textContent || "";
    if (!originalText || !originalText.match(new RegExp(escapedPattern, "i"))) return;
    const fillColor = tspan.getAttribute("fill");
    highlightTspan(tspan, originalText, fillColor);
  });
  view.contentEl.querySelectorAll('tspan[data-item-type="title"]').forEach((tspan) => {
    const originalText = tspan.textContent || "";
    if (!originalText || !originalText.match(new RegExp(escapedPattern, "i"))) return;
    const fillColor = tspan.style.getPropertyValue("--rt-dynamic-color") || null;
    highlightTspan(tspan, originalText, fillColor);
  });
  view.contentEl.querySelectorAll('tspan[data-item-type="date"]').forEach((tspan) => {
    const originalText = tspan.textContent || "";
    if (!originalText || !originalText.match(new RegExp(escapedPattern, "i"))) return;
    const fillColor = tspan.getAttribute("fill");
    highlightTspan(tspan, originalText, fillColor);
  });
  view.contentEl.querySelectorAll('tspan[data-item-type="duration"]').forEach((tspan) => {
    const originalText = tspan.textContent || "";
    if (!originalText || !originalText.match(new RegExp(escapedPattern, "i"))) return;
    const fillColor = tspan.getAttribute("fill");
    highlightTspan(tspan, originalText, fillColor);
  });
  view.contentEl.querySelectorAll("svg .rt-synopsis-text text").forEach((textEl) => {
    if (textEl.querySelector("tspan")) return;
    const originalText = textEl.textContent || "";
    if (!originalText || !originalText.match(new RegExp(escapedPattern, "i"))) return;
    const fillColor = textEl.getAttribute("fill");
    while (textEl.firstChild) textEl.removeChild(textEl.firstChild);
    const regex = new RegExp(`(${escapedPattern})`, "gi");
    let lastIndex = 0;
    let match;
    while ((match = regex.exec(originalText)) !== null) {
      if (match.index > lastIndex) {
        textEl.appendChild(document.createTextNode(originalText.substring(lastIndex, match.index)));
      }
      const highlightSpan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      highlightSpan.setAttribute("class", "rt-search-term");
      if (fillColor) highlightSpan.setAttribute("fill", fillColor);
      highlightSpan.textContent = match[0];
      textEl.appendChild(highlightSpan);
      lastIndex = match.index + match[0].length;
    }
    if (lastIndex < originalText.length) {
      textEl.appendChild(document.createTextNode(originalText.substring(lastIndex)));
    }
  });
  view.contentEl.querySelectorAll("svg .rt-synopsis-text text tspan:not([data-item-type])").forEach((tspan) => {
    const originalText = tspan.textContent || "";
    if (!originalText || !originalText.match(new RegExp(escapedPattern, "i"))) return;
    const fillColor = tspan.getAttribute("fill");
    highlightTspan(tspan, originalText, fillColor);
  });
  if (!svg) {
    return;
  }
  const allSceneGroups = svg.querySelectorAll(".rt-scene-group");
  allSceneGroups.forEach((group) => {
    const pathAttr = group.getAttribute("data-path");
    if (!pathAttr) return;
    if (!view.plugin.searchResults.has(decodeURIComponent(pathAttr))) return;
    const scenePath = group.querySelector(".rt-scene-path");
    const sceneId = scenePath == null ? void 0 : scenePath.id;
    if (!sceneId) return;
    const escapedSceneId = cssEscape(sceneId);
    const numberSquare = svg.querySelector(`.rt-number-square[data-scene-id="${escapedSceneId}"]`);
    const numberText = svg.querySelector(`.rt-number-text[data-scene-id="${escapedSceneId}"]`);
    if (numberSquare) numberSquare.classList.add("rt-search-result");
    if (numberText) numberText.classList.add("rt-search-result");
  });
}

// src/view/interactions/ModeToggleController.ts
init_GossamerCommands();
init_ModeRegistry();
init_LayoutConstants();
function buildModeOptions() {
  return getToggleableModes().map((mode) => ({
    id: mode.id,
    label: mode.name,
    acronym: mode.ui.acronym || mode.name.substring(0, 4).toUpperCase(),
    order: mode.ui.order
  }));
}
var MODE_OPTIONS = buildModeOptions();
var ICON_ACTIVE_SCALE = 1.2;
var ICON_VISUAL_GAP_INACTIVE = 4;
var ICON_VISUAL_GAP_ACTIVE = 15;
function scalePath(pathData, scale) {
  return pathData.replace(/([-\d.]+)/g, (match) => {
    const num = parseFloat(match);
    return isNaN(num) ? match : String(num * scale);
  });
}
var ORIGINAL_DOCUMENT_PATH = "M0.0349451 51.6667C0.0349438 56.1905 1.58191 60 8.89418 60H35.0768C40.5492 60 42.9307 53.5714 42.9651 50C43.0437 41.8254 42.9651 26.291 42.9651 22.8571C42.9651 20.4762 41.431 15.935 35.0768 8.33333C28.7081 0.714286 23.5187 0 21.7359 0H8.05486C2.28955 0 0.0577294 4.28571 0.0349455 8.33333C-0.043681 22.3016 0.0349463 47.8524 0.0349451 51.6667Z";
function createInactiveDocumentShape() {
  return ORIGINAL_DOCUMENT_PATH;
}
function createActiveDocumentShape() {
  return scalePath(ORIGINAL_DOCUMENT_PATH, ICON_ACTIVE_SCALE);
}
function createModeSelectorGrid(view) {
  const grid = document.createElementNS("http://www.w3.org/2000/svg", "g");
  grid.setAttribute("class", "rt-mode-selector-grid");
  grid.setAttribute("id", "mode-selector");
  const spacePerIcon = 43 + ICON_VISUAL_GAP_INACTIVE;
  const totalWidth = MODE_OPTIONS.length * 43 + (MODE_OPTIONS.length - 1) * ICON_VISUAL_GAP_INACTIVE;
  const startX = MODE_SELECTOR_POS_X - totalWidth / 2 + 21.5;
  MODE_OPTIONS.forEach((mode, index) => {
    const x = startX + index * spacePerIcon;
    const optionGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    optionGroup.setAttribute("class", "rt-mode-option");
    optionGroup.setAttribute("data-mode", mode.id);
    optionGroup.setAttribute("transform", `translate(${x}, ${MODE_SELECTOR_POS_Y})`);
    const innerGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    innerGroup.setAttribute("class", "rt-mode-option-content");
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("class", "rt-document-bg");
    path.setAttribute("d", createInactiveDocumentShape());
    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("class", "rt-mode-acronym-text");
    text.setAttribute("x", "21.5");
    text.setAttribute("y", "50");
    text.setAttribute("text-anchor", "middle");
    text.setAttribute("dominant-baseline", "middle");
    text.textContent = mode.acronym;
    const numberLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
    numberLabel.setAttribute("class", "rt-mode-number-label");
    numberLabel.setAttribute("x", "8");
    numberLabel.setAttribute("y", "16");
    numberLabel.setAttribute("text-anchor", "start");
    numberLabel.setAttribute("dominant-baseline", "middle");
    numberLabel.textContent = String(index + 1);
    innerGroup.appendChild(path);
    innerGroup.appendChild(text);
    innerGroup.appendChild(numberLabel);
    optionGroup.appendChild(innerGroup);
    grid.appendChild(optionGroup);
  });
  const showSourcePathAsTitle = view.plugin.settings.showSourcePathAsTitle !== false;
  let bookTitle = "Work in Progress";
  if (showSourcePathAsTitle) {
    const sourcePath = view.plugin.settings.sourcePath || "";
    if (sourcePath) {
      const parts = sourcePath.split("/").filter((p) => p.length > 0);
      bookTitle = parts.length > 0 ? parts[parts.length - 1] : "Work in Progress";
    }
  }
  bookTitle = bookTitle.replace(/\b\w/g, (c) => c.toUpperCase());
  if (bookTitle) {
    const bookTitleText = document.createElementNS("http://www.w3.org/2000/svg", "text");
    bookTitleText.setAttribute("class", "rt-book-title-text");
    bookTitleText.setAttribute("x", String(BOOK_TITLE_POS_X));
    bookTitleText.setAttribute("y", String(BOOK_TITLE_POS_Y));
    bookTitleText.setAttribute("text-anchor", "start");
    bookTitleText.setAttribute("dominant-baseline", "baseline");
    bookTitleText.setAttribute("id", "book-title");
    bookTitleText.textContent = bookTitle;
    grid.appendChild(bookTitleText);
  }
  const titleText = document.createElementNS("http://www.w3.org/2000/svg", "text");
  titleText.setAttribute("class", "rt-mode-title-text");
  titleText.setAttribute("x", String(MODE_TITLE_POS_X));
  titleText.setAttribute("y", String(MODE_TITLE_POS_Y));
  titleText.setAttribute("text-anchor", "start");
  titleText.setAttribute("dominant-baseline", "baseline");
  titleText.setAttribute("id", "mode-title");
  if (MODE_OPTIONS.length > 0) {
    titleText.textContent = MODE_OPTIONS[0].label;
  }
  grid.appendChild(titleText);
  return grid;
}
async function switchToMode(view, modeId, modeSelector) {
  var _a, _b, _c;
  const modeManager = (_a = view.getModeManager) == null ? void 0 : _a.call(view);
  const previousMode = (_c = (_b = modeManager == null ? void 0 : modeManager.getCurrentMode) == null ? void 0 : _b.call(modeManager)) != null ? _c : view.plugin.settings.currentMode;
  updateModeSelectorState(modeSelector, modeId);
  if (modeManager) {
    await modeManager.switchMode(modeId);
    const finalMode = modeManager.getCurrentMode();
    if (finalMode !== modeId) {
      updateModeSelectorState(modeSelector, finalMode);
    }
  } else {
    view.plugin.settings.currentMode = modeId;
    await view.plugin.saveSettings();
    resetGossamerModeState();
    if (typeof view.refreshTimeline === "function") {
      view.refreshTimeline();
    } else {
      view.plugin.refreshTimelineIfNeeded(null);
    }
  }
}
function updateModeSelectorState(modeSelector, currentMode) {
  const activeIndex = MODE_OPTIONS.findIndex((m) => m.id === currentMode);
  let x = MODE_SELECTOR_POS_X;
  const positions = [];
  for (let i = 0; i < MODE_OPTIONS.length; i++) {
    positions.push(x);
    if (i === activeIndex) {
      x += 43 * ICON_ACTIVE_SCALE + ICON_VISUAL_GAP_ACTIVE;
    } else if (i + 1 === activeIndex) {
      x += 43 + ICON_VISUAL_GAP_ACTIVE;
    } else {
      x += 43 + ICON_VISUAL_GAP_INACTIVE;
    }
  }
  const totalWidth = positions[positions.length - 1] + 43 - positions[0];
  const offset = MODE_SELECTOR_POS_X - (positions[0] + positions[positions.length - 1]) / 2;
  MODE_OPTIONS.forEach((mode, index) => {
    const modeElement = modeSelector.querySelector(`[data-mode="${mode.id}"]`);
    if (!modeElement) return;
    const bg = modeElement.querySelector(".rt-document-bg");
    const text = modeElement.querySelector(".rt-mode-acronym-text");
    const numberLabel = modeElement.querySelector(".rt-mode-number-label");
    const finalX = positions[index] + offset;
    if (mode.id === currentMode) {
      modeElement.setAttribute("transform", `translate(${finalX}, ${MODE_SELECTOR_POS_Y})`);
      modeElement.classList.add("rt-mode-current");
      bg.classList.add("rt-active");
      text.classList.add("rt-active");
      if (numberLabel) numberLabel.classList.add("rt-active");
      bg.setAttribute("d", createActiveDocumentShape());
      text.setAttribute("x", String(21.5 * ICON_ACTIVE_SCALE));
      text.setAttribute("y", String(50 * ICON_ACTIVE_SCALE));
      if (numberLabel) {
        numberLabel.setAttribute("x", String(8 * ICON_ACTIVE_SCALE));
        numberLabel.setAttribute("y", String(16 * ICON_ACTIVE_SCALE));
      }
    } else {
      modeElement.setAttribute("transform", `translate(${finalX}, ${MODE_SELECTOR_POS_Y})`);
      modeElement.classList.remove("rt-mode-current");
      bg.classList.remove("rt-active");
      text.classList.remove("rt-active");
      if (numberLabel) numberLabel.classList.remove("rt-active");
      bg.setAttribute("d", createInactiveDocumentShape());
      text.setAttribute("x", "21.5");
      text.setAttribute("y", "50");
      if (numberLabel) {
        numberLabel.setAttribute("x", "8");
        numberLabel.setAttribute("y", "16");
      }
    }
  });
  const titleText = modeSelector.querySelector("#mode-title");
  if (titleText && activeIndex >= 0) {
    titleText.textContent = MODE_OPTIONS[activeIndex].label;
  }
}
function setupModeToggleController(view, svg) {
  const modeSelector = createModeSelectorGrid(view);
  svg.appendChild(modeSelector);
  updateModeSelectorState(modeSelector, view.currentMode || "narrative");
  MODE_OPTIONS.forEach((mode) => {
    const modeElement = modeSelector.querySelector(`[data-mode="${mode.id}"]`);
    if (modeElement) {
      view.registerDomEvent(modeElement, "click", async (e) => {
        e.stopPropagation();
        await switchToMode(view, mode.id, modeSelector);
      });
    }
  });
  const handleKeyPress = async (e) => {
    var _a, _b, _c;
    const activeView = (_c = (_b = (_a = view.app) == null ? void 0 : _a.workspace) == null ? void 0 : _b.activeLeaf) == null ? void 0 : _c.view;
    if (activeView !== view) {
      return;
    }
    const activeEl = document.activeElement;
    if (activeEl) {
      const tag = activeEl.tagName.toUpperCase();
      if (tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT" || activeEl.isContentEditable) {
        return;
      }
    }
    const key = parseInt(e.key);
    if (key >= 1 && key <= 4 && key <= MODE_OPTIONS.length) {
      e.preventDefault();
      const modeId = MODE_OPTIONS[key - 1].id;
      await switchToMode(view, modeId, modeSelector);
    }
  };
  document.addEventListener("keydown", handleKeyPress);
  view.register(() => {
    document.removeEventListener("keydown", handleKeyPress);
  });
  MODE_OPTIONS.forEach((mode) => {
    const modeElement = modeSelector.querySelector(`[data-mode="${mode.id}"]`);
    if (modeElement) {
      view.registerDomEvent(modeElement, "mouseenter", (e) => {
        modeElement.classList.add("rt-mode-hover");
      });
      view.registerDomEvent(modeElement, "mouseleave", (e) => {
        modeElement.classList.remove("rt-mode-hover");
      });
    }
  });
}

// src/view/interactions/index.ts
init_ChronologueShiftController();

// src/services/VersionCheckService.ts
var import_obsidian9 = require("obsidian");
var _VersionCheckService = class _VersionCheckService {
  constructor(currentVersion) {
    this.latestVersion = null;
    this.lastCheckTime = 0;
    this.updateAvailable = false;
    this.currentVersion = currentVersion;
  }
  /**
   * Get the current plugin version from manifest
   */
  getCurrentVersion() {
    return this.currentVersion;
  }
  /**
   * Get the latest available version (if checked)
   */
  getLatestVersion() {
    return this.latestVersion;
  }
  /**
   * Check if an update is available
   */
  isUpdateAvailable() {
    return this.updateAvailable;
  }
  /**
   * Check for updates from GitHub releases
   * Returns true if a newer version is available
   */
  async checkForUpdates(force = false) {
    const now = Date.now();
    if (!force && this.lastCheckTime > 0 && now - this.lastCheckTime < _VersionCheckService.CHECK_INTERVAL_MS) {
      return this.updateAvailable;
    }
    try {
      const response = await (0, import_obsidian9.requestUrl)({
        url: _VersionCheckService.GITHUB_RELEASES_URL,
        headers: {
          "Accept": "application/vnd.github.v3+json",
          "User-Agent": "Obsidian-Radial-Timeline-Plugin"
        }
      });
      if (response.status !== 200) {
        console.warn("[VersionCheck] Failed to fetch latest release:", response.status);
        return false;
      }
      const release = response.json;
      const tagName = release.tag_name;
      this.latestVersion = tagName.startsWith("v") ? tagName.slice(1) : tagName;
      this.lastCheckTime = now;
      this.updateAvailable = this.isNewerVersion(this.latestVersion, this.currentVersion);
      if (this.updateAvailable) {
      }
      return this.updateAvailable;
    } catch (error) {
      console.warn("[VersionCheck] Error checking for updates:", error);
      return false;
    }
  }
  /**
   * Compare two semver versions
   * Returns true if version1 is newer than version2
   */
  isNewerVersion(version1, version2) {
    const v1Parts = version1.split(".").map(Number);
    const v2Parts = version2.split(".").map(Number);
    for (let i = 0; i < Math.max(v1Parts.length, v2Parts.length); i++) {
      const v1 = v1Parts[i] || 0;
      const v2 = v2Parts[i] || 0;
      if (v1 > v2) return true;
      if (v1 < v2) return false;
    }
    return false;
  }
  /**
   * Open Obsidian's community plugins update settings
   */
  openUpdateSettings(app) {
    const setting = app.setting;
    if (setting) {
      setting.open();
      setting.openTabById("community-plugins");
    }
  }
};
_VersionCheckService.GITHUB_RELEASES_URL = "https://api.github.com/repos/EricRhysTaylor/radial-timeline/releases/latest";
_VersionCheckService.CHECK_INTERVAL_MS = 24 * 60 * 60 * 1e3;
var VersionCheckService = _VersionCheckService;
var versionCheckServiceInstance = null;
function getVersionCheckService(currentVersion) {
  if (!versionCheckServiceInstance && currentVersion) {
    versionCheckServiceInstance = new VersionCheckService(currentVersion);
  }
  if (!versionCheckServiceInstance) {
    throw new Error("VersionCheckService not initialized");
  }
  return versionCheckServiceInstance;
}
function initVersionCheckService(currentVersion) {
  versionCheckServiceInstance = new VersionCheckService(currentVersion);
  return versionCheckServiceInstance;
}

// src/view/interactions/VersionIndicatorController.ts
var BUG_REPORT_TEMPLATE = `### Bug Description
<!-- Describe the bug clearly and concisely -->


### Steps to Reproduce
1. 
2. 
3. 

### Expected Behavior
<!-- What should have happened? -->


### Actual Behavior
<!-- What actually happened? -->


### Environment
- Obsidian version: 
- Plugin version: 
- Operating system: 

### Additional Context
<!-- Screenshots, error messages, or other relevant info -->
`;
var BUG_REPORT_URL = `https://github.com/EricRhysTaylor/Radial-Timeline/issues/new?labels=bug&title=${encodeURIComponent("[Bug]: ")}&body=${encodeURIComponent(BUG_REPORT_TEMPLATE)}`;
function setupVersionIndicatorController(view, svg) {
  const versionIndicator = svg.querySelector("#version-indicator");
  if (!versionIndicator) return;
  const hitArea = versionIndicator.querySelector(".rt-version-hitarea");
  const handleClick = (ev) => {
    ev.stopPropagation();
    try {
      const versionService = getVersionCheckService();
      if (versionService.isUpdateAvailable()) {
        versionService.openUpdateSettings(view.plugin.app);
      } else {
        window.open(BUG_REPORT_URL, "_blank");
      }
    } catch (e) {
      window.open(BUG_REPORT_URL, "_blank");
    }
  };
  if (hitArea) {
    view.registerDomEvent(hitArea, "click", handleClick);
  }
  view.registerDomEvent(versionIndicator, "click", handleClick);
  versionIndicator.style.cursor = "pointer";
}

// src/view/interactions/HelpIconController.ts
var WIKI_URL = "https://github.com/EricRhysTaylor/radial-timeline/wiki";
function setupHelpIconController(view, svg) {
  const helpIcon = svg.querySelector("#help-icon");
  if (!helpIcon) return;
  const hitArea = helpIcon.querySelector(".rt-help-icon-hitarea");
  const openWiki = (ev) => {
    ev.stopPropagation();
    window.open(WIKI_URL, "_blank");
  };
  if (hitArea) {
    view.registerDomEvent(hitArea, "click", openWiki);
  }
  const iconGroup = helpIcon.querySelector("g");
  if (iconGroup) {
    view.registerDomEvent(iconGroup, "click", openWiki);
  }
  helpIcon.style.cursor = "pointer";
}

// src/view/interactions/TooltipController.ts
init_tooltip();

// src/view/TimeLineView.ts
init_ChronologueShiftController();

// src/modes/ModeManager.ts
var import_obsidian10 = require("obsidian");
init_ModeDefinition();
init_ModeRegistry();
var ModeManager = class {
  // SAFE: Per-view-instance, managed by view lifecycle
  constructor(plugin, view) {
    this.plugin = plugin;
    this.view = view;
  }
  /**
   * Get the current mode from the view
   */
  getCurrentMode() {
    const currentModeString = this.view.currentMode;
    if (isTimelineMode(currentModeString)) {
      return currentModeString;
    }
    return "narrative" /* NARRATIVE */;
  }
  /**
   * Switch to a new mode
   * Handles lifecycle: exit current  update state  enter new  refresh
   * If the new mode's onEnter hook throws an error, the mode switch is cancelled and reverted.
   */
  async switchMode(newMode) {
    const currentMode = this.getCurrentMode();
    if (currentMode === newMode) {
      return;
    }
    if (newMode === "gossamer" /* GOSSAMER */) {
      const scenes = await this.plugin.getSceneData();
      const beatNotes = scenes.filter((s) => s.itemType === "Beat" || s.itemType === "Plot");
      if (beatNotes.length === 0) {
        new import_obsidian10.Notice('Cannot enter Gossamer mode: No story beats found. Create notes with frontmatter "Class: Beat".');
        return;
      }
    }
    const currentModeDefinition = getModeDefinition(currentMode);
    const newModeDefinition = getModeDefinition(newMode);
    if (currentModeDefinition.onExit) {
      await currentModeDefinition.onExit(this.view);
    }
    this.view.currentMode = newMode;
    this.plugin.settings.currentMode = newMode;
    await this.plugin.saveSettings();
    if (newModeDefinition.onEnter) {
      try {
        await newModeDefinition.onEnter(this.view);
      } catch (error) {
        console.error(`[ModeManager] Failed to enter ${newMode}:`, error);
        this.view.currentMode = currentMode;
        this.plugin.settings.currentMode = currentMode;
        await this.plugin.saveSettings();
        return;
      }
    }
    await this.refreshTimeline();
  }
  /**
   * Toggle to the next mode in the toggle cycle
   * Only cycles through modes that have showInToggleButton = true
   */
  async toggleToNextMode() {
    const currentMode = this.getCurrentMode();
    const { getToggleableModes: getToggleableModes2 } = await Promise.resolve().then(() => (init_ModeRegistry(), ModeRegistry_exports));
    const toggleableModes = getToggleableModes2();
    if (toggleableModes.length === 0) {
      await this.switchMode("narrative" /* NARRATIVE */);
      return;
    }
    const currentIndex = toggleableModes.findIndex((mode) => mode.id === currentMode);
    if (currentIndex === -1) {
      await this.switchMode(toggleableModes[0].id);
      return;
    }
    const nextIndex = (currentIndex + 1) % toggleableModes.length;
    await this.switchMode(toggleableModes[nextIndex].id);
  }
  /**
   * Check if a mode is currently active
   */
  isMode(mode) {
    return this.getCurrentMode() === mode;
  }
  /**
   * Refresh the timeline view
   * Uses the view's refresh method if available, otherwise triggers plugin refresh
   */
  async refreshTimeline() {
    if (typeof this.view.refreshTimeline === "function") {
      await this.view.refreshTimeline();
    } else {
      this.plugin.refreshTimelineIfNeeded(null);
    }
  }
};
function createModeManager(plugin, view) {
  return new ModeManager(plugin, view);
}

// src/modes/ModeInteractionController.ts
init_ModeDefinition();
var ModeInteractionController = class {
  constructor(view) {
    // SAFE: Per-view-instance, managed by view lifecycle
    this.handlers = [];
    this.currentMode = null;
    this.view = view;
  }
  /**
   * Setup interaction handlers for a mode
   * Cleans up previous mode handlers first
   * @param mode - The mode definition to setup
   * @param svg - The SVG element to attach handlers to
   */
  async setupMode(mode, svg) {
    this.cleanup();
    this.currentMode = mode.id;
    switch (mode.id) {
      case "narrative" /* NARRATIVE */:
        await this.setupAllScenesHandlers(svg);
        break;
      case "subplot" /* SUBPLOT */:
        await this.setupMainPlotHandlers(svg);
        break;
      case "gossamer" /* GOSSAMER */:
        await this.setupGossamerHandlers(svg);
        break;
      case "chronologue" /* CHRONOLOGUE */:
        await this.setupChronologueHandlers(svg);
        break;
    }
  }
  /**
   * Clean up all registered handlers
   */
  cleanup() {
    this.handlers.forEach((handler) => {
      try {
        handler.removeFunction();
      } catch (e) {
      }
    });
    this.handlers = [];
    this.currentMode = null;
  }
  /**
   * Register a handler for tracking and cleanup
   */
  registerHandler(element, event, handler, removeFunction) {
    this.handlers.push({
      element,
      event,
      handler,
      removeFunction
    });
  }
  /**
   * Setup handlers for All Scenes mode
   */
  async setupAllScenesHandlers(svg) {
    const { setupAllScenesDelegatedHover: setupAllScenesDelegatedHover2, setupSceneInteractions: setupSceneInteractions2, setupOuterRingDrag: setupOuterRingDrag2 } = await Promise.resolve().then(() => (init_AllScenesMode2(), AllScenesMode_exports));
    const container = this.view.containerEl;
    if (container) {
      setupAllScenesDelegatedHover2(this.view, container, this.view.sceneData || []);
    }
    const sceneGroups = svg.querySelectorAll(".rt-scene-group");
    sceneGroups.forEach((group) => {
      setupSceneInteractions2(this.view, group, svg, this.view.sceneData || []);
    });
    setupOuterRingDrag2(this.view, svg);
  }
  /**
   * Setup handlers for Main Plot mode
   */
  async setupMainPlotHandlers(svg) {
    const { setupMainPlotMode: setupMainPlotMode2 } = await Promise.resolve().then(() => (init_MainPlotMode2(), MainPlotMode_exports));
    setupMainPlotMode2(this.view, svg);
  }
  /**
   * Setup handlers for Gossamer mode
   */
  async setupGossamerHandlers(svg) {
    const { setupGossamerMode: setupGossamerMode2 } = await Promise.resolve().then(() => (init_GossamerMode2(), GossamerMode_exports));
    setupGossamerMode2(this.view, svg);
  }
  /**
   * Setup handlers for Chronologue mode
   */
  async setupChronologueHandlers(svg) {
    const { setupChronologueMode: setupChronologueMode2 } = await Promise.resolve().then(() => (init_ChronologueMode2(), ChronologueMode_exports));
    const viewBox = svg.getAttribute("viewBox");
    let outerRadius = 300;
    if (viewBox) {
      const [, , width, height] = viewBox.split(" ").map(parseFloat);
      const size = Math.min(width, height);
      const margin = 50;
      outerRadius = size / 2 - margin;
    }
    const view = this.view;
    view.scenes = this.view.sceneData || [];
    view.outerRadius = outerRadius;
    setupChronologueMode2(view, svg);
  }
  /**
   * Get the current mode this controller is managing
   */
  getCurrentMode() {
    return this.currentMode;
  }
};
function createInteractionController(view) {
  return new ModeInteractionController(view);
}

// src/view/WelcomeScreen.ts
var import_obsidian22 = require("obsidian");

// src/modals/BookDesignerModal.ts
var import_obsidian21 = require("obsidian");

// src/utils/beatsTemplates.ts
var import_obsidian20 = require("obsidian");
init_beatsSystems();
function getRangeValue(beatInfo) {
  if (beatInfo.range) {
    return beatInfo.range;
  }
  return "";
}
function generatePlotNoteContent(beatInfo, act, beatSystem) {
  const rangeValue = getRangeValue(beatInfo);
  const yamlEscape = (s) => s.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
  const desc = beatInfo.description ? `"${yamlEscape(beatInfo.description)}"` : '""';
  const frontmatter = [
    "---",
    "Class: Beat",
    `Act: ${act}`,
    `Description: ${desc}`,
    `Beat Model: ${beatSystem}`,
    rangeValue ? `Range: ${rangeValue}` : "Range:",
    "When:",
    "Gossamer1:",
    "---",
    ""
  ].join("\n");
  const bodyParts = [];
  if (beatInfo.description) {
    bodyParts.push(beatInfo.description);
  }
  if (beatInfo.placement) {
    bodyParts.push("");
    bodyParts.push(`**Manuscript Position:** ${beatInfo.placement}`);
  }
  const body = bodyParts.length > 0 ? "\n" + bodyParts.join("\n") + "\n" : "";
  return frontmatter + body;
}
function getBeatAct(beatIndex, totalBeats) {
  const position = beatIndex / totalBeats;
  if (position < 0.33) return 1;
  if (position < 0.67) return 2;
  return 3;
}
async function createBeatTemplateNotes(vault, beatSystemName, sourcePath, customSystem) {
  let beatSystem = PLOT_SYSTEMS[beatSystemName];
  if (beatSystemName === "Custom" && customSystem) {
    beatSystem = customSystem;
  }
  if (!beatSystem) {
    throw new Error(`Unknown beat system: ${beatSystemName}`);
  }
  let created = 0;
  let skipped = 0;
  const errors = [];
  const targetFolder = sourcePath.trim() ? (0, import_obsidian20.normalizePath)(sourcePath.trim()) : "";
  if (targetFolder) {
    const folder = vault.getAbstractFileByPath(targetFolder);
    if (!folder) {
      try {
        await vault.createFolder(targetFolder);
      } catch (e) {
      }
    }
  }
  const stripActPrefix = (name) => {
    const m = name.match(/^Act\s*\d+\s*:\s*(.+)$/i);
    return m ? m[1].trim() : name.trim();
  };
  const sanitize = (s) => s.replace(/[\\/:*?"<>|]/g, "-").replace(/\s+/g, " ").trim();
  const beatModelName = beatSystem.name || beatSystemName;
  for (let i = 0; i < beatSystem.beats.length; i++) {
    const beatName = beatSystem.beats[i];
    const beatInfo = beatSystem.beatDetails[i];
    const beatNumber = i + 1;
    const act = beatInfo.act ? beatInfo.act : getBeatAct(i, beatSystem.beats.length);
    const displayName = stripActPrefix(beatName);
    const safeBeatName = sanitize(displayName);
    const filename = `${beatNumber} ${safeBeatName}.md`;
    const filePath = targetFolder ? `${targetFolder}/${filename}` : filename;
    const normalizedPath = (0, import_obsidian20.normalizePath)(filePath);
    const existingFile = vault.getAbstractFileByPath(normalizedPath);
    if (existingFile) {
      skipped++;
      continue;
    }
    const content = generatePlotNoteContent(beatInfo, act, beatModelName);
    try {
      await vault.create(normalizedPath, content);
      created++;
    } catch (error) {
      errors.push(`Failed to create "${filename}": ${error}`);
    }
  }
  return { created, skipped, errors };
}

// src/utils/sceneGenerator.ts
function generateSceneContent(template, data) {
  var _a;
  let content = template;
  content = content.replace(/{{Act}}/g, data.act.toString());
  content = content.replace(/{{When}}/g, data.when);
  content = content.replace(/{{SceneNumber}}/g, data.sceneNumber.toString());
  const yamlEscapeDoubleQuoted = (value) => value.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
  const yamlInlineArray = (values) => `[${values.map((v) => `"${yamlEscapeDoubleQuoted(v)}"`).join(", ")}]`;
  const subplotInline = data.subplots.length <= 1 ? (_a = data.subplots[0]) != null ? _a : "" : yamlInlineArray(data.subplots);
  content = content.replace(/{{Subplot}}/g, subplotInline);
  const subplotListString = data.subplots.map((s) => `  - "${s}"`).join("\n");
  content = content.replace(/{{SubplotList}}/g, subplotListString);
  content = content.replace(/{{Character}}/g, data.character);
  content = content.replace(/{{Place}}/g, data.place);
  const characterListString = (data.characterList && data.characterList.length > 0 ? data.characterList : [data.character].filter(Boolean)).map((c) => `  - "${c}"`).join("\n");
  content = content.replace(/{{CharacterList}}/g, characterListString);
  const placeListString = (data.placeList && data.placeList.length > 0 ? data.placeList : [data.place].filter(Boolean)).map((p) => `  - "${p}"`).join("\n");
  content = content.replace(/{{PlaceList}}/g, placeListString);
  return content;
}

// src/modals/BookDesignerModal.ts
init_date();
init_beatsSystems();
var DEFAULT_SUBPLOTS = "Main Plot\nSubplot A\nSubplot B";
var DEFAULT_CHARACTERS = "Hero\nAntagonist";
var SaveTemplateModal = class extends import_obsidian21.Modal {
  constructor(app, onSave, defaultName) {
    super(app);
    this.descriptionEl = null;
    this.onSave = onSave;
    this.defaultName = defaultName;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("rt-modal-container");
    contentEl.addClass("rt-book-designer-modal");
    const header = contentEl.createDiv({ cls: "rt-modal-header" });
    header.createSpan({ cls: "rt-modal-badge", text: "TEMPLATE" });
    header.createDiv({ cls: "rt-modal-title", text: "Save layout template" });
    header.createDiv({ cls: "rt-modal-subtitle", text: "Name this layout so you can reuse it later." });
    const form = contentEl.createDiv({ cls: "rt-glass-card rt-sub-card" });
    const nameSetting = new import_obsidian21.Setting(form).setName("Template name").setDesc("Choose a short, unique name.").addText((text) => {
      this.nameInput = text;
      text.inputEl.addClass("rt-input-lg");
      text.setPlaceholder("e.g., Thriller / 3-Act Balanced");
      text.setValue(this.defaultName);
      text.inputEl.addEventListener("keydown", (evt) => {
        if (evt.key === "Enter") {
          evt.preventDefault();
          this.handleSave();
        }
      });
    });
    nameSetting.settingEl.addClass("rt-manuscript-group-setting");
    this.descriptionEl = form.createDiv({ cls: "rt-sub-card-note", text: "Templates capture layout, acts, subplots, characters, beats toggle, and the selected YAML type (base/advanced)." });
    const footer = contentEl.createDiv({ cls: "rt-modal-actions" });
    new import_obsidian21.ButtonComponent(footer).setButtonText("Save").setCta().onClick(() => this.handleSave());
    new import_obsidian21.ButtonComponent(footer).setButtonText("Cancel").onClick(() => this.close());
    footer.querySelectorAll("button").forEach((btn) => {
      btn.style.cursor = "pointer";
    });
  }
  handleSave() {
    const name = this.nameInput.getValue().trim();
    if (!name) {
      new import_obsidian21.Notice("Template name is required.");
      return;
    }
    this.onSave(name);
    this.close();
  }
};
var DeleteTemplateModal = class extends import_obsidian21.Modal {
  constructor(app, templateName, onConfirm) {
    super(app);
    this.templateName = templateName;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("rt-modal-container");
    contentEl.addClass("rt-book-designer-modal");
    const header = contentEl.createDiv({ cls: "rt-modal-header" });
    header.createSpan({ cls: "rt-modal-badge", text: "TEMPLATE" });
    header.createDiv({ cls: "rt-modal-title", text: "Delete template" });
    header.createDiv({ cls: "rt-modal-subtitle", text: `Delete "${this.templateName}"? This cannot be undone.` });
    const footer = contentEl.createDiv({ cls: "rt-modal-actions" });
    new import_obsidian21.ButtonComponent(footer).setButtonText("Delete").setCta().onClick(() => {
      this.onConfirm();
      this.close();
    });
    new import_obsidian21.ButtonComponent(footer).setButtonText("Cancel").onClick(() => this.close());
    footer.querySelectorAll("button").forEach((btn) => {
      btn.style.cursor = "pointer";
    });
  }
};
var BookDesignerModal = class extends import_obsidian21.Modal {
  constructor(app, plugin) {
    super(app);
    // Form values
    this.timeIncrement = "1 day";
    this.scenesToGenerate = 1;
    this.targetRangeMax = 60;
    this.selectedActs = [1, 2, 3];
    this.subplots = DEFAULT_SUBPLOTS;
    this.character = DEFAULT_CHARACTERS;
    this.generateBeats = false;
    // Preview
    this.previewHostEl = null;
    this.previewUpdateRaf = null;
    this.previewStatusEl = null;
    this.heroLocationMeta = null;
    this.heroModeMeta = null;
    // Layout + templates
    this.sceneAssignments = [];
    this.activeTemplateId = null;
    this.isApplyingTemplate = false;
    // Drag state
    this.dragState = null;
    // Input refs for template/application updates
    this.timeIncrementInput = null;
    this.scenesInput = null;
    this.targetRangeInput = null;
    this.subplotsInput = null;
    this.characterInput = null;
    this.templateDropdown = null;
    this.actCheckboxes = [];
    this.templateTypePills = [];
    this.beatPills = [];
    this.deleteTemplateBtn = null;
    this.plugin = plugin;
    this.templateType = "base";
    this.distributionMode = "auto";
  }
  getMaxActs() {
    const fromSettings = this.plugin.settings.actCount;
    const parsed = typeof fromSettings === "number" ? Math.floor(fromSettings) : 3;
    return Math.min(10, Math.max(3, parsed));
  }
  normalizeSelectedActs(maxActs) {
    const unique = Array.from(new Set(this.selectedActs)).filter((a) => a >= 1 && a <= maxActs);
    if (unique.length > 0) return unique.sort((a, b) => a - b);
    return [1, 2, 3].filter((a) => a <= maxActs);
  }
  resetManualLayout() {
    this.distributionMode = "auto";
    this.activeTemplateId = null;
    this.sceneAssignments = this.rebuildAutoAssignments();
    this.dragState = null;
    this.updateDistributionStatus();
  }
  resetAllDefaults() {
    const maxActs = this.getMaxActs();
    this.timeIncrement = "1 day";
    this.scenesToGenerate = 1;
    this.targetRangeMax = 60;
    this.selectedActs = Array.from({ length: maxActs }, (_, i) => i + 1);
    this.subplots = DEFAULT_SUBPLOTS;
    this.character = DEFAULT_CHARACTERS;
    this.templateType = "base";
    this.generateBeats = false;
    this.activeTemplateId = null;
    this.distributionMode = "auto";
    this.sceneAssignments = this.rebuildAutoAssignments();
    if (this.timeIncrementInput) this.timeIncrementInput.setValue(this.timeIncrement);
    if (this.scenesInput) this.scenesInput.setValue(this.scenesToGenerate.toString());
    if (this.targetRangeInput) this.targetRangeInput.setValue(this.targetRangeMax.toString());
    if (this.subplotsInput) this.subplotsInput.setValue(this.subplots);
    if (this.characterInput) this.characterInput.setValue(this.character);
    this.actCheckboxes.forEach((input, idx) => {
      const actNum = idx + 1;
      input.checked = this.selectedActs.includes(actNum);
    });
    this.templateTypePills.forEach((pill) => {
      const id = pill.getAttr("data-template-id");
      if (!id) return;
      if (id === this.templateType) pill.addClass("rt-is-active");
      else pill.removeClass("rt-is-active");
    });
    this.beatPills.forEach((pill) => {
      const val = pill.getAttr("data-generate-beats") === "true";
      if (val === this.generateBeats) pill.addClass("rt-is-active");
      else pill.removeClass("rt-is-active");
    });
    if (this.templateDropdown) this.templateDropdown.value = "";
    this.refreshTemplateDropdown();
    this.updateDistributionStatus();
    this.schedulePreviewUpdate();
  }
  markManualLayout() {
    this.distributionMode = "manual";
    this.activeTemplateId = null;
    this.updateDistributionStatus();
  }
  rebuildAutoAssignments() {
    var _a;
    const scenes = Math.max(1, Math.floor(this.scenesToGenerate || 1));
    const actsList = this.getActsListSorted();
    const subplotList = this.parseSubplots();
    const buckets = actsList.map(() => []);
    const baseSize = Math.floor(scenes / actsList.length);
    const rem = scenes % actsList.length;
    const sizes = actsList.map(() => baseSize);
    if (baseSize === 0) {
      let r = rem;
      let idx = 0;
      while (r > 0 && idx < sizes.length) {
        sizes[idx] += 1;
        r -= 1;
        idx += 1;
      }
    } else if (actsList.length === 3 && baseSize === 1 && rem === 2) {
      sizes[0] = 2;
      sizes[1] = 2;
      sizes[2] = 1;
    } else {
      sizes[sizes.length - 1] += rem;
    }
    let actCursor = 0;
    let remainingInAct = (_a = sizes[0]) != null ? _a : scenes;
    for (let i = 1; i <= scenes; i++) {
      buckets[actCursor].push(i);
      remainingInAct -= 1;
      if (remainingInAct === 0 && actCursor < actsList.length - 1) {
        actCursor += 1;
        remainingInAct = sizes[actCursor];
      }
    }
    const assignments = [];
    buckets.forEach((sceneNums, idx) => {
      const actNumber = actsList[idx];
      sceneNums.forEach((sceneNum) => {
        const subplotIndex = (sceneNum - 1) % subplotList.length;
        assignments.push({
          sceneNumber: sceneNum,
          act: actNumber,
          subplotIndex
        });
      });
    });
    return assignments.sort((a, b) => a.sceneNumber - b.sceneNumber);
  }
  getWorkingAssignments() {
    const scenes = Math.max(1, Math.floor(this.scenesToGenerate || 1));
    if (this.distributionMode === "manual" && this.sceneAssignments.length === scenes) {
      return this.sceneAssignments;
    }
    this.sceneAssignments = this.rebuildAutoAssignments();
    this.distributionMode = "auto";
    this.updateDistributionStatus();
    return this.sceneAssignments;
  }
  coerceAssignments(assignments, subplotCount, actsList) {
    const scenes = Math.max(1, Math.floor(this.scenesToGenerate || 1));
    const auto = this.rebuildAutoAssignments();
    const actSet = new Set(actsList);
    const maxSubplot = Math.max(0, subplotCount - 1);
    return Array.from({ length: scenes }, (_, idx) => {
      var _a, _b;
      const sceneNum = idx + 1;
      const incoming = assignments.find((a) => a.sceneNumber === sceneNum);
      const fallback = (_b = auto[idx]) != null ? _b : {
        sceneNumber: sceneNum,
        act: (_a = actsList[0]) != null ? _a : 1,
        subplotIndex: 0
      };
      if (!incoming) return fallback;
      const act = actSet.has(incoming.act) ? incoming.act : fallback.act;
      const subplotIndex = incoming.subplotIndex >= 0 && incoming.subplotIndex <= maxSubplot ? incoming.subplotIndex : Math.min(fallback.subplotIndex, maxSubplot);
      return { sceneNumber: sceneNum, act, subplotIndex };
    });
  }
  getTemplateList() {
    const list = this.plugin.settings.bookDesignerTemplates;
    if (Array.isArray(list)) return list;
    return [];
  }
  getCurrentTemplateSelection() {
    if (!this.templateDropdown) return null;
    const val = this.templateDropdown.value;
    return val && val.trim().length > 0 ? val : null;
  }
  async persistTemplateList(list) {
    this.plugin.settings.bookDesignerTemplates = list;
    await this.plugin.saveSettings();
  }
  updateHeroMeta() {
    if (this.heroLocationMeta) {
      const sourcePath = this.plugin.settings.sourcePath || "vault root";
      this.heroLocationMeta.setText(`Location: ${sourcePath}`);
    }
    if (this.heroModeMeta) {
      const modeLabel = this.distributionMode === "manual" ? "Manual mode" : "Auto mode";
      this.heroModeMeta.setText(modeLabel);
      this.heroModeMeta.toggleClass("rt-meta-auto", this.distributionMode !== "manual");
      this.heroModeMeta.toggleClass("rt-meta-manual", this.distributionMode === "manual");
    }
  }
  updateDistributionStatus() {
    const mode = this.distributionMode === "manual" ? "Manual layout active" : "Auto distribution";
    const templatePart = this.activeTemplateId ? " \xB7 From template" : "";
    if (this.previewStatusEl) {
      this.previewStatusEl.setText(`\u2014 ${mode}${templatePart}`);
    }
    this.updateHeroMeta();
  }
  refreshTemplateDropdown() {
    var _a;
    if (!this.templateDropdown) return;
    const selectEl = this.templateDropdown;
    selectEl.empty();
    const templates = this.getTemplateList();
    const hasTemplates = templates.length > 0;
    const placeholder = document.createElement("option");
    placeholder.value = "";
    placeholder.text = hasTemplates ? "New template" : "\u2014";
    placeholder.disabled = false;
    placeholder.selected = !this.activeTemplateId;
    selectEl.appendChild(placeholder);
    templates.forEach((t2) => {
      const opt = document.createElement("option");
      opt.value = t2.id;
      opt.text = t2.name;
      if (this.activeTemplateId && this.activeTemplateId === t2.id) {
        opt.selected = true;
        placeholder.selected = false;
      }
      selectEl.appendChild(opt);
    });
    selectEl.disabled = false;
    selectEl.value = (_a = this.activeTemplateId) != null ? _a : "";
    if (this.deleteTemplateBtn) {
      const hasSelection = !!this.getCurrentTemplateSelection();
      this.deleteTemplateBtn.setDisabled(!hasTemplates || !hasSelection);
    }
  }
  async deleteTemplate(templateId) {
    const templates = this.getTemplateList().filter((t2) => t2.id !== templateId);
    await this.persistTemplateList(templates);
    if (this.activeTemplateId === templateId) {
      this.activeTemplateId = null;
    }
    if (this.templateDropdown) {
      this.templateDropdown.value = "";
    }
    this.resetManualLayout();
    this.refreshTemplateDropdown();
    this.schedulePreviewUpdate();
    new import_obsidian21.Notice("Template deleted.");
  }
  async saveOrUpdateTemplate() {
    const selectedId = this.getCurrentTemplateSelection();
    if (selectedId) {
      const tpl = this.getTemplateList().find((t2) => t2.id === selectedId);
      if (!tpl) return;
      await this.saveTemplate(tpl.name, selectedId);
      return;
    }
    const defaultName = `Layout ${this.templateType === "base" ? "Basic" : "Advanced"} ${(/* @__PURE__ */ new Date()).toLocaleDateString()}`;
    new SaveTemplateModal(this.app, (name) => {
      void this.saveTemplate(name);
    }, defaultName).open();
  }
  async saveTemplate(name, existingId) {
    const subplotList = this.parseSubplots();
    const characters = this.character.split("\n").map((c) => c.trim()).filter(Boolean);
    const assignments = this.getWorkingAssignments();
    const template = {
      id: existingId != null ? existingId : `${Date.now()}`,
      name,
      templateType: this.templateType,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      scenesToGenerate: this.scenesToGenerate,
      targetRangeMax: this.targetRangeMax,
      timeIncrement: this.timeIncrement,
      selectedActs: [...this.selectedActs],
      subplots: subplotList,
      characters,
      generateBeats: this.generateBeats,
      assignments: assignments.map((a) => ({ ...a }))
    };
    const existing = this.getTemplateList();
    const filtered = existing.filter((t2) => t2.id !== template.id);
    filtered.unshift(template);
    await this.persistTemplateList(filtered);
    this.activeTemplateId = template.id;
    this.refreshTemplateDropdown();
    this.updateDistributionStatus();
    new import_obsidian21.Notice(`Template "${name}" ${existingId ? "updated" : "saved"}.`);
  }
  applyTemplateById(templateId) {
    const tpl = this.getTemplateList().find((t2) => t2.id === templateId);
    if (!tpl) {
      new import_obsidian21.Notice("Template not found.");
      return;
    }
    this.applyTemplate(tpl);
  }
  applyTemplate(template) {
    this.isApplyingTemplate = true;
    this.templateType = template.templateType;
    this.scenesToGenerate = template.scenesToGenerate;
    this.targetRangeMax = template.targetRangeMax;
    this.timeIncrement = template.timeIncrement;
    this.selectedActs = [...template.selectedActs];
    this.subplots = template.subplots.join("\n") || "Main Plot";
    this.character = template.characters.join("\n") || "Hero";
    this.generateBeats = template.generateBeats;
    const subplotCount = Math.max(1, template.subplots.length || this.parseSubplots().length);
    const coerced = this.coerceAssignments(template.assignments, subplotCount, this.selectedActs);
    this.sceneAssignments = coerced;
    this.distributionMode = "manual";
    this.activeTemplateId = template.id;
    this.isApplyingTemplate = false;
    this.syncUiFromState();
    this.updateDistributionStatus();
    this.schedulePreviewUpdate();
    new import_obsidian21.Notice(`Applied template "${template.name}".`);
  }
  syncUiFromState() {
    if (this.timeIncrementInput) this.timeIncrementInput.setValue(this.timeIncrement);
    if (this.scenesInput) this.scenesInput.setValue(this.scenesToGenerate.toString());
    if (this.targetRangeInput) this.targetRangeInput.setValue(this.targetRangeMax.toString());
    if (this.subplotsInput) this.subplotsInput.setValue(this.subplots);
    if (this.characterInput) this.characterInput.setValue(this.character);
    const maxActs = this.getMaxActs();
    this.selectedActs = this.normalizeSelectedActs(maxActs);
    this.actCheckboxes.forEach((input, idx) => {
      const actNum = idx + 1;
      input.checked = this.selectedActs.includes(actNum);
    });
    this.templateTypePills.forEach((pill) => {
      const id = pill.getAttr("data-template-id");
      if (!id) return;
      if (id === this.templateType) pill.addClass("rt-is-active");
      else pill.removeClass("rt-is-active");
    });
    this.beatPills.forEach((pill) => {
      const val = pill.getAttr("data-generate-beats") === "true";
      if (val === this.generateBeats) pill.addClass("rt-is-active");
      else pill.removeClass("rt-is-active");
    });
    this.refreshTemplateDropdown();
  }
  onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.empty();
    const maxActs = this.getMaxActs();
    this.selectedActs = Array.from({ length: maxActs }, (_, i) => i + 1);
    this.sceneAssignments = this.rebuildAutoAssignments();
    this.distributionMode = "auto";
    this.activeTemplateId = null;
    this.actCheckboxes = [];
    this.templateTypePills = [];
    this.beatPills = [];
    this.heroLocationMeta = null;
    this.heroModeMeta = null;
    if (modalEl) {
      modalEl.classList.add("rt-modal-shell");
      modalEl.style.width = "860px";
      modalEl.style.maxWidth = "96vw";
      modalEl.style.maxHeight = "92vh";
    }
    contentEl.addClass("rt-modal-container");
    contentEl.addClass("rt-book-designer-modal");
    contentEl.addClass("rt-manuscript-surface");
    const sourcePath = this.plugin.settings.sourcePath || "vault root";
    const hero = contentEl.createDiv({ cls: "rt-modal-header" });
    hero.createSpan({ cls: "rt-modal-badge", text: "SETUP" });
    hero.createDiv({ cls: "rt-modal-title", text: "Book designer" });
    hero.createDiv({ cls: "rt-modal-subtitle", text: `Configure and generate the scaffold for your new novel. Drag scenes in Preview to different acts and subplots to activate manual mode. Save the template to reuse it later.` });
    const heroMeta = hero.createDiv({ cls: "rt-modal-meta" });
    this.heroLocationMeta = heroMeta.createSpan({ cls: "rt-modal-meta-item", text: `Location: ${sourcePath}` });
    this.heroModeMeta = heroMeta.createSpan({ cls: "rt-modal-meta-item rt-meta-auto", text: "Auto mode" });
    this.updateHeroMeta();
    const scrollContainer = contentEl.createDiv({ cls: "rt-container rt-card-stack" });
    const structCard = scrollContainer.createDiv({ cls: "rt-glass-card rt-sub-card" });
    structCard.createDiv({ cls: "rt-sub-card-head", text: "Location & Structure" });
    new import_obsidian21.Setting(structCard).setName("Date increment per scene").setDesc("Timeline increment across scenes (e.g. 1 hour, 1 day, 1 week).").addText((text) => {
      this.timeIncrementInput = text;
      text.setValue(this.timeIncrement).setPlaceholder("1 day");
      text.inputEl.addClass("rt-input-sm");
      text.inputEl.addEventListener("blur", () => {
        const raw = text.getValue().trim();
        text.inputEl.removeClass("rt-input-flash-success");
        text.inputEl.removeClass("rt-input-flash-error");
        void text.inputEl.offsetWidth;
        if (!raw) {
          this.timeIncrement = "1 day";
          text.setValue("1 day");
          text.inputEl.addClass("rt-input-flash-success");
          return;
        }
        const valid = parseDurationDetail(raw);
        if (valid) {
          this.timeIncrement = raw;
          text.inputEl.addClass("rt-input-flash-success");
        } else {
          new import_obsidian21.Notice(`Invalid duration: "${raw}". Reverting to ${this.timeIncrement}.`);
          text.setValue(this.timeIncrement);
          text.inputEl.addClass("rt-input-flash-error");
        }
      });
    });
    const countsGroup = structCard.createDiv({ cls: "rt-manuscript-card-block rt-manuscript-group-block" });
    const countsGrid = countsGroup.createDiv({ cls: "rt-manuscript-duo-grid" });
    let lengthSettingRef;
    const scenesSetting = new import_obsidian21.Setting(countsGrid).setName("Scenes to generate").setDesc("Number of template scene files to create with YAML frontmatter.").addText((text) => {
      this.scenesInput = text;
      text.setValue(this.scenesToGenerate.toString()).onChange((value) => {
        const parsed = parseInt(value);
        if (!isNaN(parsed) && parsed > 0) {
          this.scenesToGenerate = parsed;
          if (lengthSettingRef) this.updateTargetDesc(lengthSettingRef);
          if (!this.isApplyingTemplate) this.resetManualLayout();
          this.schedulePreviewUpdate();
        }
      });
      text.inputEl.addClass("rt-input-xs");
    });
    scenesSetting.settingEl.addClass("rt-manuscript-group-setting");
    scenesSetting.settingEl.addClass("rt-scenes-generate-setting");
    const lengthSetting = new import_obsidian21.Setting(countsGrid).setName("Target book length").setDesc("Used for numbering distribution (e.g. 10, 20, 30...)").addText((text) => {
      this.targetRangeInput = text;
      text.setValue(this.targetRangeMax.toString()).onChange((value) => {
        const parsed = parseInt(value);
        if (!isNaN(parsed) && parsed > 0) {
          this.targetRangeMax = parsed;
          if (lengthSettingRef) this.updateTargetDesc(lengthSettingRef);
          this.schedulePreviewUpdate();
        }
      });
      text.inputEl.addClass("rt-input-xs");
    });
    lengthSetting.settingEl.addClass("rt-manuscript-group-setting");
    lengthSetting.settingEl.addClass("rt-book-length-setting");
    lengthSettingRef = lengthSetting;
    this.updateTargetDesc(lengthSetting);
    const actSetting = structCard.createDiv({ cls: "rt-manuscript-setting-row rt-manuscript-card-block rt-manuscript-acts-row" });
    actSetting.createDiv({ cls: "rt-manuscript-setting-label", text: "Acts to distribute scenes across" });
    const actChecks = actSetting.createDiv({ cls: "rt-manuscript-checkbox-row" });
    actChecks.style.flexWrap = "wrap";
    const actCountForUi = this.getMaxActs();
    Array.from({ length: actCountForUi }, (_, i) => i + 1).forEach((num) => {
      const item = actChecks.createDiv({ cls: "rt-manuscript-checkbox-item" });
      const input = item.createEl("input", { type: "checkbox" });
      input.checked = this.selectedActs.includes(num);
      this.actCheckboxes.push(input);
      input.onchange = () => {
        if (input.checked) {
          if (!this.selectedActs.includes(num)) this.selectedActs.push(num);
        } else {
          this.selectedActs = this.selectedActs.filter((a) => a !== num);
        }
        if (this.selectedActs.length === 0) {
          this.selectedActs = [num];
          input.checked = true;
        }
        this.selectedActs = this.normalizeSelectedActs(actCountForUi);
        if (!this.isApplyingTemplate) this.resetManualLayout();
        this.schedulePreviewUpdate();
      };
      const label = item.createEl("label");
      label.setText(`Act ${num}`);
      label.onclick = () => {
        input.click();
      };
    });
    const contentCard = scrollContainer.createDiv({ cls: "rt-glass-card rt-sub-card" });
    contentCard.createDiv({ cls: "rt-sub-card-head", text: "Content Configuration" });
    const contentGroup = contentCard.createDiv({ cls: "rt-manuscript-card-block rt-manuscript-group-block rt-manuscript-content-grid" });
    const leftCol = contentGroup.createDiv({ cls: "rt-manuscript-content-left" });
    const subplotsSetting = new import_obsidian21.Setting(leftCol).setName("Subplots").setDesc("Enter one subplot per line.").setClass("rt-setting-stacked").addTextArea((text) => {
      this.subplotsInput = text;
      text.setValue(this.subplots).onChange((value) => {
        this.subplots = value;
        if (!this.isApplyingTemplate) this.resetManualLayout();
        this.schedulePreviewUpdate();
      });
      text.inputEl.rows = 4;
      text.inputEl.classList.add("rt-manuscript-textarea");
      text.inputEl.addEventListener("blur", () => {
        const trimmed = this.subplots.split("\n").map((s) => s.trim()).filter(Boolean);
        if (trimmed.length === 0) {
          this.subplots = "Main Plot";
          text.setValue(this.subplots);
          this.schedulePreviewUpdate();
        }
      });
    });
    subplotsSetting.settingEl.addClass("rt-manuscript-group-setting");
    const characterSetting = new import_obsidian21.Setting(leftCol).setName("Characters").setDesc("Enter one character per line.").setClass("rt-setting-stacked").addTextArea((text) => {
      this.characterInput = text;
      text.setValue(this.character).onChange((value) => this.character = value);
      text.inputEl.rows = 4;
      text.inputEl.classList.add("rt-manuscript-textarea");
      text.inputEl.addEventListener("blur", () => {
        const trimmed = this.character.split("\n").map((s) => s.trim()).filter(Boolean);
        if (trimmed.length === 0) {
          this.character = "Hero";
          text.setValue(this.character);
          this.schedulePreviewUpdate();
        }
      });
    });
    characterSetting.settingEl.addClass("rt-manuscript-group-setting");
    const previewCol = contentGroup.createDiv({ cls: "rt-manuscript-preview-col rt-manuscript-preview-col-wide" });
    const previewHeader = previewCol.createDiv({ cls: "rt-manuscript-preview-head" });
    previewHeader.createDiv({ cls: "rt-manuscript-preview-title", text: "Preview" });
    this.previewStatusEl = previewHeader.createDiv({ cls: "rt-manuscript-preview-status", text: "Auto distribution" });
    this.previewHostEl = previewCol.createDiv({ cls: "rt-manuscript-preview-host" });
    this.updateDistributionStatus();
    this.schedulePreviewUpdate();
    const extraCard = scrollContainer.createDiv({ cls: "rt-glass-card rt-sub-card" });
    extraCard.createDiv({ cls: "rt-sub-card-head", text: "Templates & Extras" });
    const extraRow = extraCard.createDiv({ cls: "rt-manuscript-duo-row" });
    const templSetting = extraRow.createDiv({ cls: "rt-manuscript-setting-row rt-manuscript-card-block" });
    templSetting.createDiv({ cls: "rt-manuscript-setting-label", text: "Scene template" });
    const templPills = templSetting.createDiv({ cls: "rt-manuscript-pill-row" });
    const options = [
      { id: "base", label: "Base (Minimal)" },
      { id: "advanced", label: "Advanced" }
    ];
    options.forEach((opt) => {
      const pill = templPills.createDiv({ cls: "rt-manuscript-pill" });
      pill.setText(opt.label);
      if (this.templateType === opt.id) pill.addClass("rt-is-active");
      pill.setAttr("data-template-id", opt.id);
      this.templateTypePills.push(pill);
      pill.onclick = () => {
        templPills.querySelectorAll(".rt-manuscript-pill").forEach((p) => p.removeClass("rt-is-active"));
        pill.addClass("rt-is-active");
        this.templateType = opt.id;
      };
    });
    const beatSystem = this.plugin.settings.beatSystem || "Custom";
    const beatLabel = beatSystem === "Custom" ? "custom beats" : `${beatSystem} beats`;
    const beatSetting = extraRow.createDiv({ cls: "rt-manuscript-setting-row rt-manuscript-card-block" });
    beatSetting.createDiv({ cls: "rt-manuscript-setting-label", text: `Generate ${beatLabel}` });
    const beatPills = beatSetting.createDiv({ cls: "rt-manuscript-pill-row" });
    const beatOptions = [{ val: false, label: "No" }, { val: true, label: "Yes" }];
    beatOptions.forEach((opt) => {
      const pill = beatPills.createDiv({ cls: "rt-manuscript-pill" });
      pill.setText(opt.label);
      if (this.generateBeats === opt.val) pill.addClass("rt-is-active");
      pill.setAttr("data-generate-beats", String(opt.val));
      this.beatPills.push(pill);
      pill.onclick = () => {
        beatPills.querySelectorAll(".rt-manuscript-pill").forEach((p) => p.removeClass("rt-is-active"));
        pill.addClass("rt-is-active");
        this.generateBeats = opt.val;
      };
    });
    const templateCard = extraCard.createDiv({ cls: "rt-manuscript-card-block rt-manuscript-group-block rt-layout-templates-card" });
    const templateSetting = new import_obsidian21.Setting(templateCard).setName("Layout templates").setDesc("Select a saved layout (acts, subplots, assignments, metadata).").addDropdown((drop) => {
      this.templateDropdown = drop.selectEl;
      this.refreshTemplateDropdown();
      drop.onChange((value) => {
        if (!value) {
          this.activeTemplateId = null;
          if (this.deleteTemplateBtn) this.deleteTemplateBtn.setDisabled(true);
          this.updateDistributionStatus();
          return;
        }
        this.applyTemplateById(value);
      });
    });
    templateSetting.settingEl.addClass("rt-manuscript-group-setting");
    const templateActions = templateCard.createDiv({ cls: "rt-template-actions" });
    new import_obsidian21.ButtonComponent(templateActions).setButtonText("Save / Update template").onClick(() => {
      void this.saveOrUpdateTemplate();
    });
    new import_obsidian21.ButtonComponent(templateActions).setButtonText("Reset").onClick(() => {
      this.resetAllDefaults();
      new import_obsidian21.Notice("Layout reset to defaults with auto distribution.");
    });
    this.deleteTemplateBtn = new import_obsidian21.ButtonComponent(templateActions).setButtonText("Delete template").setDisabled(true).setWarning().onClick(() => {
      const selectedId = this.getCurrentTemplateSelection();
      if (!selectedId) return;
      const tpl = this.getTemplateList().find((t2) => t2.id === selectedId);
      if (!tpl) return;
      new DeleteTemplateModal(this.app, tpl.name, () => {
        this.deleteTemplate(selectedId);
      }).open();
    });
    this.deleteTemplateBtn.buttonEl.addClass("rt-template-delete");
    const footer = contentEl.createDiv({ cls: "rt-modal-actions" });
    new import_obsidian21.ButtonComponent(footer).setButtonText("Create Book").setCta().onClick(() => {
      this.close();
      this.generateBook();
    });
    new import_obsidian21.ButtonComponent(footer).setButtonText("Cancel").onClick(() => this.close());
    footer.querySelectorAll("button").forEach((btn) => {
      btn.style.cursor = "pointer";
    });
  }
  updateTargetDesc(setting) {
    const scenes = this.scenesToGenerate;
    const max = this.targetRangeMax;
    let examples = [];
    if (scenes <= 1) examples = [1];
    else if (scenes <= 3) {
      for (let i = 1; i <= scenes; i++) {
        const step = (max - 1) / (scenes - 1);
        examples.push(Math.round(1 + (i - 1) * step));
      }
    } else {
      for (let i = 1; i <= 3; i++) {
        const step = (max - 1) / (scenes - 1);
        examples.push(Math.round(1 + (i - 1) * step));
      }
    }
    const suffix = scenes > 3 ? "..." : "";
    setting.setDesc(`Scenes will be numbered: ${examples.join(", ")}${suffix} based on ${scenes} scenes across ${max} units.`);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.previewHostEl = null;
    this.heroLocationMeta = null;
    this.heroModeMeta = null;
    if (this.previewUpdateRaf !== null) {
      window.cancelAnimationFrame(this.previewUpdateRaf);
      this.previewUpdateRaf = null;
    }
  }
  schedulePreviewUpdate() {
    if (!this.previewHostEl) return;
    if (this.previewUpdateRaf !== null) window.cancelAnimationFrame(this.previewUpdateRaf);
    this.previewUpdateRaf = window.requestAnimationFrame(() => {
      this.previewUpdateRaf = null;
      this.renderPreview();
    });
  }
  parseSubplots() {
    const list = this.subplots.split("\n").map((s) => s.trim()).filter(Boolean);
    return list.length > 0 ? list : ["Main Plot"];
  }
  getActsListSorted() {
    const maxActs = this.getMaxActs();
    const acts = (this.selectedActs.length > 0 ? [...this.selectedActs] : [1]).map((a) => Math.max(1, Math.min(maxActs, a))).sort((a, b) => a - b);
    return Array.from(new Set(acts));
  }
  subplotColor(index, total) {
    if (total <= 1) return "var(--interactive-accent)";
    const hue = index * 137.508 % 360;
    const sat = 62;
    const light = 56;
    return `hsl(${hue}deg ${sat}% ${light}%)`;
  }
  renderPreview() {
    if (!this.previewHostEl) return;
    this.previewHostEl.empty();
    const subplotList = this.parseSubplots();
    const actsList = this.getActsListSorted();
    const totalActs = this.getMaxActs();
    const assignments = this.getWorkingAssignments();
    const size = 260;
    const outerR = 116;
    const innerR = 52;
    const cx = size / 2;
    const cy = size / 2;
    const svg = this.previewHostEl.createSvg("svg");
    svg.addClass("rt-manuscript-preview-svg");
    svg.setAttr("viewBox", `0 0 ${size} ${size}`);
    svg.setAttr("preserveAspectRatio", "xMidYMid meet");
    svg.setAttr("width", "100%");
    svg.setAttr("height", "100%");
    const subplotCount = Math.max(1, subplotList.length);
    const ringWidth = (outerR - innerR) / subplotCount;
    const dims = { cx, cy, outerR, innerR, subplotCount, totalActs, ringWidth };
    const ringColor = this.distributionMode === "manual" ? "rgba(255, 165, 0, 0.35)" : "rgba(255, 255, 255, 0.10)";
    for (let i = 0; i <= subplotCount; i++) {
      const r = outerR - i * ringWidth;
      const guide = svg.createSvg("circle");
      guide.setAttr("cx", `${cx}`);
      guide.setAttr("cy", `${cy}`);
      guide.setAttr("r", `${r}`);
      guide.setAttr("stroke", ringColor);
      guide.style.setProperty("stroke", ringColor);
      guide.addClass("rt-manuscript-preview-guide");
    }
    const actAngles = Array.from({ length: totalActs }, (_, idx) => -Math.PI / 2 + idx * 2 * Math.PI / totalActs);
    const spokeColor = this.distributionMode === "manual" ? "rgba(255, 165, 0, 0.75)" : "rgba(255, 255, 255, 0.3)";
    actAngles.forEach((angle) => {
      const x1 = cx + innerR * Math.cos(angle);
      const y1 = cy + innerR * Math.sin(angle);
      const x2 = cx + (outerR + 6) * Math.cos(angle);
      const y2 = cy + (outerR + 6) * Math.sin(angle);
      const line = svg.createSvg("line");
      line.setAttr("x1", `${x1}`);
      line.setAttr("y1", `${y1}`);
      line.setAttr("x2", `${x2}`);
      line.setAttr("y2", `${y2}`);
      line.setAttr("stroke", spokeColor);
      line.setAttr("stroke-width", "1");
      line.addClass("rt-manuscript-preview-spoke");
    });
    actsList.forEach((actNumber) => {
      const sectorIndex = (actNumber - 1) % totalActs;
      const sectorStart = actAngles[sectorIndex];
      const sectorSpan = 2 * Math.PI / totalActs;
      const actScenes = assignments.filter((a) => a.act === actNumber).sort((a, b) => a.sceneNumber - b.sceneNumber);
      const count = actScenes.length;
      if (count === 0) return;
      const anglePerScene = sectorSpan / Math.max(1, count);
      actScenes.forEach((assignment, localIdx) => {
        const a0 = sectorStart + localIdx * anglePerScene;
        const a1 = a0 + anglePerScene;
        const subplotIndex = Math.min(Math.max(assignment.subplotIndex, 0), subplotList.length - 1);
        const rOutLocal = outerR - subplotIndex * ringWidth;
        const rInLocal = rOutLocal - ringWidth;
        const path = svg.createSvg("path");
        path.setAttr("d", this.donutSlicePath(cx, cy, rInLocal, rOutLocal, a0, a1));
        path.setAttr("fill", this.subplotColor(subplotIndex, subplotList.length));
        path.addClass("rt-manuscript-preview-slice");
        path.setAttr("data-act", `${assignment.act}`);
        path.setAttr("data-scene", `${assignment.sceneNumber}`);
        path.setAttr("data-subplot", `${subplotIndex}`);
        path.addEventListener("pointerdown", (evt) => this.beginDrag(evt, assignment.sceneNumber, dims));
      });
    });
    const core = svg.createSvg("circle");
    core.setAttr("cx", `${cx}`);
    core.setAttr("cy", `${cy}`);
    core.setAttr("r", `${innerR}`);
    core.addClass("rt-manuscript-preview-core");
  }
  donutSlicePath(cx, cy, r0, r1, a0, a1) {
    const largeArc = a1 - a0 > Math.PI ? 1 : 0;
    const x0o = cx + r1 * Math.cos(a0);
    const y0o = cy + r1 * Math.sin(a0);
    const x1o = cx + r1 * Math.cos(a1);
    const y1o = cy + r1 * Math.sin(a1);
    const x0i = cx + r0 * Math.cos(a1);
    const y0i = cy + r0 * Math.sin(a1);
    const x1i = cx + r0 * Math.cos(a0);
    const y1i = cy + r0 * Math.sin(a0);
    return [
      `M ${x0o} ${y0o}`,
      `A ${r1} ${r1} 0 ${largeArc} 1 ${x1o} ${y1o}`,
      `L ${x0i} ${y0i}`,
      `A ${r0} ${r0} 0 ${largeArc} 0 ${x1i} ${y1i}`,
      "Z"
    ].join(" ");
  }
  beginDrag(evt, sceneNumber, dims) {
    const svg = evt.currentTarget.closest("svg");
    if (!svg) return;
    this.dragState = { sceneNumber, pointerId: evt.pointerId, dims, targetAct: 0, targetSubplot: 0 };
    svg.setPointerCapture(evt.pointerId);
    if (this.previewHostEl) this.previewHostEl.addClass("rt-preview-dragging");
    const moveHandler = (moveEvt) => this.handleDragMove(moveEvt, svg, dims);
    const upHandler = (upEvt) => {
      this.finishDrag(upEvt, svg);
      svg.removeEventListener("pointermove", moveHandler);
      svg.removeEventListener("pointerup", upHandler);
    };
    svg.addEventListener("pointermove", moveHandler);
    svg.addEventListener("pointerup", upHandler);
  }
  handleDragMove(evt, svg, dims) {
    if (!this.dragState) return;
    const target = this.computeDropTarget(evt, svg, dims);
    if (!target) return;
    this.dragState.targetAct = target.act;
    this.dragState.targetSubplot = target.subplotIndex;
    if (this.previewStatusEl) {
      const subplotList = this.parseSubplots();
      const subplotLabel = subplotList[target.subplotIndex] || `Subplot ${target.subplotIndex + 1}`;
      this.previewStatusEl.setText(`Dragging scene ${this.dragState.sceneNumber} \u2192 Act ${target.act}, ${subplotLabel}`);
    }
  }
  finishDrag(evt, svg) {
    if (!this.dragState) return;
    const target = this.computeDropTarget(evt, svg, this.dragState.dims);
    svg.releasePointerCapture(this.dragState.pointerId);
    if (target) {
      const assignments = this.getWorkingAssignments().map((a) => ({ ...a }));
      const idx = assignments.findIndex((a) => a.sceneNumber === this.dragState.sceneNumber);
      if (idx >= 0) {
        assignments[idx].act = target.act;
        assignments[idx].subplotIndex = target.subplotIndex;
        this.sceneAssignments = assignments;
        this.markManualLayout();
        this.schedulePreviewUpdate();
      }
    }
    this.dragState = null;
    this.updateDistributionStatus();
    if (this.previewHostEl) this.previewHostEl.removeClass("rt-preview-dragging");
  }
  computeDropTarget(evt, svg, dims) {
    const ctm = svg.getScreenCTM();
    if (!ctm) return null;
    const pt = svg.createSVGPoint();
    pt.x = evt.clientX;
    pt.y = evt.clientY;
    const local = pt.matrixTransform(ctm.inverse());
    const dx = local.x - dims.cx;
    const dy = local.y - dims.cy;
    const radius = Math.sqrt(dx * dx + dy * dy);
    if (radius < dims.innerR || radius > dims.outerR) return null;
    const angleRaw = Math.atan2(dy, dx);
    const normalized = (angleRaw - -Math.PI / 2 + 2 * Math.PI) % (2 * Math.PI);
    const sectorSpan = 2 * Math.PI / dims.totalActs;
    const targetAct = this.closestSelectedAct(normalized, sectorSpan, dims.totalActs);
    const offset = dims.outerR - radius;
    const subplotIndex = Math.min(Math.max(Math.floor(offset / dims.ringWidth), 0), dims.subplotCount - 1);
    return { act: targetAct, subplotIndex };
  }
  closestSelectedAct(normalizedAngle, sectorSpan, totalActs) {
    const selected = this.getActsListSorted();
    if (selected.length === 0) return 1;
    let bestAct = selected[0];
    let bestDiff = Number.MAX_VALUE;
    selected.forEach((act) => {
      const center = (act - 1) * sectorSpan + sectorSpan / 2;
      const diff = Math.abs(this.wrapAngle(normalizedAngle - center));
      if (diff < bestDiff) {
        bestDiff = diff;
        bestAct = act;
      }
    });
    return bestAct;
  }
  wrapAngle(angle) {
    const twoPi = 2 * Math.PI;
    let a = angle % twoPi;
    if (a > Math.PI) a -= twoPi;
    if (a < -Math.PI) a += twoPi;
    return Math.abs(a);
  }
  async generateBook() {
    var _a, _b, _c, _d;
    const vault = this.plugin.app.vault;
    const targetPath = this.plugin.settings.sourcePath;
    const targetFolder = targetPath ? (0, import_obsidian21.normalizePath)(targetPath.trim()) : "";
    if (targetFolder && !vault.getAbstractFileByPath(targetFolder)) {
      try {
        await vault.createFolder(targetFolder);
      } catch (e) {
        new import_obsidian21.Notice(`Error creating folder: ${e}`);
        return;
      }
    }
    const subplotList = this.subplots.split("\n").map((s) => s.trim()).filter((s) => s.length > 0);
    if (subplotList.length === 0) subplotList.push("Main Plot");
    const templateKey = this.templateType;
    const userTemplates = this.plugin.settings.sceneYamlTemplates;
    const templateString = userTemplates == null ? void 0 : userTemplates[templateKey];
    if (!templateString) {
      new import_obsidian21.Notice("Scene template not found in settings. Set a scene template before generating.");
      return;
    }
    const sceneBaseDate = /* @__PURE__ */ new Date();
    sceneBaseDate.setHours(0, 0, 0, 0);
    const incrementMs = parseDuration(this.timeIncrement) || 24 * 60 * 60 * 1e3;
    let createdScenes = 0;
    let skippedScenes = 0;
    new import_obsidian21.Notice(`Generating ${this.scenesToGenerate} scenes...`);
    const rangeMax = Math.max(this.targetRangeMax, this.scenesToGenerate);
    const assignments = this.getWorkingAssignments();
    for (let i = 1; i <= this.scenesToGenerate; i++) {
      const sceneDate = new Date(sceneBaseDate.getTime() + incrementMs * (i - 1));
      let when = sceneDate.toISOString().slice(0, 10);
      if (incrementMs < 24 * 60 * 60 * 1e3) {
        const hours = sceneDate.getHours().toString().padStart(2, "0");
        const mins = sceneDate.getMinutes().toString().padStart(2, "0");
        when = `${when} ${hours}:${mins}`;
      }
      let sceneNum = Math.round(i / this.scenesToGenerate * this.targetRangeMax);
      if (i === 1) sceneNum = 1;
      else if (i === this.scenesToGenerate) sceneNum = this.targetRangeMax;
      else {
        const step = (this.targetRangeMax - 1) / (this.scenesToGenerate - 1);
        sceneNum = Math.round(1 + (i - 1) * step);
      }
      const assignment = (_b = assignments.find((a) => a.sceneNumber === i)) != null ? _b : {
        sceneNumber: i,
        act: (_a = this.selectedActs[0]) != null ? _a : 1,
        subplotIndex: (i - 1) % subplotList.length
      };
      const act = assignment.act;
      const subplotIndex = Math.min(Math.max(assignment.subplotIndex, 0), subplotList.length - 1);
      const assignedSubplots = [(_c = subplotList[subplotIndex]) != null ? _c : subplotList[0]];
      const characterList = this.character.split("\n").map((c) => c.trim()).filter((c) => c.length > 0);
      const yamlEscapeDoubleQuoted = (value) => value.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
      const yamlInlineArray = (values) => `[${values.map((v) => `"${yamlEscapeDoubleQuoted(v)}"`).join(", ")}]`;
      const characterString = characterList.length === 0 ? "Hero" : characterList.length === 1 ? characterList[0] : yamlInlineArray(characterList);
      const placeListRaw = targetPath ? [targetPath] : [];
      const placeList = placeListRaw.length > 0 ? placeListRaw : ["Unknown"];
      const data = {
        act,
        when,
        sceneNumber: sceneNum,
        subplots: assignedSubplots,
        character: characterString,
        place: "Unknown",
        characterList,
        placeList
      };
      const content = generateSceneContent(templateString, data);
      const fileContent = `---
${content}
---

`;
      const filename = `${sceneNum} Scene.md`;
      const filePath = targetFolder ? `${targetFolder}/${filename}` : filename;
      try {
        if (!vault.getAbstractFileByPath(filePath)) {
          await vault.create(filePath, fileContent);
          createdScenes++;
        } else {
          skippedScenes++;
        }
      } catch (e) {
        const msg = (_d = e == null ? void 0 : e.message) != null ? _d : "";
        if (msg.includes("exists") || msg.includes("already exists")) {
          skippedScenes++;
        } else {
          console.error(`Failed to create ${filename}`, e);
        }
      }
    }
    let beatsCreated = 0;
    if (this.generateBeats) {
      const beatSystem = this.plugin.settings.beatSystem || "Custom";
      if (beatSystem === "Custom") {
        const customSystem = getCustomSystemFromSettings(this.plugin.settings);
        if (customSystem.beats.length > 0) {
          try {
            const result = await createBeatTemplateNotes(vault, "Custom", targetFolder, customSystem);
            beatsCreated = result.created;
          } catch (e) {
            new import_obsidian21.Notice(`Error creating custom beats: ${e}`);
          }
        } else {
        }
      } else {
        try {
          const result = await createBeatTemplateNotes(vault, beatSystem, targetFolder);
          beatsCreated = result.created;
        } catch (e) {
          new import_obsidian21.Notice(`Error creating beats: ${e}`);
        }
      }
    }
    const skippedInfo = skippedScenes > 0 ? ` (skipped ${skippedScenes} existing)` : "";
    new import_obsidian21.Notice(`Book created! ${createdScenes} scenes${skippedInfo}, ${beatsCreated} beat notes.`);
  }
};

// src/view/WelcomeScreen.ts
function renderWelcomeScreen({ container, plugin, refreshTimeline }) {
  container.addClass("rt-welcome-view");
  container.createDiv({ cls: "rt-welcome-title", text: "Welcome" });
  const body = container.createDiv({ cls: "rt-welcome-body" });
  const intro = body.createEl("p", { cls: "rt-welcome-paragraph" });
  intro.createSpan({ text: "Radial Timeline is a visual map of your story in a concise radial format, revealing structure, status, and meta. It works in four focused modes, each answering a different creative question." });
  const modesList = body.createEl("ul", { cls: "rt-welcome-list" });
  const addMode = (label, description) => {
    const li = modesList.createEl("li");
    li.createEl("strong", { text: `${label}: ` });
    li.createSpan({ text: description });
  };
  addMode("Narrative", "Color coded subplots and All Scenes outer ring plus Story Beats.");
  addMode("Subplot", "Isolates individual subplots with a project-management focus.");
  addMode("Chronologue", "Shows how scenes unfold in time with shift & alt submodes.");
  addMode("Gossamer", "Steps back to give you a birds-eye view of pacing and momentum.");
  const links = body.createEl("p", { cls: "rt-welcome-links" });
  const makeLinkRow = (label, href) => {
    const row = links.createDiv({ cls: "rt-welcome-link-row" });
    row.createEl("a", { href, text: label });
  };
  makeLinkRow("Learn more at the GitHub Wiki", "https://github.com/EricRhysTaylor/radial-timeline/wiki");
  makeLinkRow("Discussions group", "https://github.com/EricRhysTaylor/Radial-Timeline/discussions");
  makeLinkRow("Bug reports / feature requests", "https://github.com/EricRhysTaylor/radial-timeline/issues");
  const cta = body.createEl("p", {
    cls: "rt-welcome-paragraph",
    text: "Bug reporting & Get Help buttons in the bottom corners of the Radial Timeline window are always available. The Book Designer can help you begin by setting up a starter set of scenes."
  });
  const backupNotice = body.createDiv({ cls: "rt-welcome-backup-notice" });
  const iconContainer = backupNotice.createDiv({ cls: "rt-welcome-backup-icon" });
  iconContainer.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-archive-restore"><rect width="20" height="5" x="2" y="3" rx="1"/><path d="M4 8v11a2 2 0 0 0 2 2h2"/><path d="M20 8v11a2 2 0 0 1-2 2h-2"/><path d="m9 15 3-3 3 3"/><path d="M12 12v9"/></svg>`;
  const backupText = backupNotice.createDiv({ cls: "rt-welcome-backup-text" });
  const backupPara = backupText.createDiv();
  backupPara.createEl("strong", { text: "Protect Your Work: " });
  backupPara.createSpan({ text: "It is strongly recommended for you to " });
  backupPara.createEl("a", { text: "automate backups", href: "https://help.obsidian.md/backup" });
  backupPara.createSpan({ text: ". The native " });
  backupPara.createEl("a", { text: "Obsidian Sync", href: "https://obsidian.md/sync" });
  backupPara.createSpan({ text: " service and community favorite " });
  backupPara.createEl("a", { text: "Obsidian Git", href: "https://obsidian.md/plugins?id=obsidian-git" });
  backupPara.createSpan({ text: " are excellent choices." });
  const syncPara = backupText.createDiv();
  syncPara.style.marginTop = "8px";
  syncPara.createEl("strong", { text: "Sync Conflicts: " });
  syncPara.createSpan({ text: "Avoid mixing sync services. If using iCloud on macOS alongside another sync tool, append " });
  syncPara.createEl("code", { text: ".nosync" });
  syncPara.createSpan({ text: " to the folder name to stop iCloud from syncing the vault. " });
  syncPara.createEl("a", { text: "Read the Obsidian Sync Guide.", href: "https://help.obsidian.md/sync/switch" });
  const buttonContainer = container.createDiv({ cls: "rt-welcome-actions" });
  const bookBtn = new import_obsidian22.ButtonComponent(buttonContainer).setButtonText("Book Designer").setCta().onClick(() => {
    new BookDesignerModal(plugin.app, plugin).open();
  });
  bookBtn.buttonEl.classList.add("rt-welcome-book-btn");
}

// src/renderer/ChangeDetection.ts
function createSnapshot(scenes, openFilePaths, searchActive, searchResults, currentMode, settings, gossamerRun) {
  var _a, _b, _c, _d, _e;
  const sceneHash = scenes.map((s) => {
    const parts = [
      s.path || s.title || "",
      s.status || "",
      s.actNumber || "",
      s.subplot || "",
      s.number || "",
      s.when instanceof Date ? s.when.getTime() : s.when || "",
      s.Duration || "",
      s.due || "",
      s["Publish Stage"] || "",
      s.synopsis || "",
      // Pending Edits affects number square color (gray)
      s.pendingEdits || "",
      s.Description || "",
      stringifyPovForHash(s.pov),
      // Range field (rendered in Gossamer mode)
      s.Range || "",
      (s.Character || []).length,
      s.location || ""
    ];
    for (let i = 1; i <= 30; i++) {
      const gossamerKey = `Gossamer${i}`;
      parts.push(s[gossamerKey] || "");
      const justificationKey = `Gossamer${i} Justification`;
      parts.push(s[justificationKey] || "");
    }
    return parts.join(":");
  }).join("|");
  const publishStageColorsHash = settings.publishStageColors ? JSON.stringify(settings.publishStageColors) : "";
  const subplotColorsHash = settings.subplotColors ? JSON.stringify(settings.subplotColors) : "";
  const dominantSubplotsHash = settings.dominantSubplots ? JSON.stringify(settings.dominantSubplots) : "";
  const now = /* @__PURE__ */ new Date();
  const gossamerRunHash = (() => {
    var _a2, _b2, _c2, _d2, _e2, _f;
    if (!gossamerRun) return "";
    try {
      const beats = Array.isArray(gossamerRun.beats) ? gossamerRun.beats.map((beat) => {
        var _a3, _b3, _c3, _d3;
        return {
          beat: (_a3 = beat == null ? void 0 : beat.beat) != null ? _a3 : "",
          score: typeof (beat == null ? void 0 : beat.score) === "number" ? beat.score : "",
          status: (_b3 = beat == null ? void 0 : beat.status) != null ? _b3 : "",
          range: (beat == null ? void 0 : beat.range) ? `${(_c3 = beat.range.min) != null ? _c3 : ""}-${(_d3 = beat.range.max) != null ? _d3 : ""}` : "",
          out: (beat == null ? void 0 : beat.isOutOfRange) ? "1" : "0"
        };
      }) : [];
      return JSON.stringify({
        beats,
        label: (_b2 = (_a2 = gossamerRun.meta) == null ? void 0 : _a2.label) != null ? _b2 : "",
        model: (_d2 = (_c2 = gossamerRun.meta) == null ? void 0 : _c2.model) != null ? _d2 : "",
        summary: (_f = (_e2 = gossamerRun.overall) == null ? void 0 : _e2.summary) != null ? _f : ""
      });
    } catch (e) {
      return String(Date.now());
    }
  })();
  return {
    sceneCount: scenes.length,
    sceneHash,
    openFilePaths: new Set(openFilePaths),
    searchActive,
    searchResults: new Set(searchResults),
    currentMode,
    currentMonth: now.getMonth(),
    currentDate: now.toISOString().split("T")[0],
    sortByWhen: (_a = settings.sortByWhenDate) != null ? _a : false,
    aiEnabled: (_b = settings.enableAiSceneAnalysis) != null ? _b : false,
    targetDate: settings.targetCompletionDate,
    chronologueDurationCap: settings.chronologueDurationCapSelection,
    discontinuityThreshold: settings.discontinuityThreshold,
    publishStageColorsHash,
    subplotColorsHash,
    dominantSubplotsHash,
    povMode: (_c = settings.globalPovMode) != null ? _c : "off",
    gossamerRunExists: !!gossamerRun,
    gossamerRunHash,
    updateAvailable: (_e = (_d = getVersionCheckService()) == null ? void 0 : _d.isUpdateAvailable()) != null ? _e : false,
    timestamp: Date.now()
  };
}
function detectChanges(prev, current) {
  const changeTypes = /* @__PURE__ */ new Set();
  if (!prev) {
    return {
      hasChanges: true,
      changeTypes: /* @__PURE__ */ new Set(["scene_data" /* SCENE_DATA */]),
      canUseSelectiveUpdate: false,
      updateStrategy: "full"
    };
  }
  if (prev.sceneHash !== current.sceneHash || prev.sceneCount !== current.sceneCount) {
    changeTypes.add("scene_data" /* SCENE_DATA */);
  }
  if (!setsEqual(prev.openFilePaths, current.openFilePaths)) {
    changeTypes.add("open_files" /* OPEN_FILES */);
  }
  if (prev.searchActive !== current.searchActive || !setsEqual(prev.searchResults, current.searchResults)) {
    changeTypes.add("search" /* SEARCH */);
  }
  if (prev.currentMode !== current.currentMode) {
    changeTypes.add("mode" /* MODE */);
  }
  if (prev.sortByWhen !== current.sortByWhen || prev.aiEnabled !== current.aiEnabled || prev.targetDate !== current.targetDate || prev.chronologueDurationCap !== current.chronologueDurationCap || prev.discontinuityThreshold !== current.discontinuityThreshold || prev.publishStageColorsHash !== current.publishStageColorsHash || prev.subplotColorsHash !== current.subplotColorsHash || prev.povMode !== current.povMode) {
    changeTypes.add("settings" /* SETTINGS */);
  }
  if (prev.dominantSubplotsHash !== current.dominantSubplotsHash) {
    changeTypes.add("dominant_subplot" /* DOMINANT_SUBPLOT */);
  }
  if (prev.currentMonth !== current.currentMonth || prev.currentDate !== current.currentDate) {
    changeTypes.add("time" /* TIME */);
  }
  if (prev.gossamerRunExists !== current.gossamerRunExists || prev.gossamerRunHash !== current.gossamerRunHash) {
    changeTypes.add("gossamer" /* GOSSAMER */);
  }
  if (prev.updateAvailable !== current.updateAvailable) {
    changeTypes.add("update_status" /* UPDATE_STATUS */);
  }
  const hasChanges = changeTypes.size > 0;
  const selectiveChangeTypes = [
    "open_files" /* OPEN_FILES */,
    "search" /* SEARCH */,
    "time" /* TIME */,
    "dominant_subplot" /* DOMINANT_SUBPLOT */,
    // DOM update for scene colors
    "synopsis" /* SYNOPSIS */,
    // DOM update for synopsis text
    "gossamer" /* GOSSAMER */
  ];
  const canUseSelectiveUpdate = hasChanges && Array.from(changeTypes).every((type) => selectiveChangeTypes.includes(type));
  let updateStrategy = "none";
  if (hasChanges) {
    updateStrategy = canUseSelectiveUpdate ? "selective" : "full";
  }
  return {
    hasChanges,
    changeTypes,
    canUseSelectiveUpdate,
    updateStrategy
  };
}
function setsEqual(a, b) {
  if (a.size !== b.size) return false;
  for (const item of a) {
    if (!b.has(item)) return false;
  }
  return true;
}
function stringifyPovForHash(pov) {
  return typeof pov === "string" ? pov : "";
}

// src/view/TimeLineView.ts
var TIMELINE_VIEW_TYPE = "radial-timeline";
var _RadialTimelineView = class _RadialTimelineView extends import_obsidian23.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    // Frontmatter values to track to reduce unnecessary SVG View refreshes
    this.lastFrontmatterValues = {};
    this.timelineRefreshTimeout = null;
    // Change detection snapshot for optimizing renders
    this.lastSnapshot = null;
    // Scene data (scenes)
    this.sceneData = [];
    // Set of open scene paths (for tracking open files)
    this.openScenePaths = /* @__PURE__ */ new Set();
    // Store rotation state to persist across timeline refreshes
    this.rotationState = false;
    // Mode system
    this._currentMode = "narrative";
    // Interaction handler management
    // Store event handler references for clean removal
    this.normalEventHandlers = /* @__PURE__ */ new Map();
    this.gossamerEventHandlers = /* @__PURE__ */ new Map();
    // Property to track tab highlight timeout
    this._tabHighlightTimeout = null;
    this.plugin = plugin;
    this.openScenePaths = plugin.openScenePaths;
    this.rendererService = plugin.getRendererService();
    this._currentMode = plugin.settings.currentMode || "narrative";
    try {
      this.modeManager = createModeManager(plugin, this);
      this.interactionController = createInteractionController(this);
    } catch (e) {
    }
  }
  // Expose a safe registrar for Gossamer handlers so external modules can record svg-level listeners
  registerGossamerHandler(key, handler) {
    this.gossamerEventHandlers.set(key, handler);
  }
  /**
   * Get the current timeline mode
   */
  get currentMode() {
    return this._currentMode;
  }
  /**
   * Set the current timeline mode
   */
  set currentMode(mode) {
    this._currentMode = mode;
  }
  /**
   * Get the ModeManager instance
   * Provides centralized mode switching with lifecycle management
   */
  getModeManager() {
    return this.modeManager;
  }
  /**
   * Get the InteractionController instance
   * Manages event handler registration and cleanup
   */
  getInteractionController() {
    return this.interactionController;
  }
  getViewType() {
    return TIMELINE_VIEW_TYPE;
  }
  getDisplayText() {
    if (this.plugin.settings.showSourcePathAsTitle !== false) {
      const sourcePath = this.plugin.settings.sourcePath || "";
      if (sourcePath) {
        const parts = sourcePath.split("/").filter((p) => p.length > 0);
        if (parts.length > 0) {
          return `Radial Timeline: ${parts[parts.length - 1]}`;
        }
      }
    }
    return "Radial Timeline: Work in Progress";
  }
  getIcon() {
    return "shell";
  }
  // --- Helpers for number-square orientation/position (shared across modes) ---
  applyRotationToNumberSquares(svg, rotated) {
    const numActs = parseInt(svg.getAttribute("data-num-acts") || "3", 10);
    const angle = numActs > 0 ? 360 / numActs : 120;
    const orients = svg.querySelectorAll(".number-square-orient");
    orients.forEach((el) => {
      const base = (el.getAttribute("transform") || "").replace(/\s*rotate\([^)]*\)/g, "").trim();
      if (rotated) {
        el.setAttribute("transform", `${base} rotate(${angle})`.trim());
      } else {
        if (base) el.setAttribute("transform", base);
        else el.removeAttribute("transform");
      }
    });
  }
  getRotationState() {
    return this.rotationState;
  }
  setRotationState(rotated) {
    this.rotationState = rotated;
  }
  getSquareGroupForSceneId(svg, sceneId) {
    const rect = svg.querySelector(`.rt-number-square[data-scene-id="${sceneId}"]`);
    if (!rect) return null;
    const group = rect.closest(".number-square-group");
    return group;
  }
  setNumberSquareGroupPosition(svg, sceneId, x, y) {
    const group = this.getSquareGroupForSceneId(svg, sceneId);
    if (group) {
      group.setAttribute("transform", `translate(${x}, ${y})`);
    }
  }
  // Add this method to handle search indicator clicks
  setupSearchControls() {
    setupSearchControls(this);
  }
  /**
   * Setup interactions based on the current mode
   */
  setupInteractionsForMode(svg) {
    if (this.interactionController) {
      const { getModeDefinition: getModeDefinition2 } = (init_ModeRegistry(), __toCommonJS(ModeRegistry_exports));
      const modeDef = getModeDefinition2(this.currentMode);
      this.interactionController.setupMode(modeDef, svg);
    }
  }
  updateOpenFilesTracking() {
    var _a;
    const previousOpenFiles = new Set(this.openScenePaths);
    this.openScenePaths = /* @__PURE__ */ new Set();
    const leaves = this.app.workspace.getLeavesOfType("markdown");
    const openFilesList = [];
    leaves.forEach((leaf) => {
      const view = leaf.view;
      if (view instanceof import_obsidian23.MarkdownView && view.file) {
        this.openScenePaths.add(view.file.path);
        openFilesList.push(view.file.path);
      }
    });
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile && !openFilesList.includes(activeFile.path)) {
      this.openScenePaths.add(activeFile.path);
      openFilesList.push(activeFile.path);
    }
    try {
      const layout = this.app.workspace.getLayout();
      if (layout && layout.leaves) {
        const leafIds = Object.keys(layout.leaves);
        leafIds.forEach((id) => {
          const leafs = layout.leaves;
          const leafData = leafs[id];
          if (leafData && leafData.type === "markdown" && leafData.state && leafData.state.file) {
            const filePath = leafData.state.file;
            if (!openFilesList.includes(filePath)) {
              this.openScenePaths.add(filePath);
              openFilesList.push(filePath);
            }
          }
        });
      }
    } catch (e) {
      console.error("Error accessing workspace layout:", e);
    }
    let hasChanged = false;
    if (previousOpenFiles.size !== this.openScenePaths.size) {
      hasChanged = true;
    } else {
      for (const path of previousOpenFiles) {
        if (!this.openScenePaths.has(path)) {
          hasChanged = true;
          break;
        }
      }
      if (!hasChanged) {
        for (const path of this.openScenePaths) {
          if (!previousOpenFiles.has(path)) {
            hasChanged = true;
            break;
          }
        }
      }
    }
    this.plugin.openScenePaths = new Set(this.openScenePaths);
    if (hasChanged) {
      const container = this.containerEl.children[1];
      const updated = (_a = this.rendererService) == null ? void 0 : _a.updateOpenClasses(container, this.openScenePaths);
      if (!updated) this.refreshTimeline();
    }
  }
  refreshTimeline() {
    if (!this.plugin) return;
    const perfStart = performance.now();
    const container = this.containerEl.children[1];
    this.updateOpenFilesTracking();
    this.plugin.getSceneData().then(async (sceneData) => {
      var _a, _b;
      const dataLoadTime = performance.now() - perfStart;
      if (this._currentMode === "gossamer") {
        const { buildAllGossamerRuns: buildAllGossamerRuns2 } = await Promise.resolve().then(() => (init_gossamer(), gossamer_exports));
        const selectedBeatModel = ((_a = this.plugin.settings.beatSystem) == null ? void 0 : _a.trim()) || void 0;
        const allRuns = buildAllGossamerRuns2(sceneData, selectedBeatModel);
        this.plugin._gossamerLastRun = allRuns.current;
        this.plugin._gossamerHistoricalRuns = allRuns.historical;
        this.plugin._gossamerMinMax = allRuns.minMax;
        this.plugin._gossamerHasAnyScores = allRuns.hasAnyScores;
      }
      this.sceneData = sceneData;
      this.plugin.lastSceneData = sceneData;
      const currentSnapshot = createSnapshot(
        sceneData,
        this.plugin.openScenePaths,
        this.plugin.searchActive,
        this.plugin.searchResults,
        this._currentMode,
        this.plugin.settings,
        this.plugin._gossamerLastRun
      );
      const changeResult = detectChanges(this.lastSnapshot, currentSnapshot);
      if (changeResult.updateStrategy === "none") {
        return;
      } else if (changeResult.updateStrategy === "selective" && this.rendererService) {
        let updated = false;
        if (changeResult.changeTypes.has("open_files" /* OPEN_FILES */)) {
          updated = this.rendererService.updateOpenClasses(container, this.plugin.openScenePaths) || updated;
        }
        if (changeResult.changeTypes.has("search" /* SEARCH */)) {
          updated = this.rendererService.updateNumberSquaresDOM(container, this.plugin, sceneData) || updated;
          updated = this.rendererService.updateSearchHighlights(this) || updated;
        }
        if (changeResult.changeTypes.has("time" /* TIME */)) {
          updated = this.rendererService.updateProgressAndTicks(this) || updated;
        }
        if (changeResult.changeTypes.has("synopsis" /* SYNOPSIS */)) {
          updated = this.rendererService.updateSynopsisDOM(container, sceneData) || updated;
        }
        if (changeResult.changeTypes.has("gossamer" /* GOSSAMER */)) {
          updated = this.rendererService.updateGossamerLayer(this) || updated;
        }
        if (updated) {
          this.lastSnapshot = currentSnapshot;
          return;
        }
      }
      const loadingEl = container.createEl("div", {
        cls: "rt-loading-message",
        text: "Loading timeline data..."
      });
      container.empty();
      container.appendChild(loadingEl);
      const renderStart = performance.now();
      this.renderTimeline(container, this.sceneData);
      const renderTime = performance.now() - renderStart;
      loadingEl.remove();
      this.lastSnapshot = currentSnapshot;
      this.setupSearchControls();
      if (this.plugin.searchActive) {
        if (!((_b = this.rendererService) == null ? void 0 : _b.updateSearchHighlights(this))) {
          window.setTimeout(() => this.addHighlightRectangles(), 100);
        }
      }
    }).catch((error) => {
      const errorEl = container.createEl("div", {
        cls: "rt-error-message",
        text: `Error: ${error.message}`
      });
      console.error("Failed to load timeline data", error);
    });
  }
  setupMouseCoordinateTracking(container) {
  }
  /**
   * Called whenever the view is shown/revealed (e.g., when switching tabs back to this view)
   * Unlike onOpen which is called only once when the view is created
   */
  onload() {
  }
  async onOpen() {
    this.contentEl.addClass("radial-timeline-view");
    await this.plugin.maybeShowReleaseNotesModal();
    this.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        var _a;
        if (!(file instanceof import_obsidian23.TFile) || file.extension !== "md") return;
        const cache = this.app.metadataCache.getFileCache(file);
        if (!cache || !cache.frontmatter) return;
        const fm = cache.frontmatter;
        const isScene = fm.Class === "Scene" || fm.class === "Scene";
        const isBeatOrPlot = fm.Class === "Plot" || fm.class === "Plot" || fm.Class === "Beat" || fm.class === "Beat";
        if (!isScene && !isBeatOrPlot) return;
        const isGossamerMode = this._currentMode === "gossamer";
        if (isGossamerMode && !isBeatOrPlot) {
          return;
        }
        if (!isGossamerMode && isBeatOrPlot && !isScene) {
          return;
        }
        const fileId = file.path;
        const currentFrontmatter = JSON.stringify(cache.frontmatter);
        const previousFrontmatter = this.lastFrontmatterValues[fileId];
        this.lastFrontmatterValues[fileId] = currentFrontmatter;
        if (previousFrontmatter === currentFrontmatter) return;
        if (this.timelineRefreshTimeout) window.clearTimeout(this.timelineRefreshTimeout);
        this.timelineRefreshTimeout = window.setTimeout(() => {
          this.refreshTimeline();
        }, Math.max(0, Number((_a = this.plugin.settings.metadataRefreshDebounceMs) != null ? _a : 1e4)));
      })
    );
    if (this._currentMode === "gossamer" && this.modeManager) {
      const { TimelineMode: TimelineMode2 } = await Promise.resolve().then(() => (init_ModeDefinition(), ModeDefinition_exports));
      const { getModeDefinition: getModeDefinition2 } = await Promise.resolve().then(() => (init_ModeRegistry(), ModeRegistry_exports));
      const gossamerDef = getModeDefinition2(TimelineMode2.GOSSAMER);
      if (gossamerDef.onEnter) {
        try {
          await gossamerDef.onEnter(this);
        } catch (e) {
          console.error("[Gossamer] Failed to initialize on load:", e);
          this._currentMode = "narrative";
        }
      }
    }
    this.refreshTimeline();
  }
  async onClose() {
    this.plugin.searchActive = false;
    this.plugin.searchTerm = "";
    this.plugin.searchResults.clear();
    if (this._chronologueShiftCleanup) {
      this._chronologueShiftCleanup();
    }
  }
  // Add missing addHighlightRectangles method
  addHighlightRectangles() {
    addHighlightRectangles(this);
  }
  renderTimeline(container, scenes) {
    var _a;
    container.empty();
    const hasScenes = scenes && scenes.some((item) => item.itemType === "Scene");
    if (!scenes || scenes.length === 0 || !hasScenes) {
      renderWelcomeScreen({
        container,
        plugin: this.plugin,
        refreshTimeline: () => this.refreshTimeline()
      });
      return;
    }
    this.sceneData = scenes;
    const fragment = document.createDocumentFragment();
    const timelineContainer = document.createElement("div");
    timelineContainer.className = "radial-timeline-container";
    fragment.appendChild(timelineContainer);
    try {
      const startTime = performance.now();
      const renderer = (_a = this.rendererService) != null ? _a : this.plugin.getRendererService();
      const { svgString, maxStageColor: calculatedMaxStageColor } = renderer.generateTimeline(this.plugin, scenes);
      if (calculatedMaxStageColor) {
        document.documentElement.style.setProperty("--rt-max-publish-stage-color", calculatedMaxStageColor);
      }
      const svgElement = renderSvgFromString(svgString, timelineContainer, (cleanup) => this.register(cleanup));
      if (svgElement) {
        svgElement.setAttribute("data-mode", this.currentMode);
        if (this.currentMode === "chronologue" && isShiftModeActive()) {
          svgElement.setAttribute("data-shift-mode", "active");
        }
        if (this.currentMode === "chronologue") {
          svgElement.setAttribute("data-chronologue-mode", "true");
        } else {
          svgElement.removeAttribute("data-chronologue-mode");
        }
        if (this.currentMode === "gossamer") {
          svgElement.setAttribute("data-gossamer-mode", "true");
          const allElements = svgElement.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title");
          allElements.forEach((el) => {
            const group = el.closest(".rt-scene-group");
            const itemType = group == null ? void 0 : group.getAttribute("data-item-type");
            if (itemType !== "Beat") {
              el.classList.add("rt-non-selected");
            }
          });
        } else {
          svgElement.removeAttribute("data-gossamer-mode");
        }
        this.setupInteractionsForMode(svgElement);
        const subplotLabelGroups = svgElement.querySelectorAll(".subplot-label-group[data-font-size]");
        subplotLabelGroups.forEach((group) => {
          const fontSize = group.getAttribute("data-font-size");
          if (fontSize) {
            group.style.setProperty("--rt-subplot-font-size", `${fontSize}px`);
          }
        });
        setupRotationController(this, svgElement);
        setupModeToggleController(this, svgElement);
        setupVersionIndicatorController(this, svgElement);
        setupHelpIconController(this, svgElement);
        const adjustLabels = () => {
          var _a2;
          return (_a2 = this.rendererService) == null ? void 0 : _a2.adjustBeatLabelsAfterRender(timelineContainer);
        };
        const rafId1 = requestAnimationFrame(adjustLabels);
        const leafChangeHandler = () => {
          if (this.app.workspace.getActiveViewOfType(_RadialTimelineView) === this) {
            const timeoutId = window.setTimeout(() => {
              const rafId2 = requestAnimationFrame(adjustLabels);
              this.register(() => cancelAnimationFrame(rafId2));
            }, 50);
            this.register(() => window.clearTimeout(timeoutId));
          }
        };
        this.register(() => cancelAnimationFrame(rafId1));
        this.registerEvent(this.app.workspace.on("active-leaf-change", leafChangeHandler));
        const allSynopses = Array.from(svgElement.querySelectorAll(".rt-scene-info"));
        const sceneGroups = Array.from(svgElement.querySelectorAll(".rt-scene-group"));
        const sceneGroupRafIds = [];
        const CHUNK_SIZE = 20;
        const processSceneGroups = (startIdx) => {
          const endIdx = Math.min(startIdx + CHUNK_SIZE, sceneGroups.length);
          for (let i = startIdx; i < endIdx; i++) {
            const group = sceneGroups[i];
            const encodedPath = group.getAttribute("data-path");
            if (encodedPath && encodedPath !== "") {
              const filePath = decodeURIComponent(encodedPath);
              if (this.openScenePaths.has(filePath)) {
                group.classList.add("rt-scene-is-open");
                const scenePath = group.querySelector(".rt-scene-path");
                if (scenePath) {
                  scenePath.classList.add("rt-scene-is-open");
                }
                const sceneTitle = group.querySelector(".rt-scene-title");
                if (sceneTitle) {
                  sceneTitle.classList.add("rt-scene-is-open");
                }
                const sceneId = scenePath == null ? void 0 : scenePath.id;
                if (sceneId) {
                  const numberSquare = svgElement.querySelector(`.rt-number-square[data-scene-id="${sceneId}"]`);
                  if (numberSquare) {
                    numberSquare.classList.add("rt-scene-is-open");
                  }
                  const numberText = svgElement.querySelector(`.rt-number-text[data-scene-id="${sceneId}"]`);
                  if (numberText) {
                    numberText.classList.add("rt-scene-is-open");
                  }
                }
              }
            }
          }
          if (endIdx < sceneGroups.length) {
            const rafId = window.requestAnimationFrame(() => processSceneGroups(endIdx));
            sceneGroupRafIds.push(rafId);
          }
        };
        this.register(() => {
          sceneGroupRafIds.forEach((id) => cancelAnimationFrame(id));
        });
        processSceneGroups(0);
        allSynopses.forEach((synopsis) => {
          synopsis.classList.remove("rt-visible");
        });
        this.setupSearchControls();
        const subplotLabels = svgElement.querySelectorAll(".rt-subplot-ring-label-text");
        if (subplotLabels.length > 0) {
          const onEnterLeave = (hovering, targetGroup) => {
            if (!targetGroup) return;
            subplotLabels.forEach((label) => {
              if (hovering) label.classList.add("rt-non-selected");
              else label.classList.remove("rt-non-selected");
            });
          };
          const svg = container.querySelector(".radial-timeline-svg");
          if (svg) {
            let lastHoverGroup = null;
            this.registerDomEvent(svg, "pointerover", (e) => {
              const g = e.target.closest(".rt-scene-group");
              if (g && g !== lastHoverGroup) {
                onEnterLeave(true, g);
                lastHoverGroup = g;
              }
            });
            this.registerDomEvent(svg, "pointerout", (e) => {
              const g = e.target.closest(".rt-scene-group");
              if (g && g === lastHoverGroup) {
                onEnterLeave(false, g);
                lastHoverGroup = null;
              }
            });
          }
        }
      }
      container.appendChild(fragment);
      const svgForTooltips = container.querySelector(".radial-timeline-svg");
      if (svgForTooltips) {
        setupTooltipsFromDataAttributes(svgForTooltips, this.registerDomEvent.bind(this));
      }
      if (this.currentMode === "gossamer") {
        const svg = container.querySelector(".radial-timeline-svg");
        if (svg) {
          let gossamerOuterRafId = null;
          let gossamerInnerRafId = null;
          gossamerOuterRafId = requestAnimationFrame(() => {
            gossamerInnerRafId = requestAnimationFrame(() => {
              this.setupGossamerEventListeners(svg);
              gossamerOuterRafId = null;
              gossamerInnerRafId = null;
            });
          });
          this.register(() => {
            if (gossamerOuterRafId !== null) cancelAnimationFrame(gossamerOuterRafId);
            if (gossamerInnerRafId !== null) cancelAnimationFrame(gossamerInnerRafId);
          });
        }
      }
    } catch (error) {
      console.error("Error rendering timeline:", error);
      container.createEl("div", {
        text: "Error rendering timeline. Check console for details."
      });
    }
  }
  // New helper removed; interactions moved to modes/AllScenesMode
  // Helper method to highlight files in the navigator and tab bar
  highlightFileInExplorer(filePath, isHighlighting) {
    if (!filePath) return;
    try {
      const file = this.plugin.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian23.TFile) {
        if (isHighlighting) {
          const fileExplorer = this.plugin.app.workspace.getLeavesOfType("file-explorer")[0];
          if (fileExplorer && fileExplorer.view) {
            const explorerView = fileExplorer.view;
            if (explorerView.revealInFolder) {
              explorerView.revealInFolder(file);
            }
          }
        } else {
        }
      }
    } catch (error) {
    }
  }
  /**
   * Remove all Gossamer-specific event listeners and restore normal mode
   */
  removeGossamerEventListeners(svg) {
    this.gossamerEventHandlers.forEach((handler, key) => {
      const [eventType] = key.split("::");
      svg.removeEventListener(eventType, handler);
    });
    this.gossamerEventHandlers.clear();
  }
  /**
   * Setup Gossamer-specific event listeners
   * These are simpler and don't have conditionals - just Plot slice and dot interactions
   */
  setupGossamerEventListeners(svg) {
    this.removeGossamerEventListeners(svg);
    if (this.interactionController) {
      const { getModeDefinition: getModeDefinition2 } = (init_ModeRegistry(), __toCommonJS(ModeRegistry_exports));
      const { TimelineMode: TimelineMode2 } = (init_ModeDefinition(), __toCommonJS(ModeDefinition_exports));
      const modeDef = getModeDefinition2(TimelineMode2.GOSSAMER);
      this.interactionController.setupMode(modeDef, svg);
    }
  }
};
_RadialTimelineView.viewType = TIMELINE_VIEW_TYPE;
var RadialTimelineView = _RadialTimelineView;

// src/services/TimelineService.ts
var TimelineService = class {
  constructor(app, plugin) {
    this.refreshTimeout = null;
    this.pendingRequest = null;
    this.app = app;
    this.plugin = plugin;
  }
  getTimelineViews() {
    return this.app.workspace.getLeavesOfType(TIMELINE_VIEW_TYPE).map((leaf) => leaf.view).filter((v) => v instanceof RadialTimelineView);
  }
  /**
   * Schedule a render with change type tracking and batching
   * Multiple rapid calls will batch change types together
   */
  scheduleRender(changeTypes, delayMs = 100) {
    if (this.pendingRequest) {
      changeTypes.forEach((type) => this.pendingRequest.changeTypes.add(type));
    } else {
      this.pendingRequest = {
        changeTypes: new Set(changeTypes),
        requestedAt: Date.now(),
        priority: this.calculatePriority(changeTypes)
      };
    }
    if (this.refreshTimeout) {
      window.clearTimeout(this.refreshTimeout);
    }
    const effectiveDelay = this.pendingRequest.priority === 0 ? 0 : delayMs;
    this.refreshTimeout = window.setTimeout(() => {
      this.executeScheduledRender();
    }, effectiveDelay);
  }
  /**
   * Calculate priority for change types
   * Lower number = higher priority = shorter delay
   */
  calculatePriority(changeTypes) {
    if (changeTypes.includes("scene_data" /* SCENE_DATA */) || changeTypes.includes("mode" /* MODE */) || changeTypes.includes("settings" /* SETTINGS */)) {
      return 0;
    }
    if (changeTypes.includes("gossamer" /* GOSSAMER */)) {
      return 1;
    }
    return 2;
  }
  /**
   * Execute the scheduled render
   */
  executeScheduledRender() {
    if (!this.pendingRequest) return;
    const views = this.getTimelineViews();
    const activeLeaf = this.app.workspace.getActiveViewOfType(RadialTimelineView);
    if (activeLeaf) {
      activeLeaf.refreshTimeline();
    } else {
      const firstView = views[0];
      if (firstView) {
        firstView.refreshTimeline();
      }
    }
    this.pendingRequest = null;
    this.refreshTimeout = null;
  }
  /**
   * Legacy method for compatibility
   * @param file - File that triggered the refresh (null = settings change or manual refresh)
   */
  refreshTimelineIfNeeded(file, delayMs) {
    var _a;
    if (file && (!(file instanceof import_obsidian24.TFile) || file.extension !== "md")) return;
    const effectiveDelay = (_a = delayMs != null ? delayMs : this.plugin.settings.metadataRefreshDebounceMs) != null ? _a : 1e4;
    if (!file) {
      this.scheduleRender(["settings" /* SETTINGS */], effectiveDelay);
      return;
    }
    this.scheduleRender(["scene_data" /* SCENE_DATA */], effectiveDelay);
  }
  /**
   * Cancel any pending render
   */
  cancelPendingRender() {
    if (this.refreshTimeout) {
      window.clearTimeout(this.refreshTimeout);
      this.refreshTimeout = null;
    }
    this.pendingRequest = null;
  }
  /**
   * Activate or create the timeline view
   */
  async activateView() {
    const leaves = this.app.workspace.getLeavesOfType(TIMELINE_VIEW_TYPE);
    if (leaves.length > 0) {
      this.app.workspace.revealLeaf(leaves[0]);
      return;
    }
    const leaf = this.app.workspace.getLeaf("tab");
    await leaf.setViewState({
      type: TIMELINE_VIEW_TYPE,
      active: true
    });
    this.app.workspace.revealLeaf(leaf);
  }
};

// src/services/SceneDataService.ts
var import_obsidian25 = require("obsidian");
init_frontmatter();
init_date();
init_sceneHelpers();
init_text();
init_gossamer();

// src/utils/acts.ts
var MIN_ACTS = 3;
function getConfiguredActCount(settings) {
  const raw = settings == null ? void 0 : settings.actCount;
  if (typeof raw === "number" && Number.isFinite(raw)) {
    return Math.max(MIN_ACTS, Math.floor(raw));
  }
  return MIN_ACTS;
}
function parseActLabels(settings, actCount) {
  var _a;
  const raw = (_a = settings == null ? void 0 : settings.actLabelsRaw) != null ? _a : "";
  const labels = raw.split(",").map((label) => label.trim()).filter((label) => label.length > 0);
  if (labels.length === 0) return [];
  return labels.slice(0, actCount);
}
function shouldShowActLabels(settings) {
  var _a;
  return (_a = settings == null ? void 0 : settings.showActLabels) != null ? _a : true;
}
function clampActNumber(actNumber, actCount) {
  const n = typeof actNumber === "number" && Number.isFinite(actNumber) ? Math.floor(actNumber) : 1;
  if (n < 1) return 1;
  if (n > actCount) return actCount;
  return n;
}

// src/services/SceneDataService.ts
var PULSE_FLAG_METADATA_KEYS = [
  "Pulse Update",
  "PulseUpdate",
  "pulseupdate",
  "Beats Update",
  "BeatsUpdate",
  "beatsupdate",
  "Review Update",
  "ReviewUpdate",
  "reviewupdate"
];
function getPulseUpdateFromMetadata(metadata) {
  if (!metadata) return void 0;
  for (const key of PULSE_FLAG_METADATA_KEYS) {
    if (Object.prototype.hasOwnProperty.call(metadata, key)) {
      return metadata[key];
    }
  }
  return void 0;
}
var SceneDataService = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  /**
   * Update settings (called when settings change)
   */
  updateSettings(settings) {
    this.settings = settings;
  }
  /**
   * Get all scene data from the vault
   */
  async getSceneData(options) {
    var _a, _b, _c, _d;
    const filterBeats = (_a = options == null ? void 0 : options.filterBeatsBySystem) != null ? _a : true;
    const files = this.app.vault.getMarkdownFiles().filter((file) => {
      if (this.settings.sourcePath) {
        return file.path.startsWith(this.settings.sourcePath);
      }
      return true;
    });
    const scenes = [];
    const plotsToProcess = [];
    for (const file of files) {
      try {
        const rawMetadata = (_b = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _b.frontmatter;
        const mappings = this.settings.enableCustomMetadataMapping ? this.settings.frontmatterMappings : void 0;
        const metadata = rawMetadata ? normalizeFrontmatterKeys(rawMetadata, mappings) : void 0;
        if (metadata && metadata.Class === "Scene") {
          const whenStr = metadata.When;
          let when;
          if (typeof whenStr === "string") {
            const parsed = parseWhenField(whenStr);
            if (parsed) {
              when = parsed;
            }
          } else if (whenStr instanceof Date) {
            when = whenStr;
          }
          const hasValidWhen = when instanceof Date && !isNaN(when.getTime());
          const normalizedWhen = hasValidWhen ? when : void 0;
          const missingWhen = !hasValidWhen;
          const isoDate = hasValidWhen && normalizedWhen ? normalizedWhen.toISOString().split("T")[0] : "";
          const subplots = metadata.Subplot ? Array.isArray(metadata.Subplot) ? metadata.Subplot : [metadata.Subplot] : ["Main Plot"];
          const actValue = metadata.Act;
          const configuredActs = getConfiguredActCount(this.settings);
          const actNumberRaw = actValue !== void 0 && actValue !== null && actValue !== "" ? Number(actValue) : 1;
          const validActNumber = clampActNumber(actNumberRaw, configuredActs);
          const sceneTitle = file.basename;
          for (const subplot of subplots) {
            const durationValue = metadata.Duration;
            const duration = durationValue !== void 0 && durationValue !== null ? String(durationValue) : void 0;
            const pulseUpdate = getPulseUpdateFromMetadata(metadata);
            const pulseLastUpdated = (_c = metadata["Pulse Last Updated"]) != null ? _c : metadata["Beats Last Updated"];
            const rawCharacter = metadata.Character;
            const characterList = Array.isArray(rawCharacter) ? rawCharacter.map((c) => stripWikiLinks(c)) : rawCharacter ? [stripWikiLinks(rawCharacter)] : void 0;
            const rawPov = metadata.POV;
            let povField;
            if (Array.isArray(rawPov)) {
              for (const entry of rawPov) {
                const candidate = typeof entry === "string" ? entry : entry !== void 0 && entry !== null ? String(entry) : "";
                const trimmed = candidate.trim();
                if (trimmed.length > 0) {
                  povField = trimmed;
                  break;
                }
              }
            } else if (typeof rawPov === "string") {
              const trimmed = rawPov.trim();
              if (trimmed.length > 0) {
                povField = trimmed;
              }
            } else if (rawPov !== void 0 && rawPov !== null) {
              const converted = String(rawPov).trim();
              if (converted.length > 0) {
                povField = converted;
              }
            }
            scenes.push({
              date: isoDate,
              when: normalizedWhen,
              missingWhen,
              path: file.path,
              title: sceneTitle,
              number: void 0,
              subplot,
              act: String(validActNumber),
              actNumber: validActNumber,
              pov: povField,
              location: metadata.Place,
              Character: characterList,
              synopsis: metadata.Synopsis,
              status: metadata.Status,
              "Publish Stage": metadata["Publish Stage"],
              due: metadata.Due,
              pendingEdits: metadata["Pending Edits"],
              Duration: duration,
              // AI Scene Analysis fields - handle both string and array formats from YAML
              "previousSceneAnalysis": Array.isArray(metadata["previousSceneAnalysis"]) ? metadata["previousSceneAnalysis"].join("\n") : metadata["previousSceneAnalysis"],
              "currentSceneAnalysis": Array.isArray(metadata["currentSceneAnalysis"]) ? metadata["currentSceneAnalysis"].join("\n") : metadata["currentSceneAnalysis"],
              "nextSceneAnalysis": Array.isArray(metadata["nextSceneAnalysis"]) ? metadata["nextSceneAnalysis"].join("\n") : metadata["nextSceneAnalysis"],
              itemType: "Scene",
              "Pulse Update": normalizeBooleanValue(pulseUpdate),
              "Pulse Last Updated": typeof pulseLastUpdated === "string" ? pulseLastUpdated : void 0
            });
          }
        } else if (metadata && metadata.Class === "Backdrop") {
          const whenStr = metadata.When;
          let when;
          if (typeof whenStr === "string") {
            const parsed = parseWhenField(whenStr);
            if (parsed) when = parsed;
          } else if (whenStr instanceof Date) {
            when = whenStr;
          }
          const durationValue = metadata.Duration;
          const duration = durationValue !== void 0 && durationValue !== null ? String(durationValue) : void 0;
          const isoDate = when ? when.toISOString().split("T")[0] : "";
          scenes.push({
            date: isoDate,
            when,
            path: file.path,
            title: file.basename,
            // Use filename as title, as requested
            synopsis: metadata.Synopsis,
            // For hover
            Duration: duration,
            End: metadata.End,
            itemType: "Backdrop"
            // No subplot assignment - rendered in special Backdrop Ring
          });
        } else if (metadata && isStoryBeat(metadata.Class)) {
          const actValue = metadata.Act;
          const configuredActs = getConfiguredActCount(this.settings);
          const actNumberRaw = actValue !== void 0 && actValue !== null && actValue !== "" ? Number(actValue) : 1;
          const validActNumber = clampActNumber(actNumberRaw, configuredActs);
          plotsToProcess.push({ file, metadata, validActNumber });
        }
      } catch (error) {
        console.error(`Error processing file ${file.path}:`, error);
      }
    }
    this.applyDominantSubplotPreferences(scenes);
    const filteredScenes = this.filterScenesByDominantSubplot(scenes);
    const scenesByDate = /* @__PURE__ */ new Map();
    const processedPaths = /* @__PURE__ */ new Set();
    for (const scene of filteredScenes) {
      const dateKey = scene.date;
      const pathDateKey = `${scene.path}-${dateKey}`;
      if (processedPaths.has(pathDateKey)) {
        continue;
      }
      processedPaths.add(pathDateKey);
      if (!scenesByDate.has(dateKey)) {
        scenesByDate.set(dateKey, []);
      }
      scenesByDate.get(dateKey).push(scene);
    }
    let beatsToProcess = plotsToProcess;
    if (filterBeats && this.settings.beatSystem) {
      const beatsWithModel = beatsToProcess.map((p) => ({
        original: p,
        "Beat Model": p.metadata["Beat Model"]
      }));
      const filtered = filterBeatsBySystem(beatsWithModel, this.settings.beatSystem, this.settings.customBeatSystemName);
      beatsToProcess = filtered.map((f) => f.original);
    }
    for (const { file, metadata, validActNumber } of beatsToProcess) {
      const whenStr = metadata.When;
      let when;
      if (typeof whenStr === "string") {
        const parsed = parseWhenField(whenStr);
        if (parsed) {
          when = parsed;
        }
      } else if (whenStr instanceof Date) {
        when = whenStr;
      }
      const dateKey = when && !isNaN(when.getTime()) ? when.toISOString().split("T")[0] : "";
      const beatModel = metadata["Beat Model"] || this.settings.beatSystem || "";
      filteredScenes.push({
        date: dateKey,
        when,
        path: file.path,
        title: (_d = metadata.Title) != null ? _d : file.basename,
        subplot: "Main Plot",
        // Beats always use Main Plot for outermost ring
        act: String(validActNumber),
        actNumber: validActNumber,
        synopsis: metadata.Synopsis,
        Description: metadata.Description,
        "Beat Model": beatModel,
        Range: metadata.Range,
        "Suggest Placement": metadata["Suggest Placement"],
        itemType: "Beat",
        // Modern standard - renderer should use isBeatNote() helper
        // Include all Gossamer score fields (Gossamer1-30)
        Gossamer1: metadata.Gossamer1,
        Gossamer2: metadata.Gossamer2,
        Gossamer3: metadata.Gossamer3,
        Gossamer4: metadata.Gossamer4,
        Gossamer5: metadata.Gossamer5,
        "Publish Stage": metadata["Publish Stage"]
      });
    }
    return filteredScenes;
  }
  /**
   * Apply dominant subplot preferences from settings
   */
  applyDominantSubplotPreferences(scenes) {
    if (!this.settings.dominantSubplots) return;
    const scenesByPath = /* @__PURE__ */ new Map();
    scenes.forEach((scene) => {
      if (!scene.path) return;
      if (!scenesByPath.has(scene.path)) {
        scenesByPath.set(scene.path, []);
      }
      scenesByPath.get(scene.path).push(scene);
    });
    Object.entries(this.settings.dominantSubplots).forEach(([path, dominantSubplot]) => {
      const scenesForPath = scenesByPath.get(path);
      if (!scenesForPath || scenesForPath.length <= 1) return;
      scenesForPath.forEach((scene) => {
        scene._isDominantSubplot = scene.subplot === dominantSubplot;
      });
    });
  }
  /**
   * Keep all scenes but mark the dominant subplot for visual coloring
   * (this does NOT filter - all subplot versions are kept for rendering in their respective rings)
   */
  filterScenesByDominantSubplot(scenes) {
    return scenes;
  }
  /**
   * Check if a file path is a scene file
   */
  isSceneFile(filePath) {
    var _a;
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian25.TFile)) return false;
    const metadata = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
    if (!metadata) return false;
    return metadata.Class === "Scene";
  }
};

// src/utils/constants.ts
var STATUS_COLORS = {
  Working: "var(--rt-color-working)",
  Todo: "var(--rt-color-todo)",
  Empty: "var(--rt-color-empty)",
  Due: "var(--rt-color-due)",
  Complete: "var(--rt-color-complete)"
};
var STAGE_ORDER = ["Zero", "Author", "House", "Press"];
var STAGES_FOR_GRID = ["Zero", "Author", "House", "Press"];
var STATUSES_FOR_GRID = ["Todo", "Working", "Due", "Completed"];

// src/utils/colour.ts
function getMostAdvancedStageColor(scenes, publishStageColors) {
  const stageOrder = [...STAGE_ORDER];
  let maxStageIndex = 0;
  scenes.forEach((scene) => {
    const rawStage = scene["Publish Stage"];
    const stage = STAGE_ORDER.includes(rawStage) ? rawStage : "Zero";
    const currentIndex = stageOrder.indexOf(stage);
    if (currentIndex > maxStageIndex) {
      maxStageIndex = currentIndex;
    }
  });
  const maxStageName = stageOrder[maxStageIndex];
  return publishStageColors[maxStageName] || publishStageColors.Zero;
}
function hexToRgb(hex) {
  const match = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  if (!match) return null;
  return {
    r: parseInt(match[1], 16),
    g: parseInt(match[2], 16),
    b: parseInt(match[3], 16)
  };
}
function rgbToHsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  let h = 0, s = 0, l = (max + min) / 2;
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return { h, s, l };
}
function hslToRgb(h, s, l) {
  let r, g, b;
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p2, q2, t2) => {
      if (t2 < 0) t2 += 1;
      if (t2 > 1) t2 -= 1;
      if (t2 < 1 / 6) return p2 + (q2 - p2) * 6 * t2;
      if (t2 < 1 / 2) return q2;
      if (t2 < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
      return p2;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
}
function rgbToHex(r, g, b) {
  return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}
function lightenColor(hex, percent) {
  const num = parseInt(hex.replace("#", ""), 16);
  const r = num >> 16;
  const g = num >> 8 & 255;
  const b = num & 255;
  const mixRatio = Math.min(1, percent / 100);
  const newR = Math.min(255, Math.round(r + (255 - r) * mixRatio));
  const newG = Math.min(255, Math.round(g + (255 - g) * mixRatio));
  const newB = Math.min(255, Math.round(b + (255 - b) * mixRatio));
  return `#${(1 << 24 | newR << 16 | newG << 8 | newB).toString(16).slice(1)}`;
}

// src/SynopsisManager.ts
init_text();

// src/synopsis/SynopsisData.ts
init_text();
function getPublishStageStyle(stageInput, publishStageColors) {
  const stage = stageInput || "Zero";
  const stageClass = `rt-title-stage-${String(stage).toLowerCase()}`;
  const titleColor = publishStageColors[stage] || "#808080";
  return { stageClass, titleColor };
}
function splitSynopsisLines(contentLines) {
  let synopsisEndIndex = contentLines.findIndex((line) => line === "\xA0" || line === "");
  if (synopsisEndIndex === -1) synopsisEndIndex = Math.max(0, contentLines.length - 2);
  const metadataItems = contentLines.slice(synopsisEndIndex + 1);
  return { synopsisEndIndex, metadataItems };
}
function decodeContentLines(lines) {
  return lines.map((line) => decodeHtmlEntities(line));
}
function isOverdueAndIncomplete(scene, today = /* @__PURE__ */ new Date()) {
  const dueString = scene.due;
  if (!dueString || typeof dueString !== "string") return false;
  const parts = dueString.split("-").map(Number);
  if (parts.length !== 3 || parts.some(isNaN)) return false;
  const [dueYear, dueMonth1, dueDay] = parts;
  const dueMonth = dueMonth1 - 1;
  const todayY = today.getFullYear();
  const todayM = today.getMonth();
  const todayD = today.getDate();
  let isOverdue = false;
  if (dueYear < todayY) isOverdue = true;
  else if (dueYear === todayY) {
    if (dueMonth < todayM) isOverdue = true;
    else if (dueMonth === todayM) {
      if (dueDay < todayD) isOverdue = true;
    }
  }
  let normalizedStatus = "";
  if (scene.status) {
    if (Array.isArray(scene.status) && scene.status.length > 0) normalizedStatus = String(scene.status[0]).trim().toLowerCase();
    else if (typeof scene.status === "string") normalizedStatus = scene.status.trim().toLowerCase();
  }
  const isComplete = normalizedStatus === "complete" || normalizedStatus === "done";
  return isOverdue && !isComplete;
}

// src/synopsis/SynopsisView.ts
function createSynopsisContainer(sceneId, scenePath) {
  const containerGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
  containerGroup.setAttribute("class", "rt-scene-info rt-info-container");
  containerGroup.setAttribute("data-for-scene", sceneId);
  if (scenePath) {
    containerGroup.setAttribute("data-scene-path", encodeURIComponent(scenePath));
  }
  return containerGroup;
}
function createTextGroup() {
  const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
  group.setAttribute("class", "rt-synopsis-text");
  return group;
}
function createText(x, y, cls, text) {
  const el = document.createElementNS("http://www.w3.org/2000/svg", "text");
  el.setAttribute("class", cls);
  el.setAttribute("x", String(x));
  el.setAttribute("y", String(y));
  el.setAttribute("text-anchor", "start");
  el.textContent = text;
  return el;
}

// src/SynopsisManager.ts
init_planetaryTime();
init_LayoutConstants();
init_sceneHelpers();
init_date();

// src/utils/readability.ts
init_LayoutConstants();
function getReadabilityScale(options) {
  const value = options == null ? void 0 : options.readabilityScale;
  if (value && value in READABILITY_SCALES) return value;
  return "normal";
}
function getReadabilityMultiplier(settings) {
  const scale = getReadabilityScale(settings);
  return READABILITY_SCALES[scale];
}

// src/SynopsisManager.ts
init_ChronologueShiftController();
var _SynopsisManager = class _SynopsisManager {
  constructor(plugin) {
    this.plugin = plugin;
  }
  getReadabilityScale() {
    return getReadabilityMultiplier(this.plugin.settings);
  }
  parseHtmlSafely(html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(`<div>${html}</div>`, "text/html");
    const container = doc.querySelector("div");
    const fragment = document.createDocumentFragment();
    if (container) {
      while (container.firstChild) {
        fragment.appendChild(container.firstChild);
      }
    }
    return fragment;
  }
  /**
   * Format date from When field to friendly format for display
   * @param when Date object from scene.when
   * @returns Formatted date string (e.g., "Aug 1, 1812 @ 8AM" or "Apr 6, 1812 @ Noon" or "Apr 6, 1812 @ Midnight")
   */
  formatDateForDisplay(when) {
    if (!when) {
      return "";
    }
    if (!(when instanceof Date) || Number.isNaN(when.getTime())) {
      throw new Error("formatDateForDisplay requires a valid Date object");
    }
    const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const month = months[when.getMonth()];
    const day = when.getDate();
    const year = when.getFullYear();
    const hours = when.getHours();
    const minutes = when.getMinutes();
    let dateStr = `${month} ${day}, ${year}`;
    if (hours === 0 && minutes === 0) {
      dateStr += " @ Midnight";
    } else if (hours === 12 && minutes === 0) {
      dateStr += " @ Noon";
    } else {
      const period = hours >= 12 ? "PM" : "AM";
      const displayHours = hours % 12 === 0 ? 12 : hours % 12;
      if (minutes === 0) {
        dateStr += ` @ ${displayHours}${period}`;
      } else {
        dateStr += ` @ ${displayHours}:${String(minutes).padStart(2, "0")}${period}`;
      }
    }
    return dateStr;
  }
  buildPlanetaryLine(scene) {
    if (!scene.when) return null;
    const settings = this.plugin.settings;
    const profile = getActivePlanetaryProfile(settings);
    if (!profile) return null;
    const conversion = convertFromEarth(scene.when, profile);
    if (!conversion) return null;
    const label = (profile.label || "LOCAL").toUpperCase();
    return `${label}: ${conversion.formatted}`;
  }
  /**
   * Add title content to a text element safely
   * @param titleContent The title content to add
   * @param titleTextElement The text element to add to
   * @param titleColor The color for the title
   * @param sceneNumber Optional scene number from frontmatter
   * @param sceneDate Optional scene date from frontmatter (should be pre-formatted)
   * @param sceneDuration Optional scene duration from frontmatter
   */
  /**
   * Add title content to the title text element
   * Returns a metadata text element if date/duration exist, otherwise null
   */
  addTitleContent(titleContent, titleTextElement, titleColor, sceneNumber, sceneDate, sceneDuration) {
    if (titleContent.includes("<tspan")) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(`<svg><text>${titleContent}</text></svg>`, "image/svg+xml");
      const textNode = doc.querySelector("text");
      if (!textNode) {
        const fallbackTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        fallbackTspan.setAttribute("fill", titleColor);
        fallbackTspan.appendChild(document.createTextNode(titleContent));
        titleTextElement.appendChild(fallbackTspan);
        return null;
      }
      Array.from(textNode.childNodes).forEach((node) => {
        if (node.nodeType === Node.ELEMENT_NODE && node.tagName.toLowerCase() === "tspan") {
          const tspan = node;
          const svgTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
          Array.from(tspan.attributes).forEach((attr) => {
            svgTspan.setAttribute(attr.name, attr.value);
          });
          if (tspan instanceof HTMLElement || tspan instanceof SVGElement) {
            const style = tspan.getAttribute("style");
            if (style) {
              svgTspan.setAttribute("style", style);
            }
          }
          svgTspan.textContent = tspan.textContent;
          titleTextElement.appendChild(svgTspan);
        } else if (node.nodeType === Node.TEXT_NODE) {
          if (node.textContent) {
            titleTextElement.appendChild(document.createTextNode(node.textContent));
          }
        }
      });
      return null;
    } else {
      const titleParts = parseSceneTitleComponents(titleContent, sceneNumber, sceneDate, sceneDuration);
      if (titleParts.sceneNumber) {
        const numTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        numTspan.classList.add("rt-scene-title-bold");
        numTspan.setAttribute("data-item-type", "title");
        numTspan.style.setProperty("--rt-dynamic-color", titleColor);
        numTspan.textContent = `${titleParts.sceneNumber} `;
        titleTextElement.appendChild(numTspan);
      }
      const mainTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      mainTspan.classList.add("rt-scene-title-bold");
      mainTspan.setAttribute("data-item-type", "title");
      mainTspan.style.setProperty("--rt-dynamic-color", titleColor);
      mainTspan.textContent = titleParts.title;
      titleTextElement.appendChild(mainTspan);
      if (titleParts.date || titleParts.duration) {
        const metadataElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
        metadataElement.setAttribute("class", "rt-info-text rt-title-text-main rt-title-date-time");
        metadataElement.setAttribute("x", "0");
        metadataElement.setAttribute("y", "0");
        metadataElement.setAttribute("text-anchor", "start");
        metadataElement.setAttribute("data-metadata-block", "true");
        metadataElement.setAttribute("data-column-gap", `8px`);
        if (titleParts.date) {
          const dateTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
          dateTspan.setAttribute("class", "rt-date-text");
          dateTspan.setAttribute("data-item-type", "date");
          dateTspan.setAttribute("data-column-role", "date");
          dateTspan.setAttribute("dy", `-16px`);
          dateTspan.textContent = titleParts.date;
          metadataElement.appendChild(dateTspan);
        }
        if (titleParts.duration) {
          const durationTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
          durationTspan.setAttribute("class", "rt-duration-text");
          durationTspan.setAttribute("data-item-type", "duration");
          durationTspan.setAttribute("data-column-role", "duration");
          durationTspan.setAttribute("x", "0");
          durationTspan.setAttribute("dy", titleParts.date ? `16px` : "0");
          durationTspan.textContent = titleParts.duration;
          metadataElement.appendChild(durationTspan);
        }
        return metadataElement;
      }
    }
    return null;
  }
  /**
   * Create a DOM element for a scene synopsis with consistent formatting
   * @returns An SVG group element containing the formatted synopsis
   */
  generateElement(scene, contentLines, sceneId, subplotIndexResolver) {
    var _a;
    const { stageClass, titleColor } = getPublishStageStyle(scene["Publish Stage"], this.plugin.settings.publishStageColors);
    const fontScale = this.getReadabilityScale();
    const { synopsisEndIndex, metadataItems } = splitSynopsisLines(contentLines);
    const decodedContentLines = decodeContentLines(contentLines);
    const getSubplotColor = (subplot, sceneIdentifier) => {
      const resolveCssVariable = (index2) => {
        const normalizedIndex = Math.max(0, index2) % 15;
        const varName = `--rt-subplot-colors-${normalizedIndex}`;
        const value = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        if (!value) {
          throw new Error(`CSS variable ${varName} is not defined for subplot coloring.`);
        }
        return value;
      };
      const resolveIndex = () => {
        var _a2;
        if (subplotIndexResolver) {
          const resolved = subplotIndexResolver(subplot);
          if (!Number.isFinite(resolved)) {
            throw new Error(`Subplot index resolver returned an invalid value for "${subplot}".`);
          }
          return resolved;
        }
        const sceneGroup = (_a2 = document.getElementById(sceneIdentifier)) == null ? void 0 : _a2.closest(".scene-group");
        if (!sceneGroup) {
          throw new Error(`Scene group not found for synopsis ${sceneIdentifier}.`);
        }
        const idxAttr = sceneGroup.getAttribute("data-subplot-color-index") || sceneGroup.getAttribute("data-subplot-index");
        if (!idxAttr) {
          throw new Error(`Scene group for ${sceneIdentifier} is missing data-subplot-index.`);
        }
        const parsed = parseInt(idxAttr, 10);
        if (Number.isNaN(parsed)) {
          throw new Error(`Invalid subplot index "${idxAttr}" for scene ${sceneIdentifier}.`);
        }
        return parsed;
      };
      const index = resolveIndex();
      return resolveCssVariable(index);
    };
    const styleSource = getComputedStyle(document.documentElement);
    const synopsisLineHeight = parseFloat(styleSource.getPropertyValue("--rt-synopsis-line-height"));
    const pulseLineHeightRaw = parseFloat(styleSource.getPropertyValue("--rt-pulse-line-height"));
    const metadataLineHeight = parseFloat(styleSource.getPropertyValue("--rt-synopsis-metadata-line-height"));
    const lineHeight = synopsisLineHeight * fontScale;
    const pulseLineHeight = pulseLineHeightRaw * fontScale;
    const containerGroup = createSynopsisContainer(sceneId, scene.path);
    containerGroup.setAttribute("data-stage-color", titleColor);
    const synopsisTextGroup = createTextGroup();
    containerGroup.appendChild(synopsisTextGroup);
    const titleContent = decodedContentLines[0];
    const titleTextElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
    titleTextElement.setAttribute("class", `rt-info-text rt-title-text-main`);
    titleTextElement.setAttribute("x", "0");
    titleTextElement.setAttribute("y", "0");
    const currentMode = this.plugin.settings.currentMode || "narrative";
    const isGossamerMode = currentMode === "gossamer";
    const isBackdrop = scene.itemType === "Backdrop";
    const shouldShowDate = scene.when && !(scene.itemType === "Plot" && isGossamerMode);
    let formattedDate;
    if (shouldShowDate && scene.when) {
      if (isAlienModeActive()) {
        const settings = this.plugin.settings;
        const profile = getActivePlanetaryProfile(settings);
        const conversion = profile ? convertFromEarth(scene.when, profile) : null;
        if (conversion) {
          formattedDate = conversion.formatted;
        } else {
          formattedDate = this.formatDateForDisplay(scene.when);
        }
      } else {
        formattedDate = this.formatDateForDisplay(scene.when);
      }
    }
    let duration = scene.Duration ? scene.Duration : void 0;
    if (isBackdrop && scene.End) {
      const endDate = parseWhenField(scene.End);
      if (endDate) {
        duration = `to ${this.formatDateForDisplay(endDate)}`;
      } else {
        duration = `to ${scene.End}`;
      }
    }
    const metadataElement = this.addTitleContent(titleContent, titleTextElement, titleColor, scene.number, formattedDate, duration);
    synopsisTextGroup.appendChild(titleTextElement);
    if (metadataElement) {
      synopsisTextGroup.appendChild(metadataElement);
    }
    let extraLineCount = 0;
    const appendInfoLine = (className, text) => {
      const y = (1 + extraLineCount) * metadataLineHeight;
      synopsisTextGroup.appendChild(createText(0, y, className, text));
      extraLineCount += 1;
    };
    const appendPlanetaryLine = (text) => {
      const y = (1 + extraLineCount) * metadataLineHeight;
      const indentX = 6;
      const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
      const textEl = createText(0, y, "rt-info-text rt-title-text-secondary rt-planetary-time-text", text);
      textEl.setAttribute("dx", String(indentX));
      textEl.style.fill = titleColor;
      const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect.setAttribute("class", "rt-planetary-outline");
      rect.style.stroke = titleColor;
      const charWidth = 7.5;
      const estWidth = text.length * charWidth + indentX;
      const estHeight = 13;
      const padX = 6;
      const padY = 2;
      const yOffset = -1;
      rect.setAttribute("x", "0");
      rect.setAttribute("y", String(y - estHeight + padY + yOffset));
      rect.setAttribute("width", String(estWidth + padX));
      rect.setAttribute("height", String(estHeight + padY * 2));
      rect.setAttribute("rx", "6");
      rect.setAttribute("ry", "6");
      group.appendChild(rect);
      group.appendChild(textEl);
      synopsisTextGroup.appendChild(group);
      extraLineCount += 1;
    };
    const missingWhenMessage = this.buildMissingWhenMessage(scene);
    if (missingWhenMessage) {
      appendInfoLine("rt-info-text rt-title-text-secondary rt-missing-when-text", missingWhenMessage);
    }
    const planetaryLine = this.buildPlanetaryLine(scene);
    if (planetaryLine) {
      appendPlanetaryLine(planetaryLine);
    }
    const dueString = scene.due;
    if (dueString && isOverdueAndIncomplete(scene)) {
      appendInfoLine("rt-info-text rt-title-text-secondary rt-overdue-text", `Overdue: ${dueString}`);
    }
    const pendingEdits = scene.pendingEdits && typeof scene.pendingEdits === "string" ? scene.pendingEdits.trim() : "";
    if (pendingEdits) {
      const maxWidth = 500 * fontScale;
      const lines = splitIntoBalancedLines(pendingEdits, maxWidth, fontScale);
      for (let i = 0; i < lines.length; i++) {
        const y = (1 + extraLineCount) * metadataLineHeight + i * metadataLineHeight;
        const text = `${i === 0 ? "Revisions: " : ""}${lines[i]}`;
        synopsisTextGroup.appendChild(createText(0, y, "rt-info-text rt-title-text-secondary rt-revisions-text", text));
      }
      extraLineCount += lines.length;
    }
    for (let i = 1; i < synopsisEndIndex; i++) {
      const lineContent = decodedContentLines[i];
      const isGossamerLine = contentLines[i].includes("<gossamer>") && contentLines[i].includes("</gossamer>");
      const lineY = (i + extraLineCount) * lineHeight;
      const synopsisLineElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
      if (isGossamerLine) {
        synopsisLineElement.setAttribute("class", "rt-info-text rt-title-text-main rt-gossamer-score-line");
        synopsisLineElement.setAttribute("x", "0");
        synopsisLineElement.setAttribute("y", String(lineY));
        const gossamerContent = contentLines[i].replace(/<gossamer>/g, "").replace(/<\/gossamer>/g, "");
        const gossamerTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        gossamerTspan.classList.add("rt-scene-title-bold");
        gossamerTspan.setAttribute("data-item-type", "title");
        gossamerTspan.style.setProperty("--rt-dynamic-color", titleColor);
        gossamerTspan.textContent = gossamerContent;
        synopsisLineElement.appendChild(gossamerTspan);
      } else {
        synopsisLineElement.setAttribute("class", "rt-info-text rt-title-text-secondary");
        synopsisLineElement.setAttribute("x", "0");
        synopsisLineElement.setAttribute("y", String(lineY));
        if (lineContent.includes("<tspan")) {
          this.processContentWithTspans(lineContent, synopsisLineElement);
        } else {
          synopsisLineElement.textContent = lineContent;
        }
      }
      synopsisTextGroup.appendChild(synopsisLineElement);
    }
    if (metadataItems.length > 0) {
      const addSpacer = (yPosition, height) => {
        const spacerElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
        spacerElement.setAttribute("class", "synopsis-spacer");
        spacerElement.setAttribute("x", "0");
        spacerElement.setAttribute("y", String(yPosition));
        spacerElement.setAttribute("font-size", "2px");
        spacerElement.textContent = "\xA0";
        spacerElement.classList.add("rt-invisible-spacer");
        synopsisTextGroup.appendChild(spacerElement);
        return yPosition;
      };
      const synopsisBottomY = synopsisEndIndex * lineHeight;
      let currentMetadataY = addSpacer(synopsisBottomY, 0);
      const showTripletNeighbors = (_a = this.plugin.settings.showFullTripletAnalysis) != null ? _a : true;
      if (this.plugin.settings.enableAiSceneAnalysis && showTripletNeighbors && scene["previousSceneAnalysis"]) {
        const beatsY = currentMetadataY;
        const beatsText = scene["previousSceneAnalysis"] || "";
        const linesAdded = this.formatBeatsText(beatsText, "previousSceneAnalysis", synopsisTextGroup, beatsY, pulseLineHeight, 0);
        currentMetadataY = beatsY + linesAdded * pulseLineHeight;
        if (linesAdded > 0) {
          currentMetadataY = addSpacer(currentMetadataY, 0);
        }
      }
      if (this.plugin.settings.enableAiSceneAnalysis && scene["currentSceneAnalysis"]) {
        const beatsY = currentMetadataY;
        const beatsText = scene["currentSceneAnalysis"] || "";
        const linesAdded = this.formatBeatsText(beatsText, "currentSceneAnalysis", synopsisTextGroup, beatsY, pulseLineHeight, 0);
        currentMetadataY = beatsY + linesAdded * pulseLineHeight;
        if (linesAdded > 0) {
          currentMetadataY = addSpacer(currentMetadataY, 0);
        }
      }
      if (this.plugin.settings.enableAiSceneAnalysis && showTripletNeighbors && scene["nextSceneAnalysis"]) {
        const beatsY = currentMetadataY;
        const beatsText = scene["nextSceneAnalysis"] || "";
        const linesAdded = this.formatBeatsText(beatsText, "nextSceneAnalysis", synopsisTextGroup, beatsY, pulseLineHeight, 0);
        currentMetadataY = beatsY + linesAdded * pulseLineHeight;
        if (linesAdded > 0) {
          currentMetadataY = addSpacer(currentMetadataY, 0);
        }
      }
      const subplotStartY = currentMetadataY;
      const decodedMetadataItems = metadataItems.map((item) => decodeHtmlEntities(item));
      if (decodedMetadataItems.length > 0 && decodedMetadataItems[0] && decodedMetadataItems[0].trim().length > 0) {
        const subplots = decodedMetadataItems[0].split(", ").filter((s) => s.trim().length > 0);
        if (subplots.length > 0) {
          const subplotTextElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
          subplotTextElement.setAttribute("class", "rt-info-text rt-metadata-text");
          subplotTextElement.setAttribute("x", "0");
          subplotTextElement.setAttribute("y", String(subplotStartY));
          subplots.forEach((subplot, j) => {
            const color = getSubplotColor(subplot.trim(), sceneId);
            const subplotText = subplot.trim();
            const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
            tspan.setAttribute("data-item-type", "subplot");
            tspan.style.setProperty("--rt-dynamic-color", color);
            tspan.textContent = subplotText;
            subplotTextElement.appendChild(tspan);
            if (j < subplots.length - 1) {
              const comma = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
              comma.setAttribute("fill", "var(--text-muted)");
              comma.textContent = ", ";
              subplotTextElement.appendChild(comma);
            }
          });
          synopsisTextGroup.appendChild(subplotTextElement);
        }
      }
      if (decodedMetadataItems.length > 1 && decodedMetadataItems[1] && decodedMetadataItems[1].trim().length > 0) {
        const characterY = subplotStartY + lineHeight;
        const characterList = decodedMetadataItems[1].split(", ").filter((c) => c.trim().length > 0);
        if (characterList.length > 0) {
          const CHARACTER_COLOR_DEFAULT = "#666666";
          const CHARACTER_COLOR_POV = "#000000";
          const characterTextElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
          characterTextElement.setAttribute("class", "rt-info-text rt-metadata-text");
          characterTextElement.setAttribute("x", "0");
          characterTextElement.setAttribute("y", String(characterY));
          characterList.forEach((character, j) => {
            var _a2;
            const trimmedChar = character.trim();
            let baselineRaised = false;
            const markerMatch = trimmedChar.match(/>pov(?:=([^<]+))<$/i);
            const povLabel = markerMatch ? ((_a2 = markerMatch[1]) == null ? void 0 : _a2.trim()) || "POV" : void 0;
            const cleanedText = markerMatch ? trimmedChar.replace(/\s*>pov(?:=[^<]+)?<\s*/i, "").trim() : trimmedChar;
            const color = povLabel ? CHARACTER_COLOR_POV : CHARACTER_COLOR_DEFAULT;
            if (cleanedText) {
              const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
              tspan.setAttribute("data-item-type", "character");
              tspan.style.setProperty("--rt-dynamic-color", color);
              if (povLabel) {
                tspan.classList.add("rt-pov-character");
              }
              tspan.textContent = cleanedText;
              characterTextElement.appendChild(tspan);
            }
            if (povLabel) {
              const povTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
              povTspan.setAttribute("class", "rt-pov-marker");
              povTspan.setAttribute("dy", "-8px");
              povTspan.style.setProperty("--rt-dynamic-color", color);
              povTspan.textContent = povLabel;
              characterTextElement.appendChild(povTspan);
              baselineRaised = true;
            }
            if (j < characterList.length - 1) {
              const comma = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
              comma.setAttribute("fill", "var(--text-muted)");
              if (baselineRaised) {
                comma.setAttribute("dy", "8px");
              }
              comma.textContent = ", ";
              characterTextElement.appendChild(comma);
            } else if (baselineRaised) {
              const resetTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
              resetTspan.setAttribute("dy", "8px");
              resetTspan.textContent = "";
              characterTextElement.appendChild(resetTspan);
            }
          });
          synopsisTextGroup.appendChild(characterTextElement);
        }
      }
    }
    return containerGroup;
  }
  /**
   * Generate SVG string from DOM element (temporary compatibility method)
   */
  generateHTML(scene, contentLines, sceneId) {
    const element = this.generateElement(scene, contentLines, sceneId);
    const serializer = new XMLSerializer();
    return serializer.serializeToString(element);
  }
  /**
   * Update the position of a synopsis based on mouse position
   */
  updatePosition(synopsis, event, svg, sceneId) {
    if (!(synopsis instanceof SVGElement)) {
      throw new Error("Synopsis element must be an SVGElement.");
    }
    if (!svg) {
      throw new Error("SVG root is required to position synopsis content.");
    }
    const pt = svg.createSVGPoint();
    pt.x = event.clientX;
    pt.y = event.clientY;
    const ctm = svg.getScreenCTM();
    if (!ctm) {
      throw new Error("Unable to compute screen CTM for timeline SVG.");
    }
    const svgP = pt.matrixTransform(ctm.inverse());
    const quadrant = this.getQuadrant(svgP.x, svgP.y);
    const currentMode = this.plugin.settings.currentMode || "narrative";
    const isChronologueMode = currentMode === "chronologue";
    const isSubplotMode = currentMode === "subplot";
    const readabilityScale = getReadabilityScale(this.plugin.settings);
    const subplotOuterRadius = isChronologueMode ? SUBPLOT_OUTER_RADIUS_CHRONOLOGUE : isSubplotMode ? SUBPLOT_OUTER_RADIUS_MAINPLOT : SUBPLOT_OUTER_RADIUS_STANDARD[readabilityScale];
    const adjustedRadius = subplotOuterRadius - SYNOPSIS_INSET;
    synopsis.removeAttribute("style");
    synopsis.classList.remove("rt-synopsis-q1", "rt-synopsis-q2", "rt-synopsis-q3", "rt-synopsis-q4");
    const position = this.getPositionForQuadrant(quadrant, adjustedRadius);
    synopsis.classList.add(`rt-synopsis-${position.quadrantClass}`);
    const y = position.y;
    if (Math.abs(y) >= adjustedRadius) {
      throw new Error(`Synopsis y-position ${y} exceeds radius ${adjustedRadius}`);
    }
    const diff = adjustedRadius * adjustedRadius - y * y;
    if (diff < 0) {
      throw new Error("Cannot compute synopsis x-position due to invalid radius difference.");
    }
    const baseX = Math.sqrt(diff);
    const x = position.isRightAligned ? baseX : -baseX;
    synopsis.setAttribute("transform", `translate(${x}, ${y})`);
    synopsis.classList.add("rt-visible");
    synopsis.setAttribute("opacity", "1");
    synopsis.setAttribute("pointer-events", "all");
    this.positionTextElements(synopsis, position.isRightAligned, position.isTopHalf, adjustedRadius, sceneId);
  }
  /**
   * Determine which quadrant a point is in
   * SVG coordinate system: (0,0) is at center
   * Q1: Bottom-Right (+x, +y)
   * Q2: Bottom-Left (-x, +y)
   * Q3: Top-Left (-x, -y)
   * Q4: Top-Right (+x, -y)
   */
  getQuadrant(x, y) {
    if (x >= 0 && y >= 0) return "Q1";
    else if (x < 0 && y >= 0) return "Q2";
    else if (x < 0 && y < 0) return "Q3";
    else return "Q4";
  }
  /**
   * Get position configuration for a specific quadrant
   */
  getPositionForQuadrant(quadrant, outerRadius) {
    let result = {
      x: 0,
      y: 0,
      quadrantClass: "",
      isRightAligned: false,
      isTopHalf: false
    };
    const topHalfOffset = -550;
    const bottomHalfOffset = 120;
    switch (quadrant) {
      case "Q1":
        result.x = 0;
        result.y = bottomHalfOffset;
        result.quadrantClass = "q2";
        result.isRightAligned = false;
        result.isTopHalf = false;
        break;
      case "Q2":
        result.x = 0;
        result.y = bottomHalfOffset;
        result.quadrantClass = "q1";
        result.isRightAligned = true;
        result.isTopHalf = false;
        break;
      case "Q3":
        result.x = 0;
        result.y = topHalfOffset;
        result.quadrantClass = "q4";
        result.isRightAligned = true;
        result.isTopHalf = true;
        break;
      case "Q4":
        result.x = 0;
        result.y = topHalfOffset;
        result.quadrantClass = "q3";
        result.isRightAligned = false;
        result.isTopHalf = true;
        break;
    }
    return result;
  }
  positionTextElements(synopsis, isRightAligned, isTopHalf, radius, sceneId) {
    const textElements = Array.from(synopsis.querySelectorAll("text"));
    if (textElements.length === 0) return;
    const textAnchor = isRightAligned ? "end" : "start";
    textElements.forEach((textEl) => {
      if (textEl.getAttribute("data-metadata-block") === "true") {
        textEl.setAttribute("text-anchor", "start");
      } else {
        textEl.setAttribute("text-anchor", textAnchor);
      }
    });
    const synopsisTextGroup = synopsis.querySelector(".rt-synopsis-text");
    if (!synopsisTextGroup) {
      return;
    }
    synopsisTextGroup.removeAttribute("transform");
    const fontScale = this.getReadabilityScale();
    const titleLineHeight = 32 * fontScale;
    const synopsisLineHeight = 22 * fontScale;
    const scorePreGap = 46 * fontScale;
    const metadataSpacing = 14 * fontScale;
    const styleSource = getComputedStyle(document.documentElement);
    const pulseLineHeightRaw = parseFloat(styleSource.getPropertyValue("--rt-pulse-line-height"));
    const pulseLineHeight = pulseLineHeightRaw * fontScale;
    const synopsisTransform = synopsis.getAttribute("transform") || "";
    const translateMatch = synopsisTransform.match(/translate\(([^,]+),\s*([^)]+)\)/);
    if (!translateMatch || translateMatch.length < 3) {
      return;
    }
    const baseX = parseFloat(translateMatch[1]);
    const baseY = parseFloat(translateMatch[2]);
    const textRows = [];
    textElements.forEach((textEl) => {
      if (textEl.getAttribute("data-metadata-block") === "true" && textRows.length > 0) {
        textRows[textRows.length - 1].push(textEl);
      } else {
        textRows.push([textEl]);
      }
    });
    let yOffset = 0;
    textRows.forEach((rowElements, rowIndex) => {
      var _a;
      const primaryEl = (_a = rowElements[0]) != null ? _a : null;
      let currentRowLineHeight = rowIndex === 0 ? titleLineHeight : synopsisLineHeight;
      if (rowIndex > 0) {
        const currentEl = rowElements[0];
        const isGossamerLine = currentEl.classList.contains("rt-gossamer-score-line");
        const isBeatsText = currentEl.classList.contains("pulse-text");
        const prevEl = textRows[rowIndex - 1][0];
        const isPrevLineSynopsis = prevEl.classList.contains("rt-title-text-secondary");
        const isPrevLineBeats = prevEl.classList.contains("pulse-text");
        if (rowIndex === 1) {
          yOffset += titleLineHeight;
          currentRowLineHeight = titleLineHeight;
        } else if (isGossamerLine && isPrevLineSynopsis) {
          yOffset += scorePreGap;
          currentRowLineHeight = scorePreGap;
        } else if (isBeatsText || isPrevLineBeats) {
          yOffset += pulseLineHeight;
          currentRowLineHeight = pulseLineHeight;
        } else {
          yOffset += synopsisLineHeight;
          currentRowLineHeight = synopsisLineHeight;
        }
      }
      let anchorY = baseY + yOffset;
      if (Math.abs(anchorY) >= radius) {
        anchorY = Math.sign(anchorY) * (radius - 1);
      }
      const radiusDiff = radius * radius - anchorY * anchorY;
      if (radiusDiff < 0) {
        throw new Error(`Cannot resolve anchor for row ${rowIndex}; negative radius difference computed.`);
      }
      const circleX = Math.sqrt(radiusDiff);
      const direction = isRightAligned ? 1 : -1;
      let inset = 0;
      if (isTopHalf && primaryEl) {
        const style = window.getComputedStyle(primaryEl);
        const fontSize = parseFloat(style.fontSize) || 16;
        const ratio = rowIndex <= 1 ? 0.5 : _SynopsisManager.TEXT_HEIGHT_INSET_RATIO;
        inset = fontSize * ratio;
      }
      const anchorAbsoluteX = (circleX - inset) * direction;
      const anchorX = anchorAbsoluteX - baseX;
      const { primaryWidth, metadataWidth, gap } = this.measureRowLayout(rowElements, metadataSpacing);
      const roundedAnchorX = Math.round(anchorX);
      const rowY = rowIndex === 0 ? 0 : yOffset;
      this.positionRowColumns(
        rowElements,
        roundedAnchorX,
        rowY,
        primaryWidth,
        metadataWidth,
        gap,
        isRightAligned
      );
    });
  }
  measureRowLayout(rowElements, defaultGap) {
    if (rowElements.length === 0) {
      return { primaryWidth: 0, metadataWidth: 0, gap: defaultGap };
    }
    const primaryWidth = this.measureTextWidth(rowElements[0]);
    let metadataWidth = 0;
    let gap = defaultGap;
    if (rowElements.length > 1) {
      const metadataEl = rowElements[1];
      metadataWidth = this.measureTextWidth(metadataEl);
      const gapAttr = metadataEl.getAttribute("data-column-gap");
      if (gapAttr) {
        const parsedGap = parseFloat(gapAttr);
        if (!Number.isNaN(parsedGap)) {
          gap = parsedGap;
        }
      }
    }
    return { primaryWidth, metadataWidth, gap };
  }
  positionRowColumns(rowElements, anchorX, yPosition, primaryWidth, metadataWidth, gap, isRightAligned) {
    if (rowElements.length === 0) {
      return;
    }
    const hasMetadata = rowElements.length > 1;
    if (isRightAligned) {
      const metadataRightEdge = anchorX - SYNOPSIS_INSET;
      const metadataLeftEdge = hasMetadata ? metadataRightEdge - metadataWidth : metadataRightEdge;
      const titleRightEdge = hasMetadata ? metadataLeftEdge - gap : metadataRightEdge;
      rowElements.forEach((textEl, index) => {
        const x = index === 0 ? titleRightEdge : metadataLeftEdge;
        textEl.setAttribute("x", String(x));
        textEl.setAttribute("y", String(yPosition));
        const prev = textEl.previousElementSibling;
        if (prev && prev.tagName === "rect" && prev.classList.contains("rt-planetary-outline")) {
          let currentWidth = parseFloat(prev.getAttribute("width") || "0");
          try {
            const len = textEl.getComputedTextLength();
            if (len > 0) {
              currentWidth = len + 12;
              prev.setAttribute("width", String(currentWidth));
            }
          } catch (e) {
          }
          prev.setAttribute("x", String(x - currentWidth));
          prev.setAttribute("y", String(yPosition - 14));
          textEl.setAttribute("dx", "-6");
        }
        if (index !== 0) {
          textEl.setAttribute("text-anchor", "start");
          this.alignMetadataTspans(textEl, metadataLeftEdge);
        }
      });
    } else {
      const rowLeftEdge = anchorX + SYNOPSIS_INSET;
      const metadataLeftEdge = hasMetadata ? rowLeftEdge + primaryWidth + gap : rowLeftEdge;
      rowElements.forEach((textEl, index) => {
        const x = index === 0 ? rowLeftEdge : metadataLeftEdge;
        textEl.setAttribute("x", String(x));
        textEl.setAttribute("y", String(yPosition));
        const prev = textEl.previousElementSibling;
        if (prev && prev.tagName === "rect" && prev.classList.contains("rt-planetary-outline")) {
          try {
            const len = textEl.getComputedTextLength();
            if (len > 0) {
              prev.setAttribute("width", String(len + 12));
            }
          } catch (e) {
          }
          prev.setAttribute("x", String(x));
          prev.setAttribute("y", String(yPosition - 14));
          textEl.setAttribute("dx", "6");
        }
        if (index !== 0) {
          this.alignMetadataTspans(textEl, metadataLeftEdge);
        }
      });
    }
  }
  alignMetadataTspans(metadataText, columnX) {
    const tspans = Array.from(metadataText.querySelectorAll("tspan"));
    tspans.forEach((tspan) => {
      const role = tspan.getAttribute("data-column-role");
      if (role === "date" || role === "duration") {
        tspan.setAttribute("x", String(columnX));
      }
    });
  }
  measureTextWidth(element) {
    const box = element.getBBox();
    if (box && Number.isFinite(box.width)) {
      return Math.max(0, box.width);
    }
    const length = element.getComputedTextLength();
    if (Number.isFinite(length)) {
      return Math.max(0, length);
    }
    throw new Error("Unable to measure text width for synopsis element.");
  }
  /**
   * Process content with tspan elements and add to an SVG element
   * @param content The HTML content to process
   * @param parentElement The SVG element to append processed nodes to
   */
  processContentWithTspans(content, parentElement) {
    let processedContent = content;
    if (content.includes("&lt;tspan") && !content.includes("<tspan")) {
      processedContent = content.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&apos;/g, "'").replace(/&amp;/g, "&");
    }
    const parser = new DOMParser();
    const doc = parser.parseFromString(`<div>${processedContent}</div>`, "text/html");
    const container = doc.querySelector("div");
    if (!container) {
      throw new Error("Unable to create container for synopsis content.");
    }
    const nodes = Array.from(container.childNodes);
    if (nodes.length === 0) {
      throw new Error("Synopsis content produced no nodes to render.");
    }
    const appendTextSpan = (textValue) => {
      if (!textValue.trim()) {
        return;
      }
      const svgTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      svgTspan.textContent = textValue;
      parentElement.appendChild(svgTspan);
    };
    nodes.forEach((node) => {
      var _a, _b;
      if (node.nodeType === Node.TEXT_NODE) {
        appendTextSpan((_a = node.textContent) != null ? _a : "");
        return;
      }
      if (node.nodeType === Node.ELEMENT_NODE) {
        const element = node;
        const tag = element.tagName.toLowerCase();
        if (tag !== "tspan" && tag !== "span") {
          throw new Error(`Unsupported element <${element.tagName}> in synopsis content.`);
        }
        const svgTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        Array.from(element.attributes).forEach((attr) => {
          svgTspan.setAttribute(attr.name, attr.value);
        });
        svgTspan.textContent = (_b = element.textContent) != null ? _b : "";
        parentElement.appendChild(svgTspan);
        return;
      }
      throw new Error("Unsupported node type found in synopsis content.");
    });
    if (!parentElement.hasChildNodes()) {
      throw new Error("Synopsis conversion produced no SVG tspans.");
    }
  }
  // Add this new method for splitting text into lines
  splitTextIntoLines(text, maxWidth) {
    if (!text || typeof text !== "string") {
      return [""];
    }
    const trimmedText = text.trim();
    if (!trimmedText) {
      return [""];
    }
    const words = trimmedText.split(/\s+/);
    const lines = [];
    let currentLine = "";
    const maxCharsPerLine = 50;
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      const wordWidth = word.length;
      if (currentLine.length + wordWidth + 1 > maxCharsPerLine && currentLine !== "") {
        lines.push(currentLine.trim());
        currentLine = word;
      } else {
        currentLine += (currentLine ? " " : "") + word;
      }
    }
    if (currentLine) {
      lines.push(currentLine.trim());
    }
    if (lines.length === 0) {
      return [trimmedText];
    }
    return lines;
  }
  /**
   * Formats and adds beat text lines to an SVG group.
   * @param beatsText The multi-line string containing beats for one section.
   * @param beatKey The key identifying the section ('previousSceneAnalysis', 'currentSceneAnalysis', 'nextSceneAnalysis').
   * @param parentGroup The SVG group element to append the text elements to.
   * @param baseY The starting Y coordinate for the first line.
   * @param lineHeight The vertical distance between lines.
   * @param spacerSize Size of the spacer to add after this beats section.
   */
  formatBeatsText(beatsText, beatKey, parentGroup, baseY, lineHeight, spacerSize = 0) {
    var _a, _b;
    if (!beatsText || typeof beatsText !== "string" || beatsText === "undefined" || beatsText === "null") {
      return 0;
    }
    beatsText = beatsText.replace(/undefined|null/gi, "").trim();
    if (!beatsText) {
      return 0;
    }
    let lines = [];
    const hasNewlines = beatsText.includes("\n");
    if (hasNewlines) {
      lines = beatsText.split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
    } else {
      const trimmedText = beatsText.trim();
      if (trimmedText.startsWith("-")) {
        if (trimmedText.length > 1) {
          lines = [trimmedText];
        }
      } else {
        const beatSeparatorPattern = /,\s*(?=[^,]*[\+\-\?]\s*\/)/g;
        const parts = trimmedText.split(beatSeparatorPattern);
        if (parts.length > 1) {
          lines = parts.map((item) => `- ${item.trim()}`).filter((line) => line.length > 2);
        } else {
          lines = trimmedText.split(",").map((item) => `- ${item.trim()}`).filter((line) => line.length > 2);
        }
        if (lines.length === 0 && trimmedText.length > 0) {
          lines = [`- ${trimmedText}`];
        }
      }
    }
    if (lines.length > 0) {
      const processedLines = [];
      for (const originalLine of lines) {
        if (!originalLine || !originalLine.trim()) continue;
        const line = originalLine.trim();
        let wasSplit = false;
        let isGradeLine = false;
        const prefixMatch = line.match(/^\s*(\[[A-Z][+-]?\]\s*)/);
        const numericGradeRegex = /^\s*-?\s*(\d+(\.\d+)?\s+[ABC])/i;
        if (prefixMatch || line.match(numericGradeRegex)) {
          isGradeLine = true;
        }
        let splitChar = "";
        const hasSlashSeparator = /\s\/\s/.test(line);
        if (!hasSlashSeparator) {
          if (isGradeLine) {
            if (line.match(/\.\s/)) {
              splitChar = ".";
            } else if (line.includes(",")) {
              splitChar = ",";
            }
          } else {
            if (line.includes(",")) {
              splitChar = ",";
            }
          }
        }
        if (splitChar) {
          const parts = line.split(splitChar);
          if (parts.length > 1) {
            wasSplit = true;
            const wrapTag = isGradeLine ? "[GRADE]" : "[BODY]";
            processedLines.push(parts[0] + splitChar);
            for (let i = 1; i < parts.length; i++) {
              const part = parts[i].trim();
              if (part) {
                const text = i < parts.length - 1 ? part + splitChar : part;
                processedLines.push(`${wrapTag} ${text}`);
              }
            }
          }
        }
        if (!wasSplit) {
          processedLines.push(originalLine);
        }
      }
      lines.splice(0, lines.length, ...processedLines);
    }
    let currentY = baseY;
    let lineCount = 0;
    for (let i = 0; i < lines.length; i++) {
      let line = lines[i].trim();
      if (!line.startsWith("-")) {
        line = `- ${line}`;
      }
      let rawContent = line.substring(1).trim();
      if (!rawContent) continue;
      let titleText = rawContent;
      let commentText = "";
      let titleClass = "pulse-text-neutral";
      let commentClass = "pulse-text";
      let signDetected = null;
      let useSlashSeparator = false;
      let detectedGrade = null;
      const bodyWrapMatch = rawContent.match(/^\[BODY\]\s*(.*)$/);
      const gradeWrapMatch = rawContent.match(/^\[GRADE\]\s*(.*)$/);
      if (gradeWrapMatch) {
        titleText = gradeWrapMatch[1];
        rawContent = titleText;
        titleClass = "pulse-text-grade";
        commentClass = "pulse-text-grade";
        if (lines.length > 0) {
          const firstLineContent = lines[0].replace(/^-\s*/, "");
          const firstLineGradeMatch = firstLineContent.match(/^\s*\d+(\.\d+)?\s+([ABC])(?![A-Za-z0-9])/i);
          if (firstLineGradeMatch) {
            detectedGrade = firstLineGradeMatch[2].toUpperCase();
          }
        }
      } else if (bodyWrapMatch) {
        titleText = bodyWrapMatch[1];
        rawContent = titleText;
        titleClass = "rt-info-text rt-title-text-secondary";
        commentClass = "rt-info-text rt-title-text-secondary";
      } else {
        if (!bodyWrapMatch && !gradeWrapMatch) {
          const signSlashPattern = /^(.*?)\s*([-+?])\s*\/\s*(.*)$/;
          const match = rawContent.match(signSlashPattern);
          if (match) {
            titleText = match[1].trim();
            signDetected = match[2];
            commentText = match[3].trim();
            useSlashSeparator = true;
          } else {
            const endSignMatch = rawContent.match(/\s*([-+?])$/);
            if (endSignMatch) {
              signDetected = endSignMatch[1];
              titleText = rawContent.substring(0, endSignMatch.index).trim();
            }
          }
          if (signDetected === "+") {
            titleClass = "pulse-text-positive";
          } else if (signDetected === "-") {
            titleClass = "pulse-text-negative";
          }
        }
      }
      if (beatKey === "currentSceneAnalysis" && !bodyWrapMatch && !gradeWrapMatch) {
        const gradeMatch = titleText.match(/^\s*-?\s*(\d+(\.\d+)?\s+[ABC])/i);
        if (gradeMatch) {
          const gradeLetterMatch = titleText.match(/\s+([ABC])/i);
          if (gradeLetterMatch && gradeLetterMatch[1]) {
            detectedGrade = gradeLetterMatch[1].toUpperCase();
          }
          titleClass = "pulse-text-grade";
          commentClass = "pulse-text-grade";
        }
      }
      const brRe = /\s*\[br\]\s*/i;
      const titleSegments = (titleText || "").split(brRe);
      const commentSegments = useSlashSeparator && commentText ? (commentText || "").split(brRe) : [];
      const makeLine = (titlePart, commentPart) => {
        const lineText = document.createElementNS("http://www.w3.org/2000/svg", "text");
        lineText.setAttribute("class", "pulse-text");
        lineText.setAttribute("x", "0");
        lineText.setAttribute("y", String(currentY));
        lineText.setAttribute("text-anchor", "start");
        if (titlePart !== null) {
          const tt = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
          tt.setAttribute("class", titleClass);
          tt.textContent = titlePart;
          lineText.appendChild(tt);
        }
        if (commentPart !== null) {
          const ct = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
          ct.setAttribute("class", commentClass);
          ct.textContent = (titlePart ? " / " : "") + commentPart;
          lineText.appendChild(ct);
        }
        parentGroup.appendChild(lineText);
        currentY += lineHeight;
        lineCount += 1;
      };
      makeLine((_a = titleSegments[0]) != null ? _a : "", commentSegments.length > 0 ? (_b = commentSegments[0]) != null ? _b : "" : null);
      for (let i2 = 1; i2 < titleSegments.length; i2++) {
        makeLine(titleSegments[i2], null);
      }
      for (let i2 = 1; i2 < commentSegments.length; i2++) {
        makeLine(commentSegments[i2], null);
      }
    }
    if (spacerSize > 0) {
      const addSpacer = (yPosition, height) => {
        const spacer = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        spacer.setAttribute("class", "synopsis-spacer");
        spacer.setAttribute("x", "0");
        spacer.setAttribute("y", String(yPosition));
        spacer.setAttribute("width", "20");
        spacer.setAttribute("height", String(height));
        parentGroup.appendChild(spacer);
      };
      addSpacer(currentY, spacerSize);
      currentY += spacerSize;
    }
    return lineCount;
  }
  buildMissingWhenMessage(scene) {
    if (!shouldDisplayMissingWhenWarning(scene)) return null;
    const neighbors = this.getNarrativeNeighbors(scene);
    const previousDate = this.getValidWhen(neighbors == null ? void 0 : neighbors.previous);
    const nextDate = this.getValidWhen(neighbors == null ? void 0 : neighbors.next);
    const suggestions = [];
    if (previousDate) {
      suggestions.push(`Prev ${this.formatDateForDisplay(previousDate)}`);
    }
    if (nextDate) {
      suggestions.push(`Next ${this.formatDateForDisplay(nextDate)}`);
    }
    if (suggestions.length === 0) {
      return "Missing When date";
    }
    const suggestionText = suggestions.length === 1 ? suggestions[0] : `${suggestions[0]} or ${suggestions[1]}`;
    return `Missing When date \u2014 Try ${suggestionText}`;
  }
  getNarrativeNeighbors(scene) {
    const dataset = this.plugin.lastSceneData;
    if (!Array.isArray(dataset) || dataset.length === 0) return null;
    const sceneEntries = dataset.filter((item) => !isBeatNote(item));
    if (sceneEntries.length === 0) return null;
    const seenKeys = /* @__PURE__ */ new Set();
    const deduped = [];
    sceneEntries.forEach((item) => {
      const key = this.getSceneKey(item);
      if (!seenKeys.has(key)) {
        seenKeys.add(key);
        deduped.push(item);
      }
    });
    const ordered = sortScenes(deduped, false);
    const targetKey = this.getSceneKey(scene);
    const index = ordered.findIndex((item) => this.getSceneKey(item) === targetKey);
    if (index === -1) return null;
    return {
      previous: index > 0 ? ordered[index - 1] : void 0,
      next: index < ordered.length - 1 ? ordered[index + 1] : void 0
    };
  }
  getSceneKey(item) {
    var _a;
    return item.path || `${item.title || ""}::${String((_a = item.when) != null ? _a : "")}`;
  }
  getValidWhen(item) {
    if (!item) return null;
    if (!(item.when instanceof Date)) return null;
    return Number.isNaN(item.when.getTime()) ? null : item.when;
  }
};
/**
 * Position text elements along an arc
 * 
 * TEXT POSITIONING ON THE RADIAL ARC:
 * Each row's X position is calculated using Pythagorean theorem to place it
 * exactly on the circle at that Y coordinate: circleX = sqrt(r - y)
 * 
 * This works identically for both top and bottom halves of the timeline.
 * The text-anchor property (start/end) determines which edge of the text
 * aligns with the calculated arc position.
 * 
 * MINIMAL INSET FOR TEXT OVERHANG:
 * SVG text extends above its baseline (ascenders, cap height). We measure
 * the actual rendered text height via getBBox() and use a fraction of it
 * as the inset. This automatically scales with:
 * - Font size (title vs body vs beats)
 * - Readability scale (normal vs large)
 * - Font metrics (different fonts/localizations)
 */
_SynopsisManager.TEXT_HEIGHT_INSET_RATIO = 0.35;
var SynopsisManager = _SynopsisManager;

// src/renderer/gossamerLayer.ts
init_gossamer();
function getCSSVar(varName, fallback) {
  return getComputedStyle(document.documentElement).getPropertyValue(varName).trim() || fallback;
}
function mapScoreToRadius(score, inner, outer) {
  const clamped = Math.max(0, Math.min(100, score));
  return inner + clamped / 100 * (outer - inner);
}
function renderGossamerLayer(scenes, run, polar, anglesByBeat, beatPathByName, overlayRuns, minBand, spokeEndRadius, publishStageColorByBeat, beatSlicesByName, publishStageColors, hasAnyScores = false) {
  var _a;
  if (!run) return "";
  const beatStatusMap = new Map(run.beats.map((b) => [b.beat, b.status]));
  const outOfRangeBeats = new Set(run.beats.filter((b) => b.isOutOfRange).map((b) => b.beat));
  const defaultColor = getCSSVar("--rt-gossamer-default-color", "#7a7a7a");
  const mostAdvancedColor = publishStageColors ? getMostAdvancedStageColor(scenes, publishStageColors) : Array.from((publishStageColorByBeat == null ? void 0 : publishStageColorByBeat.values()) || [])[0] || defaultColor;
  const selectedBeatModel = (_a = run == null ? void 0 : run.meta) == null ? void 0 : _a.model;
  const beatOrder = extractBeatOrder(scenes, selectedBeatModel);
  if (!beatOrder.length) {
    return "";
  }
  const localAngles = (() => {
    const m = /* @__PURE__ */ new Map();
    const fallbackAngles = beatOrder.map((_, i) => -Math.PI / 2 + i / beatOrder.length * 2 * Math.PI);
    beatOrder.forEach((name, idx) => m.set(name, fallbackAngles[idx]));
    if (anglesByBeat) {
      anglesByBeat.forEach((val, key) => {
        m.set(key, val);
      });
    }
    return m;
  })();
  const present = extractPresentBeatScores(run);
  const { innerRadius, outerRadius } = polar;
  const nameToScore = new Map(present.map((p) => [p.beat, p.score]));
  const segments = [];
  let current = [];
  const scoreTexts = [];
  const spokes = [];
  const beatOutlines = [];
  const rangeSquares = [];
  beatOrder.forEach((name) => {
    var _a2;
    const angle = localAngles.get(name);
    if (typeof angle !== "number") return;
    const beatColor = (publishStageColorByBeat == null ? void 0 : publishStageColorByBeat.get(name)) || mostAdvancedColor;
    const score = nameToScore.get(name);
    const beatData = run.beats.find((b) => b.beat === name);
    const beatStatus = beatStatusMap.get(name);
    const spokeEnd = spokeEndRadius != null ? spokeEndRadius : outerRadius;
    const sx1 = innerRadius * Math.cos(angle);
    const sy1 = innerRadius * Math.sin(angle);
    const sx2 = spokeEnd * Math.cos(angle);
    const sy2 = spokeEnd * Math.sin(angle);
    spokes.push(`<line class="rt-gossamer-spoke" data-beat="${escapeAttr(name)}" x1="${fmt(sx1)}" y1="${fmt(sy1)}" x2="${fmt(sx2)}" y2="${fmt(sy2)}" stroke="${beatColor}"/>`);
    if (beatSlicesByName) {
      const sliceInfo = beatSlicesByName.get(name);
      if (sliceInfo) {
        const arcPath2 = buildCellArcPath(sliceInfo.innerR, sliceInfo.outerR, sliceInfo.startAngle, sliceInfo.endAngle);
        beatOutlines.push(`<path class="rt-gossamer-beat-outline" d="${arcPath2}" stroke="${beatColor}" data-beat="${escapeAttr(name)}"/>`);
      }
    }
    if (beatData == null ? void 0 : beatData.range) {
      const range = beatData.range;
      const minRadius = mapScoreToRadius(range.min, innerRadius, outerRadius);
      const maxRadius = mapScoreToRadius(range.max, innerRadius, outerRadius);
      const rangeMinX = minRadius * Math.cos(angle);
      const rangeMinY = minRadius * Math.sin(angle);
      const rangeMaxX = maxRadius * Math.cos(angle);
      const rangeMaxY = maxRadius * Math.sin(angle);
      const idealRangeWidth = getCSSVar("--rt-gossamer-ideal-range-width", "6px");
      spokes.push(`<line class="rt-gossamer-ideal-range" data-beat="${escapeAttr(name)}" x1="${fmt(rangeMinX)}" y1="${fmt(rangeMinY)}" x2="${fmt(rangeMaxX)}" y2="${fmt(rangeMaxY)}" stroke="${beatColor}" stroke-width="${idealRangeWidth}"/>`);
      rangeSquares.push(`<text class="rt-gossamer-range-value" data-beat="${escapeAttr(name)}" x="${fmt(rangeMinX)}" y="${fmt(rangeMinY + 1)}">${range.min}</text>`);
      rangeSquares.push(`<text class="rt-gossamer-range-value" data-beat="${escapeAttr(name)}" x="${fmt(rangeMaxX)}" y="${fmt(rangeMaxY + 1)}">${range.max}</text>`);
    }
    const isMissingInSequence = beatStatus === "outlineOnly";
    const displayScore = typeof score === "number" ? score : isMissingInSequence && hasAnyScores ? 0 : null;
    if (displayScore !== null) {
      const r = mapScoreToRadius(displayScore, innerRadius, outerRadius);
      const x = r * Math.cos(angle);
      const y = r * Math.sin(angle);
      current.push({ x, y });
      const path = (beatPathByName == null ? void 0 : beatPathByName.get(name)) || "";
      const encodedPath = path ? encodeURIComponent(path) : "";
      const data = `data-beat="${escapeAttr(name)}" data-score="${String(displayScore)}"${encodedPath ? ` data-path="${escapeAttr(encodedPath)}"` : ""}${((_a2 = run == null ? void 0 : run.meta) == null ? void 0 : _a2.label) ? ` data-label="${escapeAttr(run.meta.label)}"` : ""}`;
      scoreTexts.push(`<text class="rt-gossamer-score-text${isMissingInSequence ? " rt-gossamer-missing-data" : ""}" x="${fmt(x)}" y="${fmt(y + 1)}" ${data}>${displayScore}</text>`);
      if ((beatData == null ? void 0 : beatData.range) && typeof score === "number") {
        const range = beatData.range;
        const scoreRadius = mapScoreToRadius(score, innerRadius, outerRadius);
        const isInRange = score >= range.min && score <= range.max;
        const isBelowRange = score < range.min;
        const isAboveRange = score > range.max;
        let segmentStart;
        let segmentEnd;
        if (isInRange) {
          const distToMin = Math.abs(score - range.min);
          const distToMax = Math.abs(score - range.max);
          const targetBoundary = distToMin < distToMax ? range.min : range.max;
          segmentStart = scoreRadius;
          segmentEnd = mapScoreToRadius(targetBoundary, innerRadius, outerRadius);
        } else {
          if (isBelowRange) {
            segmentStart = scoreRadius;
            segmentEnd = mapScoreToRadius(range.min, innerRadius, outerRadius);
          } else {
            segmentStart = scoreRadius;
            segmentEnd = mapScoreToRadius(range.max, innerRadius, outerRadius);
          }
        }
        const segX1 = segmentStart * Math.cos(angle);
        const segY1 = segmentStart * Math.sin(angle);
        const segX2 = segmentEnd * Math.cos(angle);
        const segY2 = segmentEnd * Math.sin(angle);
        let segmentClass;
        if (isInRange) {
          segmentClass = "rt-gossamer-range-segment rt-in-range";
        } else if (isAboveRange) {
          segmentClass = "rt-gossamer-range-segment rt-above-range";
        } else {
          segmentClass = "rt-gossamer-range-segment rt-below-range";
        }
        spokes.push(`<line class="${segmentClass}" data-beat="${escapeAttr(name)}" x1="${fmt(segX1)}" y1="${fmt(segY1)}" x2="${fmt(segX2)}" y2="${fmt(segY2)}"/>`);
      }
    }
  });
  if (current.length > 1) segments.push(buildPath(current));
  if (segments.length === 0 && scoreTexts.length === 0 && spokes.length === 0 && beatOutlines.length === 0) return "";
  let bandSvg = "";
  if (minBand && minBand.min && minBand.max) {
    const minPts = toPoints(minBand.min, localAngles, innerRadius, outerRadius);
    const maxPts = toPoints(minBand.max, localAngles, innerRadius, outerRadius);
    if (minPts.length >= 2 && maxPts.length >= 2) {
      const maxPath = buildBezierPath(maxPts, true);
      const minPathForward = buildBezierPath(minPts, true);
      const minPathReversed = reverseSvgPath(minPathForward);
      const bandPath = `${maxPath} ${minPathReversed} Z`;
      const bandOpacity = getCSSVar("--rt-gossamer-band-opacity", "0.5");
      const lightColor = lightenColor(mostAdvancedColor, 70);
      bandSvg = `<path class="rt-gossamer-band" d="${bandPath}" fill="${lightColor}" fill-opacity="${bandOpacity}"/>`;
    }
  }
  const overlayPathsWithColors = [];
  const overlayDots = [];
  if (overlayRuns && overlayRuns.length > 0) {
    [...overlayRuns].reverse().forEach((ov) => {
      const path = buildOverlayPath(ov.points, localAngles, innerRadius, outerRadius);
      if (path) {
        const historicalColor = getCSSVar("--rt-gossamer-historical-color", "#c0c0c0");
        overlayPathsWithColors.push({
          path,
          color: ov.color || historicalColor
        });
      }
      const historicalDotRadius = getCSSVar("--rt-gossamer-dot-historical", "5");
      ov.points.forEach((point) => {
        const angle = localAngles.get(point.beat);
        if (typeof angle === "number") {
          const r = mapScoreToRadius(point.score, innerRadius, outerRadius);
          const x = r * Math.cos(angle);
          const y = r * Math.sin(angle);
          const errorColor = getCSSVar("--rt-gossamer-error-color", "#ff4444");
          const historicalColor = getCSSVar("--rt-gossamer-historical-color", "#c0c0c0");
          const dotColor = point.score === 0 ? errorColor : ov.color || historicalColor;
          overlayDots.push(`<circle class="rt-gossamer-dot-historical" cx="${fmt(x)}" cy="${fmt(y)}" r="${historicalDotRadius}" fill="${dotColor}" data-beat="${escapeAttr(point.beat)}" pointer-events="none"/>`);
        }
      });
    });
  }
  const overlaySvg = overlayPathsWithColors.map(({ path, color }) => `<path class="rt-gossamer-line rt-gossamer-overlay" d="${path}" stroke="${color}"/>`).join("");
  const overlayDotsSvg = overlayDots.join("");
  const mainPaths = segments.map((d) => `<path class="rt-gossamer-line" d="${d}"/>`).join("");
  const scoreTextsSvg = scoreTexts.join("");
  const spokesSvg = spokes.join("");
  const beatOutlinesSvg = beatOutlines.join("");
  const rangeMarkersSvg = rangeSquares.join("");
  return `<g class="rt-gossamer-layer">${bandSvg}${overlaySvg}${mainPaths}${spokesSvg}${beatOutlinesSvg}${overlayDotsSvg}${rangeMarkersSvg}${scoreTextsSvg}</g>`;
}
function buildBezierPath(points, startWithMove = true) {
  if (!points.length) return "";
  if (points.length === 1) {
    return startWithMove ? `M ${fmt(points[0].x)} ${fmt(points[0].y)}` : `L ${fmt(points[0].x)} ${fmt(points[0].y)}`;
  }
  if (points.length === 2) {
    const start = startWithMove ? `M ${fmt(points[0].x)} ${fmt(points[0].y)}` : `L ${fmt(points[0].x)} ${fmt(points[0].y)}`;
    return `${start} L ${fmt(points[1].x)} ${fmt(points[1].y)}`;
  }
  let path = startWithMove ? `M ${fmt(points[0].x)} ${fmt(points[0].y)}` : `L ${fmt(points[0].x)} ${fmt(points[0].y)}`;
  for (let i = 0; i < points.length - 1; i++) {
    const current = points[i];
    const next = points[i + 1];
    const prev = i > 0 ? points[i - 1] : current;
    const afterNext = i < points.length - 2 ? points[i + 2] : next;
    const distCurrNext = Math.sqrt((next.x - current.x) ** 2 + (next.y - current.y) ** 2);
    const distPrevCurr = Math.sqrt((current.x - prev.x) ** 2 + (current.y - prev.y) ** 2);
    const distNextAfter = Math.sqrt((afterNext.x - next.x) ** 2 + (afterNext.y - next.y) ** 2);
    let tension = 0.25;
    const avgDist = (distPrevCurr + distCurrNext + distNextAfter) / 3;
    if (avgDist < 50) {
      tension = 0.1;
    } else if (avgDist < 100) {
      tension = 0.15;
    }
    if (i > 0 && i < points.length - 1) {
      const v1x = current.x - prev.x;
      const v1y = current.y - prev.y;
      const v2x = next.x - current.x;
      const v2y = next.y - current.y;
      const dot = v1x * v2x + v1y * v2y;
      const mag1 = Math.sqrt(v1x * v1x + v1y * v1y);
      const mag2 = Math.sqrt(v2x * v2x + v2y * v2y);
      if (mag1 > 0 && mag2 > 0) {
        const cosAngle = dot / (mag1 * mag2);
        if (cosAngle < 0.5) {
          tension *= 0.5;
        }
      }
    }
    const maxControlDist = distCurrNext * 0.4;
    let cp1x = current.x + (next.x - prev.x) * tension;
    let cp1y = current.y + (next.y - prev.y) * tension;
    const cp1dist = Math.sqrt((cp1x - current.x) ** 2 + (cp1y - current.y) ** 2);
    if (cp1dist > maxControlDist && cp1dist > 0) {
      const scale = maxControlDist / cp1dist;
      cp1x = current.x + (cp1x - current.x) * scale;
      cp1y = current.y + (cp1y - current.y) * scale;
    }
    let cp2x = next.x - (afterNext.x - current.x) * tension;
    let cp2y = next.y - (afterNext.y - current.y) * tension;
    const cp2dist = Math.sqrt((cp2x - next.x) ** 2 + (cp2y - next.y) ** 2);
    if (cp2dist > maxControlDist && cp2dist > 0) {
      const scale = maxControlDist / cp2dist;
      cp2x = next.x + (cp2x - next.x) * scale;
      cp2y = next.y + (cp2y - next.y) * scale;
    }
    path += ` C ${fmt(cp1x)} ${fmt(cp1y)}, ${fmt(cp2x)} ${fmt(cp2y)}, ${fmt(next.x)} ${fmt(next.y)}`;
  }
  return path;
}
function buildPath(points) {
  return buildBezierPath(points, true);
}
function reverseSvgPath(path) {
  const segments = [];
  const regex = /([MLC])\s*([\d.\s,-]+)/g;
  let match;
  while ((match = regex.exec(path)) !== null) {
    const cmd = match[1];
    const coords = match[2].trim().split(/[\s,]+/).map(parseFloat);
    segments.push({ cmd, coords });
  }
  if (segments.length === 0) return "";
  const points = [];
  segments.forEach((seg, idx) => {
    if (seg.cmd === "M" || seg.cmd === "L") {
      points.push({ x: seg.coords[0], y: seg.coords[1] });
    } else if (seg.cmd === "C") {
      const prevPoint = points[points.length - 1];
      if (prevPoint) {
        prevPoint.cp2 = { x: seg.coords[0], y: seg.coords[1] };
      }
      points.push({
        x: seg.coords[4],
        y: seg.coords[5],
        cp1: { x: seg.coords[2], y: seg.coords[3] }
        // Control point entering this point
      });
    }
  });
  if (points.length < 2) return `L ${fmt(points[0].x)} ${fmt(points[0].y)}`;
  let reversedPath = `L ${fmt(points[points.length - 1].x)} ${fmt(points[points.length - 1].y)}`;
  for (let i = points.length - 1; i > 0; i--) {
    const current = points[i];
    const prev = points[i - 1];
    if (current.cp1 && prev.cp2) {
      reversedPath += ` C ${fmt(current.cp1.x)} ${fmt(current.cp1.y)}, ${fmt(prev.cp2.x)} ${fmt(prev.cp2.y)}, ${fmt(prev.x)} ${fmt(prev.y)}`;
    } else {
      reversedPath += ` L ${fmt(prev.x)} ${fmt(prev.y)}`;
    }
  }
  return reversedPath;
}
function fmt(n) {
  return n.toFixed(6).replace(/\.0+$/, "");
}
function toPoints(series, angles, inner, outer) {
  const pts = [];
  series.forEach((p) => {
    const a = angles.get(p.beat);
    if (typeof a !== "number") return;
    const r = mapScoreToRadius(p.score, inner, outer);
    pts.push({ x: r * Math.cos(a), y: r * Math.sin(a) });
  });
  return pts;
}
function buildOverlayPath(points, angles, inner, outer) {
  const pts = toPoints(points, angles, inner, outer);
  if (pts.length < 2) return null;
  return buildBezierPath(pts, true);
}
function escapeAttr(s) {
  return (s || "").replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function buildCellArcPath(innerR, outerR, startAngle, endAngle) {
  const x1 = innerR * Math.cos(startAngle);
  const y1 = innerR * Math.sin(startAngle);
  const x2 = outerR * Math.cos(startAngle);
  const y2 = outerR * Math.sin(startAngle);
  const x3 = outerR * Math.cos(endAngle);
  const y3 = outerR * Math.sin(endAngle);
  const x4 = innerR * Math.cos(endAngle);
  const y4 = innerR * Math.sin(endAngle);
  const largeArc = endAngle - startAngle > Math.PI ? 1 : 0;
  return `M ${fmt(x1)} ${fmt(y1)} L ${fmt(x2)} ${fmt(y2)} A ${fmt(outerR)} ${fmt(outerR)} 0 ${largeArc} 1 ${fmt(x3)} ${fmt(y3)} L ${fmt(x4)} ${fmt(y4)} A ${fmt(innerR)} ${fmt(innerR)} 0 ${largeArc} 0 ${fmt(x1)} ${fmt(y1)} Z`;
}

// src/renderer/components/MonthSpokes.ts
init_svg();
var normalizeAngle2 = (angle) => {
  const twoPi = Math.PI * 2;
  let normalized = angle % twoPi;
  if (normalized > Math.PI) {
    normalized -= twoPi;
  } else if (normalized <= -Math.PI) {
    normalized += twoPi;
  }
  return normalized;
};
function renderMonthSpokesAndInnerLabels(params) {
  const { months, lineInnerRadius, lineOuterRadius, currentMonthIndex, includeIntermediateSpokes = false, outerSpokeInnerRadius, numActs = 3 } = params;
  const totalActs = Math.max(3, Math.floor(numActs));
  const actBoundaryAngles = Array.from({ length: totalActs }, (_, i) => -Math.PI / 2 + i * 2 * Math.PI / totalActs);
  const isActBoundaryAngle = (angle) => {
    const tolerance = 2 * Math.PI / totalActs / 12;
    return actBoundaryAngles.some((b) => Math.abs(normalizeAngle2(angle - b)) <= tolerance);
  };
  const innerSpokeStart = lineInnerRadius - 5;
  const innerSpokeEnd = lineInnerRadius + 30;
  let svg = '<g class="month-spokes">';
  months.forEach(({ name, angle }, monthIndex) => {
    const isActBoundary = isActBoundaryAngle(angle);
    const isPastMonth = monthIndex < currentMonthIndex;
    const innerX1 = formatNumber(innerSpokeStart * Math.cos(angle));
    const innerY1 = formatNumber(innerSpokeStart * Math.sin(angle));
    const innerX2 = formatNumber(innerSpokeEnd * Math.cos(angle));
    const innerY2 = formatNumber(innerSpokeEnd * Math.sin(angle));
    svg += `
      <line  
        x1="${innerX1}"
        y1="${innerY1}"
        x2="${innerX2}"
        y2="${innerY2}"
        class="rt-month-spoke-line rt-inner-calendar-spoke${isActBoundary ? " rt-act-boundary" : ""}${isPastMonth ? " rt-past-month" : ""}"
      />`;
    if (outerSpokeInnerRadius !== void 0) {
      const outerX1 = formatNumber(outerSpokeInnerRadius * Math.cos(angle));
      const outerY1 = formatNumber(outerSpokeInnerRadius * Math.sin(angle));
      const outerX2 = formatNumber(lineOuterRadius * Math.cos(angle));
      const outerY2 = formatNumber(lineOuterRadius * Math.sin(angle));
      const dashOffset = isActBoundary ? "" : ' stroke-dashoffset="2"';
      svg += `
      <line  
        x1="${outerX1}"
        y1="${outerY1}"
        x2="${outerX2}"
        y2="${outerY2}"
        class="rt-month-spoke-line${isActBoundary ? " rt-act-boundary" : ""}${isPastMonth ? " rt-past-month" : ""}"${dashOffset}
      />`;
    }
    const innerLabelRadius = lineInnerRadius;
    const pixelToRadian = 5 * 2 * Math.PI / (2 * Math.PI * innerLabelRadius);
    const startAngle = angle + pixelToRadian;
    const endAngle = angle + Math.PI / 6;
    const innerPathId = `innerMonthPath-${name}`;
    svg += `
      <path id="${innerPathId}"
        d="
          M ${formatNumber(innerLabelRadius * Math.cos(startAngle))} ${formatNumber(innerLabelRadius * Math.sin(startAngle))}
          A ${formatNumber(innerLabelRadius)} ${formatNumber(innerLabelRadius)} 0 0 1 ${formatNumber(innerLabelRadius * Math.cos(endAngle))} ${formatNumber(innerLabelRadius * Math.sin(endAngle))}
        "
        fill="none"
      />
      <text class="rt-month-label" ${isPastMonth ? 'opacity="0.5"' : ""}>
        <textPath href="#${innerPathId}" startOffset="0" text-anchor="start">
          ${months[monthIndex].shortName}
        </textPath>
      </text>
    `;
  });
  if (includeIntermediateSpokes && months.length > 0 && outerSpokeInnerRadius !== void 0) {
    const multiplier = 3;
    const majorStep = 2 * Math.PI / months.length;
    for (let monthIndex = 0; monthIndex < months.length; monthIndex++) {
      for (let step = 1; step < multiplier; step++) {
        const rawAngle = months[monthIndex].angle + majorStep * step / multiplier;
        const angle = normalizeAngle2(rawAngle);
        const x1 = formatNumber(outerSpokeInnerRadius * Math.cos(angle));
        const y1 = formatNumber(outerSpokeInnerRadius * Math.sin(angle));
        const x2 = formatNumber(lineOuterRadius * Math.cos(angle));
        const y2 = formatNumber(lineOuterRadius * Math.sin(angle));
        svg += `
      <line
        x1="${x1}"
        y1="${y1}"
        x2="${x2}"
        y2="${y2}"
        class="rt-month-spoke-line rt-month-spoke-intermediate"
        stroke-dashoffset="2"
      />`;
      }
    }
  }
  if (outerSpokeInnerRadius !== void 0) {
    actBoundaryAngles.forEach((angle) => {
      const x1 = formatNumber(outerSpokeInnerRadius * Math.cos(angle));
      const y1 = formatNumber(outerSpokeInnerRadius * Math.sin(angle));
      const x2 = formatNumber(lineOuterRadius * Math.cos(angle));
      const y2 = formatNumber(lineOuterRadius * Math.sin(angle));
      svg += `
        <line
          x1="${x1}"
          y1="${y1}"
          x2="${x2}"
          y2="${y2}"
          class="rt-month-spoke-line rt-act-boundary"
        />`;
    });
  }
  svg += "</g>";
  return svg;
}
function renderGossamerMonthSpokes(params) {
  const { innerRadius, outerRadius, numActs = 3 } = params;
  const totalActs = Math.max(3, Math.floor(numActs));
  const actBoundaryAngles = Array.from({ length: totalActs }, (_, i) => -Math.PI / 2 + i * 2 * Math.PI / totalActs);
  let spokesHtml = "";
  const monthAngles = Array.from({ length: 12 }, (_, i) => i / 12 * 2 * Math.PI - Math.PI / 2);
  monthAngles.forEach((angle) => {
    const x1 = formatNumber(innerRadius * Math.cos(angle));
    const y1 = formatNumber(innerRadius * Math.sin(angle));
    const x2 = formatNumber(outerRadius * Math.cos(angle));
    const y2 = formatNumber(outerRadius * Math.sin(angle));
    const isActBoundary = actBoundaryAngles.some((b) => Math.abs(normalizeAngle2(angle - b)) < 1e-6);
    spokesHtml += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" class="rt-month-spoke-line rt-gossamer-grid-spoke${isActBoundary ? " rt-act-boundary" : ""}"/>`;
  });
  actBoundaryAngles.forEach((angle) => {
    const x1 = formatNumber(innerRadius * Math.cos(angle));
    const y1 = formatNumber(innerRadius * Math.sin(angle));
    const x2 = formatNumber(outerRadius * Math.cos(angle));
    const y2 = formatNumber(outerRadius * Math.sin(angle));
    spokesHtml += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" class="rt-month-spoke-line rt-gossamer-grid-spoke rt-act-boundary"/>`;
  });
  return `<g class="rt-gossamer-spokes">${spokesHtml}</g>`;
}

// src/renderer/components/ProgressRing.ts
function renderProgressRing(params) {
  const { progressRadius, yearProgress, currentYearStartAngle, segmentCount = 6 } = params;
  const fullCircleAngle = 2 * Math.PI;
  const segmentAngle = fullCircleAngle / segmentCount;
  const completeSegments = Math.floor(yearProgress * segmentCount);
  const partialSegmentAngle = (yearProgress * segmentCount - completeSegments) * segmentAngle;
  let svg = "";
  for (let i = 0; i < segmentCount; i++) {
    const segStart = currentYearStartAngle + i * segmentAngle;
    let segEnd = segStart + segmentAngle;
    if (i > completeSegments) continue;
    if (i === completeSegments && partialSegmentAngle > 0) {
      segEnd = segStart + partialSegmentAngle;
    }
    svg += `
            <path
                d="
                    M ${progressRadius * Math.cos(segStart)} ${progressRadius * Math.sin(segStart)}
                    A ${progressRadius} ${progressRadius} 0 ${segEnd - segStart > Math.PI ? 1 : 0} 1 
                    ${progressRadius * Math.cos(segEnd)} ${progressRadius * Math.sin(segEnd)}
                "
                class="progress-ring-fill"
                stroke="url(#linearColors${i + 1})"
            />
        `;
  }
  return svg;
}

// src/renderer/components/ProgressTicks.ts
init_svg();
function renderTargetDateTick(params) {
  const { plugin, progressRadius, dateToAngle: dateToAngle2 } = params;
  let targetDateAngle = -Math.PI / 2;
  if (plugin.settings.targetCompletionDate) {
    try {
      const targetDate = /* @__PURE__ */ new Date(plugin.settings.targetCompletionDate + "T00:00:00");
      const today = /* @__PURE__ */ new Date();
      today.setHours(0, 0, 0, 0);
      if (!isNaN(targetDate.getTime()) && targetDate > today) {
        targetDateAngle = dateToAngle2(targetDate);
      }
    } catch (e) {
    }
  }
  const targetTickOuterRadius = progressRadius + 5;
  const targetTickInnerRadius = progressRadius - 35;
  const targetMarkerSize = 8;
  const line = `
        <line
            x1="${formatNumber(targetTickOuterRadius * Math.cos(targetDateAngle))}"
            y1="${formatNumber(targetTickOuterRadius * Math.sin(targetDateAngle))}"
            x2="${formatNumber((targetTickInnerRadius + 3) * Math.cos(targetDateAngle))}"
            y2="${formatNumber((targetTickInnerRadius + 3) * Math.sin(targetDateAngle))}"
            class="target-date-tick"
        />`;
  const markerX = formatNumber(targetTickInnerRadius * Math.cos(targetDateAngle) - targetMarkerSize / 2);
  const markerY = formatNumber(targetTickInnerRadius * Math.sin(targetDateAngle) - targetMarkerSize / 2);
  const marker = `
        <rect x="${markerX}" y="${markerY}" width="${targetMarkerSize}" height="${targetMarkerSize}" class="target-date-marker" />`;
  return `${line}
${marker}`;
}

// src/renderer/components/Progress.ts
init_svg();
init_date();
function renderEstimatedDateElements(params) {
  const { estimateDate, progressRadius } = params;
  let absoluteDatePos;
  if (estimateDate === null) {
    absoluteDatePos = -Math.PI / 2;
  } else {
    absoluteDatePos = dateToAngle(estimateDate);
  }
  const tickOuterRadius = progressRadius + 5;
  const tickInnerRadius = progressRadius - 35;
  const tickOuterX = tickOuterRadius * Math.cos(absoluteDatePos);
  const tickOuterY = tickOuterRadius * Math.sin(absoluteDatePos);
  const tickInnerX = tickInnerRadius * Math.cos(absoluteDatePos);
  const tickInnerY = tickInnerRadius * Math.sin(absoluteDatePos);
  let svg = "";
  if ([tickOuterX, tickOuterY, tickInnerX, tickInnerY].every((v) => Number.isFinite(v))) {
    svg += `
      <line x1="${formatNumber(tickOuterX)}" y1="${formatNumber(tickOuterY)}" x2="${formatNumber(tickInnerX)}" y2="${formatNumber(tickInnerY)}" class="estimated-date-tick" />
      <circle cx="${formatNumber(tickInnerX)}" cy="${formatNumber(tickInnerY)}" r="4" class="estimated-date-dot" />
    `;
  }
  const displayDate = estimateDate === null ? new Date((/* @__PURE__ */ new Date()).getFullYear(), 0, 1) : estimateDate;
  const dateFormatter = new Intl.DateTimeFormat("en-US", { month: "short", day: "numeric" });
  const dateDisplay = dateFormatter.format(displayDate);
  const labelRadius = progressRadius - 45;
  const maxOffset = -18;
  const offsetX = maxOffset * Math.cos(absoluteDatePos);
  const maxYOffset = 5;
  const offsetY = -maxYOffset * Math.sin(absoluteDatePos);
  const labelXNum = labelRadius * Math.cos(absoluteDatePos) + offsetX;
  const labelYNum = labelRadius * Math.sin(absoluteDatePos) + offsetY;
  if (Number.isFinite(labelXNum) && Number.isFinite(labelYNum)) {
    const labelX = formatNumber(labelXNum);
    const labelY = formatNumber(labelYNum);
    svg += `
      <text x="${labelX}" y="${labelY}" text-anchor="middle" dominant-baseline="middle" class="estimation-date-label">${dateDisplay}</text>
    `;
  }
  return svg;
}
function renderEstimationArc(params) {
  const { estimateDate, progressRadius } = params;
  if (estimateDate === null) {
    return "";
  }
  const startAngle = -Math.PI / 2;
  const estimatedDateAngle = dateToAngle(estimateDate);
  let arcAngleSpan = estimatedDateAngle - startAngle;
  if (arcAngleSpan < 0) arcAngleSpan += 2 * Math.PI;
  const x0 = progressRadius * Math.cos(startAngle);
  const y0 = progressRadius * Math.sin(startAngle);
  const x1 = progressRadius * Math.cos(estimatedDateAngle);
  const y1 = progressRadius * Math.sin(estimatedDateAngle);
  if (![x0, y0, x1, y1].every(Number.isFinite)) return "";
  return `
    <path d="M ${x0} ${y0} A ${progressRadius} ${progressRadius} 0 ${arcAngleSpan > Math.PI ? 1 : 0} 1 ${x1} ${y1}" class="progress-ring-base" />
  `;
}

// src/services/RendererService.ts
init_date();

// src/renderer/dom/SceneDOMUpdater.ts
function updateSceneColors(svg, plugin, changedScenes) {
  try {
    const subplotColors = plugin.settings.subplotColors || [];
    const masterSubplotOrder = getMasterSubplotOrder(svg);
    let updated = false;
    changedScenes.forEach((scene) => {
      if (!scene.path) return;
      const encodedPath = encodeURIComponent(scene.path);
      const sceneGroups = svg.querySelectorAll(`[data-path="${encodedPath}"]`);
      sceneGroups.forEach((group) => {
        const subplot = scene.subplot || "Main Plot";
        const subplotIndex = masterSubplotOrder.indexOf(subplot);
        if (subplotIndex === -1) return;
        const arc = group.querySelector(".rt-scene-arc");
        if (arc) {
          const color = subplotColors[subplotIndex % subplotColors.length] || "#cccccc";
          arc.setAttribute("fill", color);
          updated = true;
        }
      });
    });
    return updated;
  } catch (error) {
    console.error("[SceneDOMUpdater] Failed to update scene colors:", error);
    return false;
  }
}
function getMasterSubplotOrder(svg) {
  const labels = svg.querySelectorAll(".rt-subplot-ring-label-text");
  return Array.from(labels).map((label) => label.getAttribute("data-subplot-name")).filter((name) => name !== null);
}

// src/renderer/dom/NumberSquareDOMUpdater.ts
init_sceneHelpers();
function updateNumberSquareStates(svg, plugin, scenes) {
  try {
    let updated = false;
    scenes.forEach((scene) => {
      if (!scene.path) return;
      const encodedPath = encodeURIComponent(scene.path);
      const sceneGroups = svg.querySelectorAll(`.rt-scene-group[data-path="${encodedPath}"]`);
      sceneGroups.forEach((group) => {
        const scenePath = group.querySelector(".rt-scene-path");
        const sceneId = scenePath == null ? void 0 : scenePath.id;
        const numberSquare = sceneId ? svg.querySelector(`.rt-number-square[data-scene-id="${sceneId}"]`) : null;
        const numberText = sceneId ? svg.querySelector(`.rt-number-text[data-scene-id="${sceneId}"]`) : null;
        if (!numberSquare || !numberText) return;
        const { isSceneOpen, isSearchMatch, hasEdits } = getSceneState(scene, plugin);
        let newSquareClasses = buildSquareClasses(isSceneOpen, isSearchMatch, hasEdits);
        let newTextClasses = buildTextClasses(isSceneOpen, isSearchMatch, hasEdits);
        if (shouldDisplayMissingWhenWarning(scene)) {
          newSquareClasses += " rt-missing-when";
          newTextClasses += " rt-missing-when";
        }
        if (plugin.settings.enableAiSceneAnalysis) {
          const existingClasses = numberText.getAttribute("class") || "";
          const gradeMatch = existingClasses.match(/rt-grade-([A-F])/);
          if (gradeMatch) {
            newTextClasses += ` rt-grade-${gradeMatch[1]}`;
          }
        }
        const currentSquareClasses = numberSquare.getAttribute("class");
        if (currentSquareClasses !== newSquareClasses) {
          numberSquare.setAttribute("class", newSquareClasses);
          updated = true;
        }
        const currentTextClasses = numberText.getAttribute("class");
        if (currentTextClasses !== newTextClasses) {
          numberText.setAttribute("class", newTextClasses);
          updated = true;
        }
      });
    });
    return updated;
  } catch (error) {
    console.error("[NumberSquareDOMUpdater] Failed to update number squares:", error);
    return false;
  }
}

// src/renderer/dom/SynopsisDOMUpdater.ts
function updateSynopsisText(svg, changedScenes) {
  try {
    let updated = false;
    changedScenes.forEach((scene) => {
      if (!scene.path || !scene.synopsis) return;
      const encodedPath = encodeURIComponent(scene.path);
      const synopsisElements = svg.querySelectorAll(`[data-scene-path="${encodedPath}"] .rt-synopsis-text`);
      synopsisElements.forEach((element) => {
        const currentText = element.textContent || "";
        const newText = scene.synopsis || "";
        if (currentText !== newText) {
          element.textContent = newText;
          updated = true;
        }
      });
    });
    return updated;
  } catch (error) {
    console.error("[SynopsisDOMUpdater] Failed to update synopsis:", error);
    return false;
  }
}

// src/renderer/dom/SubplotLabelDOMUpdater.ts
function updateSubplotLabels(svg, newLabels) {
  try {
    let updated = false;
    newLabels.forEach((newText, subplotName) => {
      const labelElements = svg.querySelectorAll(`[data-subplot-name="${subplotName}"] textPath`);
      labelElements.forEach((element) => {
        const currentText = element.textContent || "";
        if (currentText !== newText) {
          element.textContent = newText;
          updated = true;
        }
      });
    });
    return updated;
  } catch (error) {
    console.error("[SubplotLabelDOMUpdater] Failed to update subplot labels:", error);
    return false;
  }
}

// src/renderer/TimelineRenderer.ts
init_LayoutConstants();

// src/renderer/renderers/RingRenderer.ts
init_svg();
init_text();
init_sceneHelpers();

// src/utils/numberSquareHelpers.ts
init_svg();
function hashKey(input) {
  let hash = 0;
  for (let i = 0; i < input.length; i++) {
    hash = hash * 31 + input.charCodeAt(i) >>> 0;
  }
  return hash.toString(36);
}
function makeSceneId(actIndex, ring, idx, isOuterAllScenes, isOuter, uniqueKey) {
  const base = isOuterAllScenes && isOuter ? `scene-path-${actIndex}-${ring}-outer-${idx}` : `scene-path-${actIndex}-${ring}-${idx}`;
  if (!uniqueKey) return base;
  return `${base}-${hashKey(uniqueKey)}`;
}
function generateNumberSquareGroup(squareX, squareY, squareSize, squareClasses, sceneId, number, textClasses, grade, options) {
  var _a;
  const cornerRadius = (_a = options == null ? void 0 : options.cornerRadius) != null ? _a : 0;
  const radiusAttr = cornerRadius > 0 ? ` rx="${cornerRadius}" ry="${cornerRadius}"` : "";
  const subplotAttr = (options == null ? void 0 : options.subplotIndex) !== void 0 ? ` data-subplot-idx="${options.subplotIndex}"` : "";
  const dataAttrString = (options == null ? void 0 : options.dataAttrs) ? Object.entries(options.dataAttrs).filter(([, v]) => v !== void 0 && v !== null).map(([k, v]) => `${k}="${escapeXml(String(v))}"`).join(" ") : "";
  const dataAttrs = dataAttrString ? ` ${dataAttrString}` : "";
  return `
        <g class="number-square-group"${dataAttrs} transform="translate(${squareX}, ${squareY})">
            <g class="number-square-orient">
                <rect 
                    x="-${squareSize.width / 2}" 
                    y="-${squareSize.height / 2}" 
                    width="${squareSize.width}" 
                    height="${squareSize.height}" 
                    class="${squareClasses}" 
                    data-scene-id="${escapeXml(sceneId)}"
                    ${radiusAttr}${subplotAttr}
                />
                <text 
                    x="0" 
                    y="0" 
                    text-anchor="middle" 
                    dominant-baseline="middle" 
                    class="${textClasses}"
                    data-scene-id="${escapeXml(sceneId)}"
                    dy="0.1em"
                >${number}</text>
            </g>
        </g>
    `;
}

// src/renderer/renderers/RingRenderer.ts
init_LayoutConstants();

// src/renderer/utils/SceneLayout.ts
init_LayoutConstants();
init_sceneHelpers();
function computePositions(innerR, outerR, startAngle, endAngle, items) {
  const middleRadius = (innerR + outerR) / 2;
  const plotAngularWidth = PLOT_PIXEL_WIDTH / middleRadius;
  const totalAngularSpace = endAngle - startAngle;
  const plotCount = items.filter((it) => isBeatNote(it)).length;
  const plotTotalAngularSpace = plotCount * plotAngularWidth;
  const sceneCount = items.filter((it) => !isBeatNote(it)).length;
  const sceneAngularSize = sceneCount > 0 ? (totalAngularSpace - plotTotalAngularSpace) / sceneCount : 0;
  let current = startAngle;
  const positions = /* @__PURE__ */ new Map();
  items.forEach((it, idx) => {
    if (isBeatNote(it)) {
      positions.set(idx, { startAngle: current, endAngle: current + plotAngularWidth, angularSize: plotAngularWidth });
      current += plotAngularWidth;
    } else {
      positions.set(idx, { startAngle: current, endAngle: current + sceneAngularSize, angularSize: sceneAngularSize });
      current += sceneAngularSize;
    }
  });
  return positions;
}

// src/renderer/utils/SceneFill.ts
init_sceneHelpers();
init_text();
init_date();
function getFillForScene(scene, publishStageColors, subplotColorResolver, isOuterAllScenes, forceSubplotColor) {
  if (isBeatNote(scene)) {
    return "#FFFFFF";
  }
  const subplotName = scene.subplot && scene.subplot.trim().length > 0 ? scene.subplot : "Main Plot";
  if (forceSubplotColor && subplotColorResolver) {
    return subplotColorResolver(subplotName);
  }
  const statusList = Array.isArray(scene.status) ? scene.status : [scene.status];
  const norm = normalizeStatus(statusList[0]);
  const publishStage = scene["Publish Stage"] || "Zero";
  if (!norm) return `url(#plaidTodo${publishStage})`;
  if (norm === "Completed") {
    if (isOuterAllScenes && subplotColorResolver) {
      return subplotColorResolver(subplotName);
    }
    const stageColor = publishStageColors[publishStage] || publishStageColors.Zero;
    return stageColor;
  }
  if (scene.due && isOverdueDateString(scene.due)) return STATUS_COLORS.Due;
  if (norm === "Working") return `url(#plaidWorking${publishStage})`;
  if (norm === "Todo") return `url(#plaidTodo${publishStage})`;
  return STATUS_COLORS[statusList[0]] || STATUS_COLORS.Todo;
}

// src/renderer/utils/LabelMetrics.ts
init_FontMetricsCache();
function estimatePixelsFromTitle(title, fontPx, _fudge, paddingPx) {
  return estimateBeatLabelWidth(title, fontPx, paddingPx);
}

// src/renderer/components/SceneArcs.ts
init_svg();
var TAU = Math.PI * 2;
var FULL_CIRCLE_EPSILON = 1e-4;
function sceneArcPath(innerR, outerR, startAngle, endAngle) {
  const span = Math.abs(endAngle - startAngle);
  const isFullCircle = span >= TAU - FULL_CIRCLE_EPSILON;
  if (isFullCircle) {
    const midAngle = startAngle + (endAngle - startAngle) / 2;
    const innerStartX = formatNumber(innerR * Math.cos(startAngle));
    const innerStartY = formatNumber(innerR * Math.sin(startAngle));
    const outerStartX = formatNumber(outerR * Math.cos(startAngle));
    const outerStartY = formatNumber(outerR * Math.sin(startAngle));
    const outerMidX = formatNumber(outerR * Math.cos(midAngle));
    const outerMidY = formatNumber(outerR * Math.sin(midAngle));
    const innerMidX = formatNumber(innerR * Math.cos(midAngle));
    const innerMidY = formatNumber(innerR * Math.sin(midAngle));
    const outerRadius = formatNumber(outerR);
    const innerRadius = formatNumber(innerR);
    return `
    M ${innerStartX} ${innerStartY}
    L ${outerStartX} ${outerStartY}
    A ${outerRadius} ${outerRadius} 0 1 1 ${outerMidX} ${outerMidY}
    A ${outerRadius} ${outerRadius} 0 1 1 ${outerStartX} ${outerStartY}
    L ${innerStartX} ${innerStartY}
    A ${innerRadius} ${innerRadius} 0 1 0 ${innerMidX} ${innerMidY}
    A ${innerRadius} ${innerRadius} 0 1 0 ${innerStartX} ${innerStartY}
  `;
  }
  return `
    M ${formatNumber(innerR * Math.cos(startAngle))} ${formatNumber(innerR * Math.sin(startAngle))}
    L ${formatNumber(outerR * Math.cos(startAngle))} ${formatNumber(outerR * Math.sin(startAngle))}
    A ${formatNumber(outerR)} ${formatNumber(outerR)} 0 0 1 ${formatNumber(outerR * Math.cos(endAngle))} ${formatNumber(outerR * Math.sin(endAngle))}
    L ${formatNumber(innerR * Math.cos(endAngle))} ${formatNumber(innerR * Math.sin(endAngle))}
    A ${formatNumber(innerR)} ${formatNumber(innerR)} 0 0 0 ${formatNumber(innerR * Math.cos(startAngle))} ${formatNumber(innerR * Math.sin(startAngle))}
  `;
}
function renderVoidCellPath(innerR, outerR, startAngle, endAngle) {
  const path = sceneArcPath(innerR, outerR, startAngle, endAngle);
  return `<path d="${path}" class="rt-void-cell"/>`;
}

// src/renderer/components/Scenes.ts
init_svg();
init_sceneHelpers();
function renderSceneGroup(params) {
  const { scene, act, ring, idx, innerR, outerR, startAngle, endAngle, subplotIdxAttr, subplotColorIdxAttr, titleInset } = params;
  const groupId = `scene-group-${act}-${ring}-${idx}`;
  const colorAttr = subplotColorIdxAttr !== void 0 ? ` data-subplot-color-index="${String(subplotColorIdxAttr)}"` : "";
  return `
    <g class="rt-scene-group${isBeatNote(scene) ? " beats" : ""}" data-item-type="${isBeatNote(scene) ? "Beat" : "Scene"}" data-act="${act}" data-ring="${ring}" data-idx="${idx}" data-start-angle="${formatNumber(startAngle)}" data-end-angle="${formatNumber(endAngle)}" data-inner-r="${formatNumber(innerR)}" data-outer-r="${formatNumber(outerR)}" data-subplot-index="${String(subplotIdxAttr)}"${colorAttr} data-title-inset="${formatNumber(titleInset)}" data-path="${scene.path ? encodeURIComponent(scene.path) : ""}" id="${groupId}">
  `;
}

// src/renderer/modules/ModeRenderingHelpers.ts
init_ModeDefinition();
init_ModeRegistry();
function shouldRenderStoryBeats(plugin) {
  const currentMode = plugin.settings.currentMode || "narrative" /* NARRATIVE */;
  const modeDef = getModeDefinition(currentMode);
  return modeDef.rendering.beatDisplay !== "none";
}
function shouldShowSubplotRings(plugin) {
  const currentMode = plugin.settings.currentMode || "narrative" /* NARRATIVE */;
  const modeDef = getModeDefinition(currentMode);
  return modeDef.rendering.innerRingContent !== "hidden";
}
function shouldShowAllScenesInOuterRing(plugin) {
  const currentMode = plugin.settings.currentMode || "narrative" /* NARRATIVE */;
  const modeDef = getModeDefinition(currentMode);
  return modeDef.rendering.outerRingContent === "narrative" || modeDef.rendering.outerRingContent === "chronologue";
}
function getSubplotLabelText(plugin, subplot, isOuterRing) {
  if (!isOuterRing) {
    return subplot.toUpperCase();
  }
  const currentMode = plugin.settings.currentMode || "narrative" /* NARRATIVE */;
  const modeDef = getModeDefinition(currentMode);
  if (modeDef.rendering.outerRingContent === "narrative") {
    return "ALL SCENES";
  } else if (modeDef.rendering.outerRingContent === "subplot-only") {
    return "MAIN PLOT";
  } else if (modeDef.rendering.outerRingContent === "chronologue") {
    return "CHRONOLOGUE";
  }
  return subplot.toUpperCase();
}

// src/renderer/utils/SynopsisBuilder.ts
init_sceneHelpers();
init_text();

// src/utils/pov.ts
var MODE_KEYWORDS = {
  first: "first",
  "1st": "first",
  second: "second",
  "2nd": "second",
  you: "second",
  third: "third",
  "3rd": "third",
  limited: "third",
  omni: "omni",
  omniscient: "omni",
  objective: "objective",
  narrator: "objective",
  legacy: "legacy",
  pov: "legacy"
};
var COUNT_WORDS = {
  one: 1,
  two: 2,
  three: 3,
  four: 4,
  five: 5,
  six: 6,
  seven: 7,
  eight: 8,
  nine: 9,
  ten: 10,
  dozen: 12
};
var MODE_CONFIG = {
  first: { label: "1", usesCharacters: true },
  third: { label: "3", usesCharacters: true },
  legacy: { label: "1", usesCharacters: true },
  second: { label: "2", usesCharacters: false, syntheticText: "You" },
  omni: { label: "3", usesCharacters: false, syntheticText: "Omni" },
  objective: { label: "0", usesCharacters: false, syntheticText: "Narrator" }
};
function interpretKeyword(raw) {
  if (typeof raw !== "string") return {};
  const trimmed = raw.trim().toLowerCase();
  if (!trimmed) return {};
  const firstToken = trimmed.split(/\s+/)[0];
  const mappedMode = MODE_KEYWORDS[firstToken];
  if (mappedMode) {
    return { modeOverride: mappedMode };
  }
  if (trimmed === "count" || trimmed === "all") {
    return { countOverride: Number.POSITIVE_INFINITY };
  }
  const wordCount = COUNT_WORDS[trimmed];
  if (wordCount) {
    return { countOverride: wordCount };
  }
  const numeric = Number(trimmed);
  if (!Number.isNaN(numeric) && numeric > 0) {
    return { countOverride: numeric };
  }
  return {};
}
function normalizeGlobalMode(mode) {
  if (!mode || mode === "off") return "legacy";
  if (mode === "first" || mode === "second" || mode === "third" || mode === "omni" || mode === "objective") {
    return mode;
  }
  return "legacy";
}
function determineHighlightCount(countOverride, characterCount) {
  if (characterCount <= 0) return 0;
  if (countOverride === void 0) {
    return 1;
  }
  if (!Number.isFinite(countOverride)) {
    return characterCount;
  }
  return Math.max(1, Math.min(characterCount, Math.floor(countOverride)));
}
function resolveScenePov(scene, options) {
  const characters = scene.Character || [];
  const { modeOverride, countOverride } = interpretKeyword(scene.pov);
  const effectiveMode = modeOverride != null ? modeOverride : normalizeGlobalMode(options.globalMode);
  const config = MODE_CONFIG[effectiveMode];
  const syntheticEntries = [];
  const characterMarkers = [];
  if (!config.usesCharacters) {
    if (config.syntheticText) {
      syntheticEntries.push({ text: config.syntheticText, label: config.label });
    }
    return { syntheticEntries, characterMarkers };
  }
  const highlightCount = determineHighlightCount(countOverride, characters.length);
  for (let i = 0; i < highlightCount; i++) {
    if (i >= characters.length) break;
    characterMarkers.push({ index: i, label: config.label });
  }
  return { syntheticEntries, characterMarkers };
}

// src/renderer/utils/SynopsisBuilder.ts
function buildSynopsisElement(plugin, scene, sceneId, maxTextWidth, orderedSubplots, subplotIndexResolver) {
  const fontScale = getReadabilityMultiplier(plugin.settings);
  if (scene.itemType === "Backdrop") {
    const lines = [scene.title || "Untitled"];
    if (scene.synopsis) {
      lines.push(...splitIntoBalancedLines(scene.synopsis, maxTextWidth, fontScale));
    } else if (scene.Description) {
      lines.push(...splitIntoBalancedLines(scene.Description, maxTextWidth, fontScale));
    }
    return plugin.synopsisManager.generateElement(scene, lines, sceneId, subplotIndexResolver);
  }
  const contentLines = [
    scene.title || "",
    ...isBeatNote(scene) && scene.Description ? splitIntoBalancedLines(scene.Description, maxTextWidth, fontScale) : scene.synopsis ? splitIntoBalancedLines(scene.synopsis, maxTextWidth, fontScale) : []
  ];
  if (isBeatNote(scene)) {
    const gossamer1 = scene.Gossamer1;
    if (gossamer1 !== void 0 && gossamer1 !== null) {
      contentLines.push(`<gossamer>${gossamer1}/100</gossamer>`);
    }
  }
  contentLines.push("\xA0");
  if (!isBeatNote(scene)) {
    contentLines.push(orderedSubplots.join(", "));
    const characters = scene.Character || [];
    const povInfo = resolveScenePov(scene, {
      globalMode: plugin.settings.globalPovMode
    });
    const formattedEntries = [];
    povInfo.syntheticEntries.forEach((entry) => {
      formattedEntries.push(`${entry.text} >pov=${entry.label}<`);
    });
    const markerMap = /* @__PURE__ */ new Map();
    povInfo.characterMarkers.forEach((marker) => {
      markerMap.set(marker.index, marker.label);
    });
    characters.forEach((char, index) => {
      const label = markerMap.get(index);
      if (label) {
        formattedEntries.push(`${char} >pov=${label}<`);
      } else {
        formattedEntries.push(char);
      }
    });
    const rawCharacters = formattedEntries.filter((str) => !!str && str.trim().length > 0).join(", ");
    if (rawCharacters) {
      contentLines.push(rawCharacters);
    }
  }
  const filtered = contentLines.filter((line) => line && line.trim() !== "\xA0");
  return plugin.synopsisManager.generateElement(scene, filtered, sceneId, subplotIndexResolver);
}
function appendSynopsisElementForScene({
  plugin,
  scene,
  sceneId,
  maxTextWidth,
  masterSubplotOrder,
  scenes,
  targets
}) {
  if (!scene.title) {
    return;
  }
  const allSceneSubplots = scenes.filter((s) => s.path === scene.path).map((s) => s.subplot).filter((s) => s !== void 0);
  const sceneSubplot = scene.subplot || "Main Plot";
  const orderedSubplots = [sceneSubplot, ...allSceneSubplots.filter((s) => s !== sceneSubplot)];
  try {
    const synopsisElement = buildSynopsisElement(
      plugin,
      scene,
      sceneId,
      maxTextWidth,
      orderedSubplots,
      (name) => {
        const idx = masterSubplotOrder.indexOf(name);
        if (idx < 0) return 0;
        return idx % 16;
      }
    );
    targets.push(synopsisElement);
  } catch (error) {
    console.warn("Failed to build synopsis for scene:", scene.path, error);
  }
}

// src/renderer/components/SubplotDominanceIndicators.ts
init_svg();
function normalizeSubplotName(name) {
  if (name && name.trim().length > 0) {
    return name.trim();
  }
  return "Main Plot";
}
function resolveDominantScene(params) {
  const { scenePath, candidateScenes, masterSubplotOrder, dominantSubplots } = params;
  if (!candidateScenes.length) {
    throw new Error("resolveDominantScene requires at least one candidate scene");
  }
  const selectFallback = () => {
    let fallbackScene = candidateScenes[0];
    let fallbackSubplot = normalizeSubplotName(fallbackScene.subplot);
    let bestIndex = masterSubplotOrder.indexOf(fallbackSubplot);
    if (bestIndex === -1) bestIndex = Infinity;
    candidateScenes.forEach((scene) => {
      const subplotName = normalizeSubplotName(scene.subplot);
      const idx = masterSubplotOrder.indexOf(subplotName);
      if (idx !== -1 && idx < bestIndex) {
        fallbackScene = scene;
        fallbackSubplot = subplotName;
        bestIndex = idx;
      }
    });
    return { scene: fallbackScene, subplot: fallbackSubplot };
  };
  const storedPreference = scenePath && dominantSubplots ? dominantSubplots[scenePath] : void 0;
  if (storedPreference) {
    const matchedScene = candidateScenes.find((scene) => normalizeSubplotName(scene.subplot) === storedPreference);
    if (matchedScene) {
      return {
        scene: matchedScene,
        dominantSubplot: storedPreference,
        storedPreference,
        preferenceMatched: true
      };
    }
    const fallback2 = selectFallback();
    return {
      scene: fallback2.scene,
      dominantSubplot: fallback2.subplot,
      storedPreference,
      preferenceMatched: false
    };
  }
  const fallback = selectFallback();
  return {
    scene: fallback.scene,
    dominantSubplot: fallback.subplot,
    preferenceMatched: false
  };
}
function computeSubplotDominanceStates(params) {
  const { scenes, masterSubplotOrder, dominantSubplots } = params;
  const subplotDominanceStates = /* @__PURE__ */ new Map();
  masterSubplotOrder.forEach((subplot) => {
    subplotDominanceStates.set(subplot, {
      hasSharedOverlap: false,
      hasHiddenSharedScenes: false
    });
  });
  const scenesGroupedByPath = /* @__PURE__ */ new Map();
  scenes.forEach((scene) => {
    if (!scene.path) return;
    if (!scenesGroupedByPath.has(scene.path)) {
      scenesGroupedByPath.set(scene.path, []);
    }
    scenesGroupedByPath.get(scene.path).push(scene);
  });
  scenesGroupedByPath.forEach((items, path) => {
    const uniqueSubplots = Array.from(
      new Set(items.map((scene) => normalizeSubplotName(scene.subplot)))
    );
    if (uniqueSubplots.length <= 1) return;
    const { dominantSubplot } = resolveDominantScene({
      scenePath: path,
      candidateScenes: items,
      masterSubplotOrder,
      dominantSubplots
    });
    uniqueSubplots.forEach((subplotName) => {
      const existing = subplotDominanceStates.get(subplotName) || {
        hasSharedOverlap: false,
        hasHiddenSharedScenes: false
      };
      existing.hasSharedOverlap = true;
      if (subplotName !== dominantSubplot) {
        existing.hasHiddenSharedScenes = true;
      }
      subplotDominanceStates.set(subplotName, existing);
    });
  });
  return subplotDominanceStates;
}
function renderSubplotDominanceIndicators(params) {
  const { masterSubplotOrder, ringStartRadii, ringWidths, subplotStates, subplotColorFor } = params;
  if (masterSubplotOrder.length === 0) return "";
  const TRIANGLE_SIZE = 11;
  const RADIAL_INSET = 11;
  const TANGENT_OFFSET = 10.7;
  const CENTER_OFFSET_X = 10;
  const CENTER_OFFSET_Y = 0;
  const totalRings = masterSubplotOrder.length;
  const iconAngle = -Math.PI / 2;
  const radialX = Math.cos(iconAngle);
  const radialY = Math.sin(iconAngle);
  const tangentX = Math.round(-radialY);
  const tangentY = Math.round(radialX);
  let svg = '<g class="rt-subplot-dominance-flags">';
  masterSubplotOrder.forEach((subplotName, offset) => {
    const state = subplotStates.get(subplotName);
    if (!state || !state.hasSharedOverlap) return;
    const ring = totalRings - offset - 1;
    const innerR = ringStartRadii[ring];
    if (innerR === void 0) return;
    const iconRadius = Math.round(innerR + RADIAL_INSET);
    const iconX = Math.round(iconRadius * radialX);
    const iconY = Math.round(iconRadius * radialY);
    const path = `M 0 0 L 0 ${TRIANGLE_SIZE} L ${TRIANGLE_SIZE} ${TRIANGLE_SIZE} Z`;
    const cssClass = state.hasHiddenSharedScenes ? "is-hidden" : "is-shown";
    const subplotColor = subplotColorFor(subplotName);
    const finalX = iconX + tangentX * TANGENT_OFFSET - CENTER_OFFSET_X;
    const finalY = iconY + tangentY * TANGENT_OFFSET - CENTER_OFFSET_Y;
    const styleAttr = `style="--flag-color: ${subplotColor}"`;
    svg += `
            <g class="rt-subplot-dominance-flag ${cssClass}"
               data-subplot-name="${escapeXml(subplotName)}"
               data-has-hidden="${state.hasHiddenSharedScenes ? "true" : "false"}"
               transform="translate(${finalX} ${finalY})"
               ${styleAttr}>
                <path d="${path}" />
            </g>
        `;
  });
  svg += "</g>";
  return svg;
}

// src/renderer/renderers/RingRenderer.ts
function renderRings(ctx) {
  const {
    plugin,
    scenes,
    actsToRender,
    sortByWhen,
    isChronologueMode,
    forceChronological,
    masterSubplotOrder,
    colorIndexBySubplot,
    ringStartRadii,
    ringWidths,
    scenesByActAndSubplot,
    PUBLISH_STAGE_COLORS,
    maxTextWidth,
    synopsesElements,
    sceneGrades,
    manuscriptOrderPositions,
    numActs
  } = ctx;
  let svg = "";
  const fontScale = getReadabilityMultiplier(plugin.settings);
  const NUM_RINGS = masterSubplotOrder.length;
  const readabilityScale = plugin.settings.readabilityScale || "normal";
  const beatTextRadius = BEAT_TEXT_RADIUS[readabilityScale] || BEAT_TEXT_RADIUS.normal;
  const resolveSubplotColorIndex = (subplotName) => {
    const key = subplotName && subplotName.trim().length > 0 ? subplotName : "Main Plot";
    if (colorIndexBySubplot.has(key)) return colorIndexBySubplot.get(key);
    const fallback = colorIndexBySubplot.get("Main Plot");
    return fallback !== void 0 ? fallback : 0;
  };
  const subplotColorFor = (subplotName) => {
    const normalized = resolveSubplotColorIndex(subplotName) % 16;
    const varName = `--rt-subplot-colors-${normalized}`;
    try {
      const computed = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
      return computed || "#EFBDEB";
    } catch (e) {
      return "#EFBDEB";
    }
  };
  const currentMode = plugin.settings.currentMode || "narrative";
  const forceSubplotFillColors = currentMode === "narrative" || currentMode === "chronologue";
  for (let act = 0; act < actsToRender; act++) {
    const totalRings = NUM_RINGS;
    const subplotCount = masterSubplotOrder.length;
    const ringsToUse = Math.min(subplotCount, totalRings);
    for (let ringOffset = 0; ringOffset < ringsToUse; ringOffset++) {
      const ring = totalRings - ringOffset - 1;
      const innerR = ringStartRadii[ring];
      const outerR = innerR + ringWidths[ring];
      let startAngle;
      let endAngle;
      if (sortByWhen) {
        startAngle = -Math.PI / 2;
        endAngle = 3 * Math.PI / 2;
      } else {
        const totalActsDivisor = actsToRender || numActs;
        startAngle = act * 2 * Math.PI / totalActsDivisor - Math.PI / 2;
        endAngle = (act + 1) * 2 * Math.PI / totalActsDivisor - Math.PI / 2;
      }
      const subplot = masterSubplotOrder[ringOffset];
      if (subplot === "Backdrop") continue;
      const isOuterRing = ringOffset === 0;
      if (isOuterRing && shouldShowAllScenesInOuterRing(plugin)) {
        const seenPaths = /* @__PURE__ */ new Set();
        const seenPlotKeys = /* @__PURE__ */ new Set();
        const combined = [];
        const scenesByPath = /* @__PURE__ */ new Map();
        scenes.forEach((s) => {
          var _a;
          if (s.itemType === "Backdrop") return;
          if (!sortByWhen) {
            const sAct = s.actNumber !== void 0 ? s.actNumber - 1 : 0;
            if (sAct !== act) return;
          }
          if (isBeatNote(s)) {
            if (isChronologueMode) return;
            const pKey = `${String(s.title || "")}::${String((_a = s.actNumber) != null ? _a : "")}`;
            if (!seenPlotKeys.has(pKey)) {
              seenPlotKeys.add(pKey);
              combined.push(s);
            }
          } else {
            const key = s.path || `${s.title || ""}::${String(s.when || "")}`;
            if (!scenesByPath.has(key)) {
              scenesByPath.set(key, []);
            }
            scenesByPath.get(key).push(s);
          }
        });
        scenesByPath.forEach((scenesForPath, pathKey) => {
          var _a, _b, _c, _d, _e, _f;
          if (seenPaths.has(pathKey)) return;
          seenPaths.add(pathKey);
          const scenePath = scenesForPath[0].path;
          const resolution = resolveDominantScene({
            scenePath,
            candidateScenes: scenesForPath,
            masterSubplotOrder,
            dominantSubplots: plugin.settings.dominantSubplots
          });
          if (scenePath && resolution.storedPreference && !resolution.preferenceMatched && plugin.settings.dominantSubplots) {
            delete plugin.settings.dominantSubplots[scenePath];
          }
          combined.push(resolution.scene);
          const sceneIndex = combined.length - 1;
          const uniqueKey = ((_a = resolution.scene) == null ? void 0 : _a.path) || `${((_b = resolution.scene) == null ? void 0 : _b.title) || ""}::${(_d = (_c = resolution.scene) == null ? void 0 : _c.number) != null ? _d : ""}::${(_f = (_e = resolution.scene) == null ? void 0 : _e.when) != null ? _f : ""}`;
          const allScenesSceneId = makeSceneId(act, NUM_RINGS - 1, sceneIndex, true, true, uniqueKey);
          extractGradeFromScene(resolution.scene, allScenesSceneId, sceneGrades, plugin);
        });
        const sortedCombined = sortScenes(combined, sortByWhen, forceChronological);
        const positions = computePositions(innerR, outerR, startAngle, endAngle, sortedCombined);
        if (isChronologueMode && manuscriptOrderPositions) {
          sortedCombined.forEach((scene, idx) => {
            const position = positions.get(idx);
            if (position) {
              const key = scene.path || `title:${scene.title || ""}`;
              manuscriptOrderPositions.set(key, position);
            }
          });
        }
        sortedCombined.forEach((scene, idx) => {
          var _a, _b;
          const { text } = parseSceneTitle(scene.title || "", scene.number);
          const position = positions.get(idx);
          const sceneStartAngle = position.startAngle;
          const sceneEndAngle = position.endAngle;
          const effectiveOuterR = isBeatNote(scene) ? outerR + 2 : outerR;
          if (isBeatNote(scene) && scene.title) {
            const titleWithoutNumber = scene.title.replace(/^\s*\d+(?:\.\d+)?\s+/, "").trim();
            const center = (sceneStartAngle + sceneEndAngle) / 2;
            plugin._beatAngles.set(titleWithoutNumber, center);
            if (!plugin._beatSlices) plugin._beatSlices = /* @__PURE__ */ new Map();
            plugin._beatSlices.set(titleWithoutNumber, {
              startAngle: sceneStartAngle,
              endAngle: sceneEndAngle,
              innerR,
              outerR: effectiveOuterR
            });
          }
          const sceneTitleInset = SCENE_TITLE_INSET + (fontScale - 1) * 18;
          const textPathRadius = Math.max(innerR, outerR - sceneTitleInset);
          const textPathLargeArcFlag = sceneEndAngle - (sceneStartAngle + TEXTPATH_START_NUDGE_RAD) > Math.PI ? 1 : 0;
          const color = getFillForScene(scene, PUBLISH_STAGE_COLORS, subplotColorFor, true, forceSubplotFillColors);
          const arcPathStr = sceneArcPath(innerR, effectiveOuterR, sceneStartAngle, sceneEndAngle);
          const sceneUniqueKey = scene.path || `${scene.title || ""}::${(_a = scene.number) != null ? _a : ""}::${(_b = scene.when) != null ? _b : ""}`;
          const sceneId = makeSceneId(act, ring, idx, true, true, sceneUniqueKey);
          appendSynopsisElementForScene({
            plugin,
            scene,
            sceneId,
            maxTextWidth,
            masterSubplotOrder,
            scenes,
            targets: synopsesElements
          });
          let sceneClasses = "rt-scene-path";
          if (scene.path && plugin.openScenePaths.has(scene.path)) sceneClasses += " rt-scene-is-open";
          const dyOffset = 0;
          const rawTitleFull = (() => {
            const full = scene.title || "";
            const m = full.match(/^(?:\s*\d+(?:\.\d+)?\s+)?(.+)/);
            return m ? m[1] : full;
          })();
          const estimatedWidth = estimatePixelsFromTitle(
            rawTitleFull,
            BEAT_FONT_PX * fontScale,
            ESTIMATE_FUDGE_RENDER,
            PADDING_RENDER_PX * fontScale
          );
          const labelStartAngle = sceneStartAngle;
          const labelEndAngle = sceneStartAngle + estimatedWidth / beatTextRadius;
          const desiredAngleArc = labelEndAngle - labelStartAngle;
          const largeArcFlag = desiredAngleArc > Math.PI ? 1 : 0;
          const subplotIdxAttr = (() => {
            const name = scene.subplot && scene.subplot.trim().length > 0 ? scene.subplot : "Main Plot";
            return Math.max(0, masterSubplotOrder.indexOf(name));
          })();
          const subplotColorIdxAttr = resolveSubplotColorIndex(scene.subplot || "Main Plot");
          const plotStrokeAttr = (() => {
            if (isBeatNote(scene)) {
              const publishStage = scene["Publish Stage"] || "Zero";
              const stageColor = PUBLISH_STAGE_COLORS[publishStage] || PUBLISH_STAGE_COLORS.Zero;
              return `stroke="${stageColor}" stroke-width="2"`;
            }
            return "";
          })();
          svg += `
                        ${renderSceneGroup({
            scene,
            act,
            ring,
            idx,
            innerR,
            outerR: effectiveOuterR,
            startAngle: sceneStartAngle,
            endAngle: sceneEndAngle,
            subplotIdxAttr,
            subplotColorIdxAttr,
            titleInset: sceneTitleInset
          })}
                            <path id="${sceneId}"
                                  d="${arcPathStr}" 
                                  fill="${color}" 
                                  ${plotStrokeAttr}
                                  class="${sceneClasses}"/>
                            ${!isBeatNote(scene) ? `
                            <path id="textPath-${act}-${ring}-outer-${idx}" 
                                  d="M ${formatNumber(textPathRadius * Math.cos(sceneStartAngle + TEXTPATH_START_NUDGE_RAD))} ${formatNumber(textPathRadius * Math.sin(sceneStartAngle + TEXTPATH_START_NUDGE_RAD))} 
                                     A ${formatNumber(textPathRadius)} ${formatNumber(textPathRadius)} 0 ${textPathLargeArcFlag} 1 ${formatNumber(textPathRadius * Math.cos(sceneEndAngle))} ${formatNumber(textPathRadius * Math.sin(sceneEndAngle))}" 
                                  fill="none"/>
                            <text class="rt-scene-title${scene.path && plugin.openScenePaths.has(scene.path) ? " rt-scene-is-open" : ""}" dy="${dyOffset}" data-scene-id="${sceneId}">
                                <textPath href="#textPath-${act}-${ring}-outer-${idx}" startOffset="4">
                                    ${text}
                                </textPath>
                            </text>` : `
                            <path id="plot-label-arc-${act}-${ring}-outer-${idx}" 
                                  d="M ${formatNumber(beatTextRadius * Math.cos(labelStartAngle))} ${formatNumber(beatTextRadius * Math.sin(labelStartAngle))} 
                                     A ${formatNumber(beatTextRadius)} ${formatNumber(beatTextRadius)} 0 ${largeArcFlag} 1 ${formatNumber(beatTextRadius * Math.cos(labelEndAngle))} ${formatNumber(beatTextRadius * Math.sin(labelEndAngle))}" 
                                  data-slice-start="${formatNumber(sceneStartAngle)}" data-radius="${formatNumber(beatTextRadius)}" fill="none"/>
                            <text class="rt-storybeat-title" dy="-3">
                                <textPath href="#plot-label-arc-${act}-${ring}-outer-${idx}" startOffset="2">
                                    ${escapeXml(rawTitleFull)}
                                </textPath>
                            </text>
                            `}
                        </g>`;
        });
        const totalUsedSpace = Array.from(positions.values()).reduce((sum, p) => sum + p.angularSize, 0);
        const totalAngularSpace = endAngle - startAngle;
        const remainingVoidSpace = totalAngularSpace - totalUsedSpace;
        if (remainingVoidSpace > 1e-3) {
          const voidStartAngle = startAngle + totalUsedSpace;
          const voidEndAngle = endAngle;
          svg += renderVoidCellPath(innerR, outerR, voidStartAngle, voidEndAngle);
        }
        continue;
      }
      const currentScenes = subplot ? scenesByActAndSubplot[act][subplot] || [] : [];
      if (currentScenes && currentScenes.length > 0) {
        const sortedCurrentScenes = sortScenes(currentScenes, sortByWhen, forceChronological);
        const isAllScenesMode = shouldShowAllScenesInOuterRing(plugin);
        const effectiveScenes = sortedCurrentScenes.filter((scene) => !isBeatNote(scene));
        const scenePositions = computePositions(innerR, outerR, startAngle, endAngle, effectiveScenes);
        effectiveScenes.forEach((scene, idx) => {
          var _a, _b;
          const { text } = parseSceneTitle(scene.title || "", scene.number);
          const position = scenePositions.get(idx);
          if (!position) return;
          const sceneStartAngle = position.startAngle;
          const sceneEndAngle = position.endAngle;
          const sceneTitleInset = SCENE_TITLE_INSET + (fontScale - 1) * 18;
          const textPathRadius = Math.max(innerR, outerR - sceneTitleInset);
          const textPathLargeArcFlag = sceneEndAngle - (sceneStartAngle + TEXTPATH_START_NUDGE_RAD) > Math.PI ? 1 : 0;
          const color = getFillForScene(
            scene,
            PUBLISH_STAGE_COLORS,
            subplotColorFor,
            isAllScenesMode,
            forceSubplotFillColors
          );
          const arcPathStr = sceneArcPath(innerR, outerR, sceneStartAngle, sceneEndAngle);
          const sceneUniqueKey = scene.path || `${scene.title || ""}::${(_a = scene.number) != null ? _a : ""}::${(_b = scene.when) != null ? _b : ""}`;
          const sceneId = makeSceneId(act, ring, idx, false, false, sceneUniqueKey);
          const subplotIdxAttr = (() => {
            const name = scene.subplot && scene.subplot.trim().length > 0 ? scene.subplot : "Main Plot";
            return Math.max(0, masterSubplotOrder.indexOf(name));
          })();
          const subplotColorIdxAttr = resolveSubplotColorIndex(scene.subplot || "Main Plot");
          let sceneClasses = "rt-scene-path rt-scene-arc";
          if (scene.path && plugin.openScenePaths.has(scene.path)) sceneClasses += " rt-scene-is-open";
          const dyOffset = 0;
          svg += `
                        ${renderSceneGroup({
            scene,
            act,
            ring,
            idx,
            innerR,
            outerR,
            startAngle: sceneStartAngle,
            endAngle: sceneEndAngle,
            subplotIdxAttr,
            subplotColorIdxAttr,
            titleInset: sceneTitleInset
          })}
                            <path id="${sceneId}"
                                  d="${arcPathStr}" 
                                  fill="${color}" 
                                  class="${sceneClasses}"/>

                            ${!isBeatNote(scene) ? `
                            <path id="textPath-${act}-${ring}-${idx}" 
                                  d="M ${formatNumber(textPathRadius * Math.cos(sceneStartAngle + TEXTPATH_START_NUDGE_RAD))} ${formatNumber(textPathRadius * Math.sin(sceneStartAngle + TEXTPATH_START_NUDGE_RAD))} 
                                     A ${formatNumber(textPathRadius)} ${formatNumber(textPathRadius)} 0 ${textPathLargeArcFlag} 1 ${formatNumber(textPathRadius * Math.cos(sceneEndAngle))} ${formatNumber(textPathRadius * Math.sin(sceneEndAngle))}" 
                                  fill="none"/>
                            <text class="rt-scene-title${scene.path && plugin.openScenePaths.has(scene.path) ? " rt-scene-is-open" : ""}" data-scene-id="${sceneId}">
                                <textPath href="#textPath-${act}-${ring}-${idx}" startOffset="4">
                                    ${text}
                                </textPath>
                            </text>` : ``}
                        </g>`;
        });
        const totalUsedSpace = Array.from(scenePositions.values()).reduce((sum, p) => sum + p.angularSize, 0);
        const totalAngularSpace = endAngle - startAngle;
        const remainingVoidSpace = totalAngularSpace - totalUsedSpace;
        if (remainingVoidSpace > 1e-3) {
          const voidStartAngle = startAngle + totalUsedSpace;
          const voidEndAngle = endAngle;
          svg += renderVoidCellPath(innerR, outerR, voidStartAngle, voidEndAngle);
        }
      } else {
        svg += renderVoidCellPath(innerR, outerR, startAngle, endAngle);
      }
    }
  }
  return svg;
}

// src/renderer/utils/GridData.ts
init_sceneHelpers();
init_text();
init_date();
function computeGridData(scenes) {
  const sceneNotesOnly = scenes.filter((scene) => !isBeatNote(scene));
  const processedScenes = /* @__PURE__ */ new Set();
  const statusCounts = sceneNotesOnly.reduce((acc, scene) => {
    var _a;
    if (scene.path && processedScenes.has(scene.path)) {
      return acc;
    }
    if (scene.path) {
      processedScenes.add(scene.path);
    }
    const normalizedStatus = ((_a = scene.status) == null ? void 0 : _a.toString().trim().toLowerCase()) || "";
    if (!normalizedStatus || normalizedStatus === "") {
      acc["Todo"] = (acc["Todo"] || 0) + 1;
      return acc;
    }
    if (normalizedStatus === "complete") {
      const publishStage = scene["Publish Stage"] || "Zero";
      acc[publishStage] = (acc[publishStage] || 0) + 1;
    } else if (scene.due) {
      if (isOverdueDateString(scene.due)) {
        acc["Due"] = (acc["Due"] || 0) + 1;
      } else {
        let statusKey = "Todo";
        if (scene.status) {
          if (Array.isArray(scene.status) && scene.status.length > 0) {
            statusKey = String(scene.status[0]);
          } else if (typeof scene.status === "string") {
            statusKey = scene.status;
          }
        }
        acc[statusKey] = (acc[statusKey] || 0) + 1;
      }
    } else {
      let statusKey = "Todo";
      if (scene.status) {
        if (Array.isArray(scene.status) && scene.status.length > 0) {
          statusKey = String(scene.status[0]);
        } else if (typeof scene.status === "string") {
          statusKey = scene.status;
        }
      }
      acc[statusKey] = (acc[statusKey] || 0) + 1;
    }
    return acc;
  }, {});
  const processedPathsForGrid = /* @__PURE__ */ new Set();
  const gridCounts = {};
  STAGES_FOR_GRID.forEach((s) => {
    gridCounts[s] = { Todo: 0, Working: 0, Due: 0, Completed: 0 };
  });
  scenes.forEach((scene) => {
    if (isBeatNote(scene)) return;
    if (!scene.path || processedPathsForGrid.has(scene.path)) return;
    processedPathsForGrid.add(scene.path);
    const rawStage = scene["Publish Stage"];
    const stageKey = STAGES_FOR_GRID.includes(rawStage) ? rawStage : "Zero";
    const normalized = normalizeStatus(scene.status);
    let bucket = "Todo";
    if (normalized === "Completed") {
      bucket = "Completed";
    } else if (scene.due && isOverdueDateString(scene.due)) {
      bucket = "Due";
    } else if (normalized) {
      bucket = normalized;
    }
    if (!(bucket in gridCounts[stageKey])) {
      bucket = "Todo";
    }
    gridCounts[stageKey][bucket] += 1;
  });
  const uniqueScenesCount = processedPathsForGrid.size;
  const seenForMax = /* @__PURE__ */ new Set();
  let highestPrefixNumber = 0;
  scenes.forEach((scene) => {
    if (isBeatNote(scene)) return;
    if (!scene.path || seenForMax.has(scene.path)) return;
    seenForMax.add(scene.path);
    const { number } = parseSceneTitle(scene.title || "", scene.number);
    if (number) {
      const n = parseFloat(String(number));
      if (!isNaN(n)) {
        highestPrefixNumber = Math.max(highestPrefixNumber, n);
      }
    }
  });
  const estimatedTotalScenes = Math.max(uniqueScenesCount, Math.floor(highestPrefixNumber));
  return {
    statusCounts,
    gridCounts,
    estimatedTotalScenes
  };
}

// src/renderer/renderers/NumberSquareRenderer.ts
init_sceneHelpers();

// src/renderer/components/NumberSquares.ts
init_svg();
init_sceneHelpers();
init_text();
function renderNumberSquaresUnified(params) {
  const {
    plugin,
    scenes,
    sceneGrades,
    positions,
    squareRadius,
    act,
    ringOuter,
    NUM_RINGS,
    masterSubplotOrder,
    ringStartRadii,
    ringWidths,
    scenesByActAndSubplot,
    sceneNumbersMap,
    enableSubplotColors = false,
    resolveSubplotVisual,
    numActs
  } = params;
  let svg = '<g class="rt-number-squares">';
  const readabilityScale = getReadabilityMultiplier(plugin.settings);
  const squareScale = readabilityScale > 1 ? 1 + (readabilityScale - 1) * 0.75 : 1;
  const totalActs = numActs != null ? numActs : 3;
  scenes.forEach((scene, idx) => {
    var _a, _b, _c;
    if (isBeatNote(scene) || scene.itemType === "Backdrop") return;
    const number = getScenePrefixNumber(scene.title, scene.number);
    if (!number) return;
    let sceneStartAngle;
    let textPathRadius;
    let sceneId;
    const uniqueKey = scene.path || (scene.title ? `${scene.title}::${(_a = scene.number) != null ? _a : ""}::${(_b = scene.when) != null ? _b : ""}` : void 0);
    let posForOuter;
    if (positions && squareRadius !== void 0 && act !== void 0 && ringOuter !== void 0) {
      const pos = positions.get(idx);
      if (!pos) return;
      sceneStartAngle = pos.startAngle;
      textPathRadius = squareRadius;
      sceneId = makeSceneId(act, ringOuter, idx, true, true, uniqueKey);
      posForOuter = pos;
    } else if (NUM_RINGS && masterSubplotOrder && ringStartRadii && ringWidths && scenesByActAndSubplot) {
      const subplot = scene.subplot || "Main Plot";
      const subplotIndex = masterSubplotOrder.indexOf(subplot);
      const ring = NUM_RINGS - 1 - subplotIndex;
      const currentMode = plugin.settings.currentMode || "narrative";
      const isChronologueMode = currentMode === "chronologue";
      const sortByWhen = isChronologueMode ? true : (_c = plugin.settings.sortByWhenDate) != null ? _c : false;
      const sceneActNumber = scene.actNumber !== void 0 ? scene.actNumber : 1;
      const actIndex = sortByWhen ? 0 : sceneActNumber - 1;
      const scenesInActAndSubplot = scenesByActAndSubplot[actIndex] && scenesByActAndSubplot[actIndex][subplot] || [];
      const filteredScenes = scenesInActAndSubplot.filter((s) => !isBeatNote(s));
      const sceneIndex = filteredScenes.indexOf(scene);
      let startAngle;
      let endAngle;
      if (sortByWhen) {
        startAngle = -Math.PI / 2;
        endAngle = 3 * Math.PI / 2;
      } else {
        startAngle = actIndex * 2 * Math.PI / totalActs - Math.PI / 2;
        endAngle = (actIndex + 1) * 2 * Math.PI / totalActs - Math.PI / 2;
      }
      const innerR = ringStartRadii[ring];
      const outerR = innerR + ringWidths[ring];
      const totalAngularSpace = endAngle - startAngle;
      const sceneAngularSize = filteredScenes.length > 0 ? totalAngularSpace / filteredScenes.length : 0;
      let currentAngle = startAngle;
      for (let i = 0; i < sceneIndex; i++) currentAngle += sceneAngularSize;
      sceneStartAngle = currentAngle;
      textPathRadius = (ringStartRadii[ring] + (ringStartRadii[ring] + ringWidths[ring])) / 2;
      sceneId = makeSceneId(actIndex, ring, sceneIndex, false, false, uniqueKey);
    } else {
      return;
    }
    const squareSize = getNumberSquareSize(number, squareScale);
    const squareX = textPathRadius * Math.cos(sceneStartAngle);
    const squareY = textPathRadius * Math.sin(sceneStartAngle);
    const { isSceneOpen, isSearchMatch, hasEdits } = getSceneState(scene, plugin);
    let squareClasses = buildSquareClasses(isSceneOpen, isSearchMatch, hasEdits);
    let textClasses = buildTextClasses(isSceneOpen, isSearchMatch, hasEdits);
    const grade = sceneGrades.get(sceneId);
    if (plugin.settings.enableAiSceneAnalysis && grade) {
      textClasses += ` rt-grade-${grade}`;
    }
    if (shouldDisplayMissingWhenWarning(scene)) {
      squareClasses += " rt-missing-when";
      textClasses += " rt-missing-when";
    }
    if (sceneNumbersMap) {
      sceneNumbersMap.set(sceneId, { number, x: squareX, y: squareY, width: squareSize.width, height: squareSize.height });
    }
    const subplotVisual = enableSubplotColors && resolveSubplotVisual ? resolveSubplotVisual(scene) : null;
    const baseDataAttrs = subplotVisual ? {
      "data-subplot-color-index": subplotVisual.subplotIndex,
      "data-subplot-index": subplotVisual.subplotIndex
    } : void 0;
    const dataAttrs = posForOuter ? {
      ...baseDataAttrs,
      "data-outer-ring": "true",
      "data-scene-order": idx,
      "data-act": act,
      "data-ring": ringOuter,
      "data-start-angle": formatNumber(posForOuter.startAngle),
      "data-end-angle": formatNumber(posForOuter.endAngle)
    } : baseDataAttrs;
    svg += generateNumberSquareGroup(
      squareX,
      squareY,
      squareSize,
      squareClasses,
      sceneId,
      number,
      textClasses,
      grade,
      {
        cornerRadius: 4,
        subplotIndex: subplotVisual == null ? void 0 : subplotVisual.subplotIndex,
        dataAttrs
      }
    );
  });
  svg += "</g>";
  return svg;
}
function renderOuterRingNumberSquares(params) {
  return renderNumberSquaresUnified({
    plugin: params.plugin,
    scenes: params.combined,
    sceneGrades: params.sceneGrades,
    positions: params.positions,
    squareRadius: params.squareRadiusOuter,
    act: params.act,
    ringOuter: params.ringOuter,
    enableSubplotColors: params.enableSubplotColors,
    resolveSubplotVisual: params.resolveSubplotVisual
  });
}
function renderInnerRingsNumberSquaresAllScenes(params) {
  var _a;
  const { plugin, NUM_RINGS, masterSubplotOrder, ringStartRadii, ringWidths, scenesByActAndSubplot, scenes, sceneGrades, enableSubplotColors = false, resolveSubplotVisual, numActs } = params;
  const readabilityScale = getReadabilityMultiplier(plugin.settings);
  const squareScale = readabilityScale > 1 ? 1 + (readabilityScale - 1) * 0.75 : 1;
  const totalActs = numActs != null ? numActs : 3;
  const currentMode = plugin.settings.currentMode || "narrative";
  const isChronologueMode = currentMode === "chronologue";
  const sortByWhen = isChronologueMode ? true : (_a = plugin.settings.sortByWhenDate) != null ? _a : false;
  let svg = "";
  scenes.forEach((scene) => {
    var _a2, _b;
    if (isBeatNote(scene) || scene.itemType === "Backdrop") return;
    const number = getScenePrefixNumber(scene.title, scene.number);
    if (!number) return;
    const subplot = scene.subplot && scene.subplot.trim().length > 0 ? scene.subplot : "Main Plot";
    if (subplot === "Main Plot") return;
    const subplotIndex = masterSubplotOrder.indexOf(subplot);
    if (subplotIndex === -1) return;
    const ring = NUM_RINGS - 1 - subplotIndex;
    if (ring < 0 || ring >= NUM_RINGS) return;
    const sceneActNumber = scene.actNumber !== void 0 ? scene.actNumber : 1;
    const actIndex = sortByWhen ? 0 : sceneActNumber - 1;
    const scenesInActAndSubplot = scenesByActAndSubplot[actIndex] && scenesByActAndSubplot[actIndex][subplot] || [];
    const filteredScenesForIndex = scenesInActAndSubplot.filter((s) => !isBeatNote(s));
    const sceneKey = scene.path || scene.title || "";
    const sceneIndex = filteredScenesForIndex.findIndex((s) => (s.path || s.title || "") === sceneKey);
    if (sceneIndex === -1) return;
    let startAngle;
    let endAngle;
    if (sortByWhen) {
      startAngle = -Math.PI / 2;
      endAngle = 3 * Math.PI / 2;
    } else {
      startAngle = actIndex * 2 * Math.PI / totalActs - Math.PI / 2;
      endAngle = (actIndex + 1) * 2 * Math.PI / totalActs - Math.PI / 2;
    }
    const innerR = ringStartRadii[ring];
    const outerR = innerR + ringWidths[ring];
    const middleRadius = (innerR + outerR) / 2;
    const totalAngularSpace = endAngle - startAngle;
    const sceneAngularSize = filteredScenesForIndex.length > 0 ? totalAngularSpace / filteredScenesForIndex.length : 0;
    let currentAngle = startAngle;
    for (let i = 0; i < sceneIndex; i++) currentAngle += sceneAngularSize;
    const sceneStartAngle = currentAngle;
    const textPathRadius = (innerR + outerR) / 2;
    const squareSize = getNumberSquareSize(number, squareScale);
    const squareX = textPathRadius * Math.cos(sceneStartAngle);
    const squareY = textPathRadius * Math.sin(sceneStartAngle);
    const { isSceneOpen, isSearchMatch, hasEdits } = getSceneState(scene, plugin);
    let squareClasses = buildSquareClasses(isSceneOpen, isSearchMatch, hasEdits);
    let textClasses = buildTextClasses(isSceneOpen, isSearchMatch, hasEdits);
    if (shouldDisplayMissingWhenWarning(scene)) {
      squareClasses += " rt-missing-when";
      textClasses += " rt-missing-when";
    }
    const uniqueKey = scene.path || (scene.title ? `${scene.title}::${(_a2 = scene.number) != null ? _a2 : ""}::${(_b = scene.when) != null ? _b : ""}` : void 0);
    const sceneId = makeSceneId(actIndex, ring, sceneIndex, false, false, uniqueKey);
    extractGradeFromScene(scene, sceneId, sceneGrades, plugin);
    const grade = sceneGrades.get(sceneId);
    if (plugin.settings.enableAiSceneAnalysis && grade) textClasses += ` rt-grade-${grade}`;
    const subplotVisual = enableSubplotColors && resolveSubplotVisual ? resolveSubplotVisual(scene) : null;
    svg += generateNumberSquareGroup(
      squareX,
      squareY,
      squareSize,
      squareClasses,
      sceneId,
      number,
      textClasses,
      grade,
      {
        cornerRadius: 4,
        subplotIndex: subplotVisual == null ? void 0 : subplotVisual.subplotIndex
      }
    );
  });
  return svg;
}
function renderNumberSquaresStandard(params) {
  return renderNumberSquaresUnified({
    plugin: params.plugin,
    scenes: params.scenes,
    sceneGrades: params.sceneGrades,
    NUM_RINGS: params.NUM_RINGS,
    masterSubplotOrder: params.masterSubplotOrder,
    ringStartRadii: params.ringStartRadii,
    ringWidths: params.ringWidths,
    scenesByActAndSubplot: params.scenesByActAndSubplot,
    sceneNumbersMap: params.sceneNumbersMap,
    enableSubplotColors: params.enableSubplotColors,
    resolveSubplotVisual: params.resolveSubplotVisual,
    numActs: params.numActs
  });
}

// src/renderer/renderers/NumberSquareRenderer.ts
function renderNumberSquares(ctx) {
  var _a;
  const {
    plugin,
    scenes,
    scenesByActAndSubplot,
    masterSubplotOrder,
    ringStartRadii,
    ringWidths,
    sceneGrades,
    sceneNumbersMap,
    numberSquareVisualResolver,
    shouldApplyNumberSquareColors,
    numActs
  } = ctx;
  let svg = "";
  const NUM_RINGS = masterSubplotOrder.length;
  const totalActs = Math.max(3, numActs || getConfiguredActCount(plugin.settings));
  if (shouldShowAllScenesInOuterRing(plugin)) {
    svg += `<g class="rt-number-squares">`;
    const ringOuter = NUM_RINGS - 1;
    const innerROuter = ringStartRadii[ringOuter];
    const outerROuter = innerROuter + ringWidths[ringOuter];
    const squareRadiusOuter = (innerROuter + outerROuter) / 2;
    const currentMode = plugin.settings.currentMode || "narrative";
    const isChronologueMode = currentMode === "chronologue";
    const sortByWhen = isChronologueMode ? true : (_a = plugin.settings.sortByWhenDate) != null ? _a : false;
    const actsToRender = sortByWhen ? 1 : totalActs;
    for (let act = 0; act < actsToRender; act++) {
      let startAngle;
      let endAngle;
      if (sortByWhen) {
        startAngle = -Math.PI / 2;
        endAngle = 3 * Math.PI / 2;
      } else {
        startAngle = act * 2 * Math.PI / totalActs - Math.PI / 2;
        endAngle = (act + 1) * 2 * Math.PI / totalActs - Math.PI / 2;
      }
      const seenPaths = /* @__PURE__ */ new Set();
      const seenPlotKeys = /* @__PURE__ */ new Set();
      const combined = [];
      const scenesByPathForSquares = /* @__PURE__ */ new Map();
      scenes.forEach((s) => {
        var _a2;
        if (s.itemType === "Backdrop") return;
        if (!sortByWhen) {
          const sAct = s.actNumber !== void 0 ? s.actNumber - 1 : 0;
          if (sAct !== act) return;
        }
        if (isBeatNote(s)) {
          if (isChronologueMode) return;
          const pKey = `${String(s.title || "")}::${String((_a2 = s.actNumber) != null ? _a2 : "")}`;
          if (seenPlotKeys.has(pKey)) return;
          seenPlotKeys.add(pKey);
          combined.push(s);
        } else {
          const key = s.path || `${s.title || ""}::${String(s.when || "")}`;
          if (!scenesByPathForSquares.has(key)) {
            scenesByPathForSquares.set(key, []);
          }
          scenesByPathForSquares.get(key).push(s);
        }
      });
      scenesByPathForSquares.forEach((scenesForPath, pathKey) => {
        if (seenPaths.has(pathKey)) return;
        seenPaths.add(pathKey);
        const scenePath = scenesForPath[0].path;
        const resolution = resolveDominantScene({
          scenePath,
          candidateScenes: scenesForPath,
          masterSubplotOrder,
          dominantSubplots: plugin.settings.dominantSubplots
        });
        combined.push(resolution.scene);
      });
      const forceChronological = isChronologueMode;
      const sortedCombined = sortScenes(combined, sortByWhen, forceChronological);
      const positionsDetailed = computePositions(innerROuter, outerROuter, startAngle, endAngle, sortedCombined);
      const positions = /* @__PURE__ */ new Map();
      positionsDetailed.forEach((p, i) => positions.set(i, { startAngle: p.startAngle, endAngle: p.endAngle }));
      if (plugin.settings.enableAiSceneAnalysis) {
        sortedCombined.forEach((sceneItem, combinedIdx) => {
          var _a2, _b;
          if (isBeatNote(sceneItem)) return;
          const uniqueKey = sceneItem.path || `${sceneItem.title || ""}::${(_a2 = sceneItem.number) != null ? _a2 : ""}::${(_b = sceneItem.when) != null ? _b : ""}`;
          const combinedSceneId = makeSceneId(act, ringOuter, combinedIdx, true, true, uniqueKey);
          extractGradeFromScene(sceneItem, combinedSceneId, sceneGrades, plugin);
        });
      }
      svg += renderOuterRingNumberSquares({
        plugin,
        act,
        ringOuter,
        squareRadiusOuter,
        positions,
        combined: sortedCombined,
        sceneGrades,
        enableSubplotColors: shouldApplyNumberSquareColors,
        resolveSubplotVisual: numberSquareVisualResolver || void 0
      });
    }
    svg += renderInnerRingsNumberSquaresAllScenes({
      plugin,
      NUM_RINGS,
      masterSubplotOrder,
      ringStartRadii,
      ringWidths,
      scenesByActAndSubplot,
      scenes,
      sceneGrades,
      enableSubplotColors: shouldApplyNumberSquareColors,
      resolveSubplotVisual: numberSquareVisualResolver || void 0,
      numActs
    });
    svg += `</g>`;
  } else if (!shouldShowAllScenesInOuterRing(plugin)) {
    svg += renderNumberSquaresStandard({
      plugin,
      NUM_RINGS,
      masterSubplotOrder,
      ringStartRadii,
      ringWidths,
      scenesByActAndSubplot,
      scenes,
      sceneGrades,
      sceneNumbersMap,
      enableSubplotColors: shouldApplyNumberSquareColors,
      resolveSubplotVisual: numberSquareVisualResolver || void 0,
      numActs
    });
  }
  return svg;
}

// src/renderer/TimelineRenderer.ts
init_date();
init_sceneHelpers();

// src/renderer/utils/Chronologue.ts
init_sceneHelpers();
init_date();
init_svg();

// src/renderer/utils/Performance.ts
function pushPerfRecord(plugin, record) {
  const host = plugin;
  if (!host._perfMeasurements) {
    host._perfMeasurements = [];
  }
  host._perfMeasurements.push(record);
  if (host._perfMeasurements.length > 200) {
    host._perfMeasurements.shift();
  }
}
function startPerfSegment(plugin, label) {
  const canMeasure = typeof performance !== "undefined" && typeof performance.now === "function";
  const start = canMeasure ? performance.now() : Date.now();
  return () => {
    const end = canMeasure ? performance.now() : Date.now();
    const duration = end - start;
    const record = { label, duration, timestamp: Date.now() };
    pushPerfRecord(plugin, record);
  };
}

// src/renderer/utils/Chronologue.ts
init_ChronologueTimeline();

// src/renderer/components/BackdropRing.ts
init_date();
init_svg();
init_LayoutConstants();
init_sceneHelpers();
function renderBackdropRing({
  plugin,
  scenes,
  availableRadius,
  synopsesElements,
  maxTextWidth,
  masterSubplotOrder
}) {
  const backdropItems = scenes.filter((s) => s.itemType === "Backdrop" && s.when && (s.Duration || s.End));
  if (backdropItems.length === 0) return "";
  const seenPaths = /* @__PURE__ */ new Set();
  const candidates = [];
  scenes.forEach((s) => {
    if (isBeatNote(s) || s.itemType === "Backdrop") return;
    const key = s.path || `${s.title || ""}::${String(s.when || "")}`;
    if (!seenPaths.has(key)) {
      if (s.when && s.when instanceof Date && !isNaN(s.when.getTime())) {
        seenPaths.add(key);
        candidates.push(s);
      }
    }
  });
  const sortedScenes = sortScenes(candidates, true, true);
  if (sortedScenes.length === 0) return "";
  const startAngle = -Math.PI / 2;
  const endAngle = 3 * Math.PI / 2;
  const totalAngle = endAngle - startAngle;
  const angularSize = totalAngle / sortedScenes.length;
  function mapTimestampToSceneIndexAngle(timeMs, bias = "end") {
    let prevIndex = -1;
    for (let i = 0; i < sortedScenes.length; i++) {
      const sceneTime = sortedScenes[i].when.getTime();
      const condition = bias === "start" ? sceneTime < timeMs : sceneTime <= timeMs;
      if (condition) {
        prevIndex = i;
      } else {
        break;
      }
    }
    if (prevIndex === -1) {
      return startAngle;
    }
    if (prevIndex === sortedScenes.length - 1) {
      return startAngle + prevIndex * angularSize + angularSize;
    }
    const prevScene = sortedScenes[prevIndex];
    const nextScene = sortedScenes[prevIndex + 1];
    const prevTime = prevScene.when.getTime();
    const nextTime = nextScene.when.getTime();
    const segmentDuration = nextTime - prevTime;
    const progress = segmentDuration > 0 ? (timeMs - prevTime) / segmentDuration : 0;
    const prevAngle2 = startAngle + prevIndex * angularSize;
    return prevAngle2 + progress * angularSize;
  }
  const segments = backdropItems.map((item, index) => {
    const itemStart = item.when.getTime();
    let itemEnd;
    if (item.End) {
      const parsedEnd = parseWhenField(item.End);
      itemEnd = parsedEnd ? parsedEnd.getTime() : itemStart;
    } else {
      const duration = parseDuration(item.Duration) || 0;
      itemEnd = itemStart + duration;
    }
    const viewStartMs = sortedScenes[0].when.getTime();
    const viewEndMs = sortedScenes[sortedScenes.length - 1].when.getTime();
    const clampedStartMs = Math.max(itemStart, viewStartMs);
    const clampedEndMs = Math.min(itemEnd, viewEndMs);
    if (clampedStartMs >= clampedEndMs && itemStart < viewStartMs && itemEnd < viewStartMs) return null;
    if (clampedStartMs >= clampedEndMs && itemStart > viewEndMs) return null;
    let computedStartAngle = mapTimestampToSceneIndexAngle(clampedStartMs, "start");
    let computedEndAngle = mapTimestampToSceneIndexAngle(clampedEndMs, "end");
    const epsilon = 2e-3;
    const span = computedEndAngle - computedStartAngle;
    const fullCircleSpan = totalAngle - epsilon;
    if (span <= 0) {
      computedEndAngle = computedStartAngle + epsilon;
    } else if (span >= totalAngle - 1e-4) {
      computedEndAngle = computedStartAngle + fullCircleSpan;
    }
    return {
      scene: item,
      startAngle: computedStartAngle,
      endAngle: computedEndAngle
    };
  }).filter((seg) => seg !== null);
  let svg = `<g class="rt-backdrop-ring">`;
  svg += `<circle cx="0" cy="0" r="${formatNumber(availableRadius)}" class="rt-backdrop-ring-background" stroke-width="${BACKDROP_RING_HEIGHT}" pointer-events="none" fill="none" />`;
  svg += `<defs>
        <pattern id="rt-backdrop-diagonal" width="40" height="40" patternUnits="userSpaceOnUse" patternTransform="rotate(45)">
            <rect x="0" y="0" width="20" height="40" fill="var(--rt-subplot-colors-0)" fill-opacity="0.25" />
            <rect x="20" y="0" width="20" height="40" fill="var(--rt-subplot-colors-1)" fill-opacity="0.25" />
        </pattern>
    </defs>`;
  const innerBorderR = availableRadius - BACKDROP_RING_HEIGHT / 2;
  const outerBorderR = availableRadius + BACKDROP_RING_HEIGHT / 2;
  svg += `<circle cx="0" cy="0" r="${formatNumber(innerBorderR)}" class="rt-backdrop-border" fill="none" />`;
  svg += `<circle cx="0" cy="0" r="${formatNumber(outerBorderR)}" class="rt-backdrop-border" fill="none" />`;
  const events = [];
  segments.forEach((seg, idx) => {
    events.push({ angle: seg.startAngle, type: "start", idx });
    events.push({ angle: seg.endAngle, type: "end", idx });
  });
  events.sort((a, b) => a.angle === b.angle ? a.type === "end" ? -1 : 1 : a.angle - b.angle);
  const intervals = [];
  const active = [];
  let prevAngle = null;
  for (const ev of events) {
    if (prevAngle !== null && ev.angle > prevAngle && active.length > 1) {
      intervals.push({ start: prevAngle, end: ev.angle, active: [...active] });
    }
    if (ev.type === "start") {
      active.push(ev.idx);
    } else {
      const pos = active.indexOf(ev.idx);
      if (pos >= 0) active.splice(pos, 1);
    }
    prevAngle = ev.angle;
  }
  segments.forEach((seg, idx) => {
    var _a, _b;
    const largeArcFlag = seg.endAngle - seg.startAngle > Math.PI ? 1 : 0;
    const x1 = formatNumber(availableRadius * Math.cos(seg.startAngle));
    const y1 = formatNumber(availableRadius * Math.sin(seg.startAngle));
    const x2 = formatNumber(availableRadius * Math.cos(seg.endAngle));
    const y2 = formatNumber(availableRadius * Math.sin(seg.endAngle));
    const d = `M ${x1} ${y1} A ${formatNumber(availableRadius)} ${formatNumber(availableRadius)} 0 ${largeArcFlag} 1 ${x2} ${y2}`;
    const textRadius = availableRadius + BACKDROP_TITLE_RADIUS_OFFSET;
    const tx1 = formatNumber(textRadius * Math.cos(seg.startAngle));
    const ty1 = formatNumber(textRadius * Math.sin(seg.startAngle));
    const tx2 = formatNumber(textRadius * Math.cos(seg.endAngle));
    const ty2 = formatNumber(textRadius * Math.sin(seg.endAngle));
    const td = `M ${tx1} ${ty1} A ${formatNumber(textRadius)} ${formatNumber(textRadius)} 0 ${largeArcFlag} 1 ${tx2} ${ty2}`;
    const TD_COL_DY = 16;
    const pathId = `backdrop-arc-${idx}`;
    const sceneUniqueKey = seg.scene.path || `${seg.scene.title || ""}::${(_a = seg.scene.number) != null ? _a : ""}::${(_b = seg.scene.when) != null ? _b : ""}`;
    const sceneId = makeSceneId(0, 1, idx, true, true, sceneUniqueKey);
    appendSynopsisElementForScene({
      plugin,
      scene: seg.scene,
      sceneId,
      maxTextWidth,
      masterSubplotOrder,
      scenes,
      targets: synopsesElements
    });
    const encodedPath = encodeURIComponent(seg.scene.path || "");
    const currentSegmentClass = `rt-backdrop-segment`;
    const labelClass = `rt-backdrop-label`;
    svg += `<g class="rt-scene-group" data-item-type="Backdrop" data-path="${encodedPath}">`;
    svg += `<defs><path id="${pathId}" d="${td}" /></defs>`;
    const segmentHeight = BACKDROP_RING_HEIGHT - 2;
    const halfHeight2 = segmentHeight / 2;
    const boxInnerRadius = availableRadius - halfHeight2;
    const boxOuterRadius = availableRadius + halfHeight2;
    const boxLargeArcFlag = seg.endAngle - seg.startAngle > Math.PI ? 1 : 0;
    const startInnerX = formatNumber(boxInnerRadius * Math.cos(seg.startAngle));
    const startInnerY = formatNumber(boxInnerRadius * Math.sin(seg.startAngle));
    const startOuterX = formatNumber(boxOuterRadius * Math.cos(seg.startAngle));
    const startOuterY = formatNumber(boxOuterRadius * Math.sin(seg.startAngle));
    const endInnerX = formatNumber(boxInnerRadius * Math.cos(seg.endAngle));
    const endInnerY = formatNumber(boxInnerRadius * Math.sin(seg.endAngle));
    const endOuterX = formatNumber(boxOuterRadius * Math.cos(seg.endAngle));
    const endOuterY = formatNumber(boxOuterRadius * Math.sin(seg.endAngle));
    const boxPath = `M ${startOuterX} ${startOuterY} A ${formatNumber(boxOuterRadius)} ${formatNumber(boxOuterRadius)} 0 ${boxLargeArcFlag} 1 ${endOuterX} ${endOuterY} L ${endInnerX} ${endInnerY} A ${formatNumber(boxInnerRadius)} ${formatNumber(boxInnerRadius)} 0 ${boxLargeArcFlag} 0 ${startInnerX} ${startInnerY} Z`;
    svg += `<path id="${sceneId}" d="${boxPath}" class="${currentSegmentClass} rt-scene-path" pointer-events="all" data-scene-id="${sceneId}" />`;
    const title = seg.scene.title || "Untitled";
    const textPadding = 4;
    const totalArcLen = textRadius * (seg.endAngle - seg.startAngle);
    const usableArcLen = Math.max(0, totalArcLen - textPadding * 2);
    const estimatedTextWidth = title.length * 14 + 30;
    const repeatCount = Math.ceil(usableArcLen / estimatedTextWidth) + 2;
    const content = (title + " \u2022 ").repeat(repeatCount);
    svg += `<text class="${labelClass}">
            <textPath href="#${pathId}" startOffset="${textPadding}" spacing="auto" method="align">
                ${content}
            </textPath>
        </text>`;
    svg += `</g>`;
  });
  const overlayRadius = availableRadius;
  const boxHeight = BACKDROP_RING_HEIGHT - 2;
  const halfHeight = boxHeight / 2;
  const overlayInnerR = overlayRadius - halfHeight;
  const overlayOuterR = overlayRadius + halfHeight;
  const buildBoxPath = (start, end) => {
    const boxLargeArcFlag = end - start > Math.PI ? 1 : 0;
    const startInnerX = formatNumber(overlayInnerR * Math.cos(start));
    const startInnerY = formatNumber(overlayInnerR * Math.sin(start));
    const startOuterX = formatNumber(overlayOuterR * Math.cos(start));
    const startOuterY = formatNumber(overlayOuterR * Math.sin(start));
    const endInnerX = formatNumber(overlayInnerR * Math.cos(end));
    const endInnerY = formatNumber(overlayInnerR * Math.sin(end));
    const endOuterX = formatNumber(overlayOuterR * Math.cos(end));
    const endOuterY = formatNumber(overlayOuterR * Math.sin(end));
    return `M ${startOuterX} ${startOuterY} A ${formatNumber(overlayOuterR)} ${formatNumber(overlayOuterR)} 0 ${boxLargeArcFlag} 1 ${endOuterX} ${endOuterY} L ${endInnerX} ${endInnerY} A ${formatNumber(overlayInnerR)} ${formatNumber(overlayInnerR)} 0 ${boxLargeArcFlag} 0 ${startInnerX} ${startInnerY} Z`;
  };
  const overlayPaths = [];
  intervals.forEach((interval) => {
    const { start, end, active: activeSegments } = interval;
    activeSegments.forEach((segIdx, depth) => {
      const hueClass = `rt-backdrop-hue-${depth % 8}`;
      const parityClass = depth % 2 === 0 ? "rt-backdrop-overlap-even" : "rt-backdrop-overlap-odd";
      const overlayClass = `rt-backdrop-segment rt-backdrop-overlap ${parityClass} ${hueClass}`;
      const path = buildBoxPath(start, end);
      overlayPaths.push(`<path d="${path}" class="${overlayClass}" pointer-events="none" />`);
    });
  });
  overlayPaths.forEach((p) => {
    svg += p;
  });
  svg += `</g>`;
  return svg;
}

// src/renderer/utils/Chronologue.ts
function buildChronologueOuterLabels(plugin, scenes) {
  const stopChronoLabels = startPerfSegment(plugin, "timeline.chronologue-labels");
  const startAngle = -Math.PI / 2;
  const endAngle = 3 * Math.PI / 2;
  const seenPaths = /* @__PURE__ */ new Set();
  const combined = [];
  scenes.forEach((s) => {
    if (isBeatNote(s) || s.itemType === "Backdrop") {
      return;
    }
    const key = s.path || `${s.title || ""}::${String(s.when || "")}`;
    if (!seenPaths.has(key)) {
      seenPaths.add(key);
      combined.push(s);
    }
  });
  const sortByWhen = true;
  const forceChronological = true;
  const sortedScenes = sortScenes(combined, sortByWhen, forceChronological);
  const validDates = sortedScenes.map((s) => s.when).filter((when) => when instanceof Date && !isNaN(when.getTime()));
  const timeSpan = validDates.length > 0 ? calculateTimeSpan(validDates) : void 0;
  const sceneStartAngles = [];
  let sceneAngularSize = 0;
  if (sortedScenes.length > 0) {
    const totalAngularSpace = endAngle - startAngle;
    sceneAngularSize = totalAngularSpace / sortedScenes.length;
    sortedScenes.forEach((_, idx) => {
      const sceneStartAngle = startAngle + idx * sceneAngularSize;
      sceneStartAngles.push(sceneStartAngle);
    });
  }
  const chronoTicks = generateChronologicalTicks(sortedScenes, sceneStartAngles, sceneAngularSize, timeSpan);
  const outerLabels = chronoTicks.map((tick) => ({
    name: tick.name,
    shortName: tick.shortName,
    angle: tick.angle,
    isMajor: tick.isMajor,
    isFirst: tick.isFirst,
    isLast: tick.isLast,
    sceneIndex: tick.sceneIndex,
    earthDate: tick.earthDate
  }));
  stopChronoLabels();
  return outerLabels;
}
function renderChronologueOverlays({
  plugin,
  scenes,
  subplotOuterRadius,
  manuscriptOrderPositions,
  ringStartRadii,
  ringWidths,
  masterSubplotOrder = [],
  chronologueSceneEntries,
  durationArcRadius = 0,
  synopsesElements = [],
  maxTextWidth = 0
}) {
  const stopChronoOverlays = startPerfSegment(plugin, "timeline.chronologue-overlays");
  let svg = "";
  const durationCapMs = durationSelectionToMs(plugin.settings.chronologueDurationCapSelection);
  const chronologueTimelineArc = renderChronologueTimelineArc(
    scenes,
    subplotOuterRadius,
    manuscriptOrderPositions,
    durationCapMs,
    durationArcRadius,
    chronologueSceneEntries
  );
  if (chronologueTimelineArc) {
    svg += chronologueTimelineArc;
  }
  const outerRingIndex = ringStartRadii.length - 1;
  const outerRingInnerR = ringStartRadii[outerRingIndex];
  const outerRingOuterR = outerRingInnerR + ringWidths[outerRingIndex];
  let customThresholdMs = void 0;
  if (plugin.settings.discontinuityThreshold) {
    const parsed = parseDurationDetail(plugin.settings.discontinuityThreshold);
    if (parsed) {
      customThresholdMs = parsed.ms;
    }
  }
  svg += renderChronologicalBackboneArc(
    scenes,
    outerRingInnerR,
    outerRingOuterR,
    3,
    manuscriptOrderPositions,
    chronologueSceneEntries,
    customThresholdMs
  );
  const backdropSubplotIndex = masterSubplotOrder.indexOf("Backdrop");
  if (backdropSubplotIndex !== -1) {
    const numRings = ringStartRadii.length;
    const ringIndex = numRings - 1 - backdropSubplotIndex;
    if (ringIndex >= 0 && ringIndex < numRings) {
      const backdropRadius = ringStartRadii[ringIndex] + ringWidths[ringIndex] / 2;
      svg += renderBackdropRing({
        plugin,
        scenes,
        availableRadius: backdropRadius,
        synopsesElements,
        maxTextWidth,
        masterSubplotOrder
      });
    }
  }
  stopChronoOverlays();
  return svg;
}
function renderOuterLabelTexts({
  outerLabels,
  isChronologueMode,
  currentMonthIndex
}) {
  let labelsSvg = "";
  let boundaryLabelsHtml = "";
  outerLabels.forEach(({ shortName, isFirst, isLast, earthDate }, index) => {
    const pathId = `monthLabelPath-${index}`;
    const isPastMonth = !isChronologueMode && index < currentMonthIndex;
    let labelClass = "rt-month-label-outer";
    if (isFirst) {
      labelClass = "rt-month-label-outer rt-date-boundary rt-date-first";
    } else if (isLast) {
      labelClass = "rt-month-label-outer rt-date-boundary rt-date-last";
    }
    let labelContent = shortName;
    if ((isFirst || isLast) && shortName.includes("\n")) {
      const lines = shortName.split("\n");
      labelContent = lines.map((line, i) => `<tspan x="0" dy="${i === 0 ? 0 : "0.9em"}">${line}</tspan>`).join("");
    }
    const earthDateAttr = earthDate ? ` data-earth-date="${earthDate}"` : "";
    const labelHtml = `
            <text class="${labelClass}"${earthDateAttr} ${isPastMonth ? 'opacity="0.5"' : ""}>
                <textPath href="#${pathId}" startOffset="0" text-anchor="start">
                    ${labelContent}
                </textPath>
            </text>
        `;
    if (isChronologueMode && (isFirst || isLast)) {
      boundaryLabelsHtml += labelHtml;
    } else {
      labelsSvg += labelHtml;
    }
  });
  return { labelsSvg, boundaryLabelsHtml };
}
function renderChronologueOuterTicks({
  outerLabels,
  monthTickStart,
  monthTickEnd
}) {
  if (!outerLabels.length) {
    return "";
  }
  let svg = '<g class="rt-chronological-outer-ticks">';
  outerLabels.forEach(({ angle, isMajor, shortName, isFirst, isLast, sceneIndex }) => {
    const tickStart = monthTickStart;
    const dataAttrs = sceneIndex !== void 0 ? ` data-scene-index="${sceneIndex}"` : "";
    if (isMajor) {
      const tickEnd = monthTickEnd;
      const x1 = formatNumber(tickStart * Math.cos(angle));
      const y1 = formatNumber(tickStart * Math.sin(angle));
      const x2 = formatNumber(tickEnd * Math.cos(angle));
      const y2 = formatNumber(tickEnd * Math.sin(angle));
      const boundaryClass = isFirst ? " rt-date-first" : isLast ? " rt-date-last" : "";
      svg += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" 
                class="rt-chronological-tick rt-chronological-tick-major${boundaryClass}"${dataAttrs}/>`;
    } else if (shortName === "") {
      const tickEnd = (monthTickStart + monthTickEnd) / 2;
      const x1 = formatNumber(tickStart * Math.cos(angle));
      const y1 = formatNumber(tickStart * Math.sin(angle));
      const x2 = formatNumber(tickEnd * Math.cos(angle));
      const y2 = formatNumber(tickEnd * Math.sin(angle));
      svg += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" 
                class="rt-chronological-tick rt-chronological-tick-minor"${dataAttrs}/>`;
    }
  });
  svg += "</g>";
  return svg;
}

// src/renderer/utils/Precompute.ts
init_sceneHelpers();
init_LayoutConstants();

// src/renderer/layout/Rings.ts
function computeRingGeometry(params) {
  const { size, innerRadius, subplotOuterRadius, outerRadius, numRings, monthTickTerminal, monthTextInset, fixedRingIndex, fixedRingWidth } = params;
  if (!Number.isFinite(numRings) || numRings <= 0) {
    const lineInnerRadius2 = innerRadius;
    const lineOuterRadius2 = outerRadius;
    const monthLabelRadius2 = lineOuterRadius2 - monthTextInset;
    return { ringWidths: [], ringStartRadii: [], lineInnerRadius: lineInnerRadius2, lineOuterRadius: lineOuterRadius2, monthLabelRadius: monthLabelRadius2 };
  }
  const availableSpace = subplotOuterRadius - innerRadius;
  let ringWidths = [];
  if (fixedRingIndex !== void 0 && fixedRingWidth !== void 0 && numRings > 1) {
    const remainingSpace = availableSpace - fixedRingWidth;
    const standardWidth = remainingSpace / (numRings - 1);
    ringWidths = Array.from({ length: numRings }, (_, i) => i === fixedRingIndex ? fixedRingWidth : standardWidth);
  } else {
    const reductionFactor = 1;
    const sumOfSeries = reductionFactor === 1 ? numRings : (1 - Math.pow(reductionFactor, numRings)) / (1 - reductionFactor);
    const initialRingWidth = availableSpace / sumOfSeries;
    ringWidths = Array.from({ length: numRings }, (_, i) => initialRingWidth * Math.pow(reductionFactor, i));
  }
  const ringStartRadii = ringWidths.reduce((acc, width, i) => {
    const previousRadius = i === 0 ? innerRadius : acc[i - 1] + ringWidths[i - 1];
    acc.push(previousRadius);
    return acc;
  }, []);
  const lineInnerRadius = ringStartRadii[0] - 20;
  const lineOuterRadius = outerRadius;
  const monthLabelRadius = lineOuterRadius - monthTextInset;
  return { ringWidths, ringStartRadii, lineInnerRadius, lineOuterRadius, monthLabelRadius };
}

// src/renderer/utils/Precompute.ts
var BACKDROP_RING_HEIGHT2 = 20;
function computeCacheableValues(plugin, scenes) {
  var _a;
  const stopPrecompute = startPerfSegment(plugin, "timeline.precompute");
  const currentMode = plugin.settings.currentMode || "narrative";
  const isChronologueMode = currentMode === "chronologue";
  const isSubplotMode = currentMode === "subplot";
  const readabilityScale = getReadabilityScale(plugin.settings);
  const sortByWhen = isChronologueMode ? true : (_a = plugin.settings.sortByWhenDate) != null ? _a : false;
  const forceChronological = isChronologueMode;
  const allSubplotsSet = /* @__PURE__ */ new Set();
  let hasBackdrops = false;
  scenes.forEach((scene) => {
    if (scene.itemType === "Backdrop") {
      hasBackdrops = true;
      return;
    }
    const key = scene.subplot && scene.subplot.trim().length > 0 ? scene.subplot : "Main Plot";
    allSubplotsSet.add(key);
  });
  const allSubplots = Array.from(allSubplotsSet);
  if (isChronologueMode && hasBackdrops) {
    allSubplots.push("Backdrop");
  }
  const NUM_RINGS = allSubplots.length;
  const shouldShowBeats = shouldRenderStoryBeats(plugin);
  const allScenesPlotNotes = shouldShowBeats ? scenes.filter((s) => isBeatNote(s)) : [];
  const totalPlotNotes = allScenesPlotNotes.length;
  const plotIndexByKey = /* @__PURE__ */ new Map();
  allScenesPlotNotes.forEach((p, i) => {
    var _a2;
    return plotIndexByKey.set(`${String(p.title || "")}::${String((_a2 = p.actNumber) != null ? _a2 : "")}`, i);
  });
  const plotsBySubplot = /* @__PURE__ */ new Map();
  allScenesPlotNotes.forEach((p) => {
    const key = String(p.subplot || "");
    const arr = plotsBySubplot.get(key) || [];
    arr.push(p);
    plotsBySubplot.set(key, arr);
  });
  const scenesByActAndSubplot = {};
  if (sortByWhen) {
    scenesByActAndSubplot[0] = {};
    scenes.forEach((scene) => {
      if (scene.itemType === "Backdrop") return;
      const subplot = scene.subplot && scene.subplot.trim().length > 0 ? scene.subplot : "Main Plot";
      if (!scenesByActAndSubplot[0][subplot]) {
        scenesByActAndSubplot[0][subplot] = [];
      }
      scenesByActAndSubplot[0][subplot].push(scene);
    });
    Object.keys(scenesByActAndSubplot[0]).forEach((subplot) => {
      scenesByActAndSubplot[0][subplot] = sortScenes(scenesByActAndSubplot[0][subplot], true, forceChronological);
    });
  } else {
    const numActs = getConfiguredActCount(plugin.settings);
    for (let act = 0; act < numActs; act++) {
      scenesByActAndSubplot[act] = {};
    }
    scenes.forEach((scene) => {
      if (scene.itemType === "Backdrop") return;
      const act = scene.actNumber !== void 0 ? scene.actNumber - 1 : 0;
      const validAct = act >= 0 && act < numActs ? act : 0;
      const subplot = scene.subplot && scene.subplot.trim().length > 0 ? scene.subplot : "Main Plot";
      if (!scenesByActAndSubplot[validAct][subplot]) {
        scenesByActAndSubplot[validAct][subplot] = [];
      }
      scenesByActAndSubplot[validAct][subplot].push(scene);
    });
    for (let act = 0; act < numActs; act++) {
      Object.keys(scenesByActAndSubplot[act] || {}).forEach((subplot) => {
        scenesByActAndSubplot[act][subplot] = sortScenes(scenesByActAndSubplot[act][subplot], false, false);
      });
    }
  }
  const allSubplotsMap = /* @__PURE__ */ new Map();
  const actsToCheck = sortByWhen ? 1 : getConfiguredActCount(plugin.settings);
  for (let actIndex = 0; actIndex < actsToCheck; actIndex++) {
    Object.entries(scenesByActAndSubplot[actIndex] || {}).forEach(([subplot, scenes2]) => {
      allSubplotsMap.set(subplot, (allSubplotsMap.get(subplot) || 0) + scenes2.length);
    });
  }
  const subplotCounts = Array.from(allSubplotsMap.entries()).map(([subplot, count]) => ({
    subplot,
    count
  }));
  subplotCounts.sort((a, b) => {
    if (a.subplot === "Main Plot" || !a.subplot) return -1;
    if (b.subplot === "Main Plot" || !b.subplot) return 1;
    if (a.count !== b.count) return b.count - a.count;
    return a.subplot.localeCompare(b.subplot);
  });
  const baseSubplotOrder = subplotCounts.map((item) => item.subplot);
  const colorIndexBySubplot = /* @__PURE__ */ new Map();
  baseSubplotOrder.forEach((subplot, idx) => {
    colorIndexBySubplot.set(subplot, idx % 16);
  });
  let masterSubplotOrder = [...baseSubplotOrder];
  if (isChronologueMode && hasBackdrops) {
    masterSubplotOrder = masterSubplotOrder.filter((s) => s !== "Backdrop");
    if (masterSubplotOrder.length > 0) {
      masterSubplotOrder.splice(1, 0, "Backdrop");
    } else {
      masterSubplotOrder.push("Backdrop");
    }
  }
  const subplotDominanceStates = computeSubplotDominanceStates({
    scenes,
    masterSubplotOrder,
    dominantSubplots: plugin.settings.dominantSubplots
  });
  const subplotOuterRadius = isChronologueMode ? SUBPLOT_OUTER_RADIUS_CHRONOLOGUE : isSubplotMode ? SUBPLOT_OUTER_RADIUS_MAINPLOT : SUBPLOT_OUTER_RADIUS_STANDARD[readabilityScale];
  const backdropSubplotIndex = masterSubplotOrder.indexOf("Backdrop");
  let fixedRingIndex;
  if (isChronologueMode && backdropSubplotIndex !== -1) {
    fixedRingIndex = NUM_RINGS - 1 - backdropSubplotIndex;
  }
  const ringGeo = computeRingGeometry({
    size: SVG_SIZE,
    innerRadius: INNER_RADIUS,
    subplotOuterRadius,
    outerRadius: MONTH_LABEL_RADIUS,
    numRings: NUM_RINGS,
    monthTickTerminal: 0,
    monthTextInset: 0,
    fixedRingIndex,
    fixedRingWidth: isChronologueMode ? BACKDROP_RING_HEIGHT2 : void 0
  });
  const maxStageColor = getMostAdvancedStageColor(scenes, plugin.settings.publishStageColors);
  stopPrecompute();
  return {
    scenesByActAndSubplot,
    masterSubplotOrder,
    colorIndexBySubplot,
    totalPlotNotes,
    plotIndexByKey,
    plotsBySubplot,
    ringWidths: ringGeo.ringWidths,
    ringStartRadii: ringGeo.ringStartRadii,
    lineInnerRadius: ringGeo.lineInnerRadius,
    maxStageColor,
    subplotDominanceStates
  };
}

// src/renderer/TimelineRenderer.ts
init_LayoutConstants();

// src/renderer/components/Grid.ts
function renderCenterGrid(params) {
  const {
    statusesForGrid,
    stagesForGrid,
    gridCounts,
    PUBLISH_STAGE_COLORS,
    currentYearLabel,
    estimatedTotalScenes,
    startXGrid,
    startYGrid,
    cellWidth,
    cellHeight,
    cellGapX,
    cellGapY,
    headerY
  } = params;
  const gridWidth = statusesForGrid.length * cellWidth + (statusesForGrid.length - 1) * cellGapX;
  const gridHeight = stagesForGrid.length * cellHeight + (stagesForGrid.length - 1) * cellGapY;
  const isStageCompleteForGridRow = (rowIndex, gridCountsIn, stages) => {
    const stage = stages[rowIndex];
    const rc = gridCountsIn[stage];
    const rowTotal = (rc.Todo || 0) + (rc.Working || 0) + (rc.Due || 0) + (rc.Completed || 0);
    const maxStageIdxForGrid = stages.reduce((acc, s, idx) => {
      const counts = gridCountsIn[s];
      const total = (counts.Todo || 0) + (counts.Working || 0) + (counts.Due || 0) + (counts.Completed || 0);
      return total > 0 ? Math.max(acc, idx) : acc;
    }, -1);
    if (rowTotal === 0 && maxStageIdxForGrid > rowIndex) {
      return true;
    }
    if (rowIndex === maxStageIdxForGrid) {
      const completed = rc.Completed || 0;
      const incomplete = (rc.Todo || 0) + (rc.Working || 0) + (rc.Due || 0);
      const thisStageComplete = completed > 0 && incomplete === 0;
      if (!thisStageComplete) return false;
      for (let i = 0; i < rowIndex; i++) {
        const prevStage = stages[i];
        const prevCounts = gridCountsIn[prevStage];
        const prevTotal = (prevCounts.Todo || 0) + (prevCounts.Working || 0) + (prevCounts.Due || 0) + (prevCounts.Completed || 0);
        const prevIncomplete = (prevCounts.Todo || 0) + (prevCounts.Working || 0) + (prevCounts.Due || 0);
        if (prevTotal > 0 && prevIncomplete > 0) {
          return false;
        }
      }
      return true;
    }
    return false;
  };
  const renderGridCell = (stage, status, x, y, count) => {
    let fillAttr = "";
    if (status === "Completed") {
      const solid = PUBLISH_STAGE_COLORS[stage] || "#888888";
      fillAttr = `fill="${solid}"`;
    } else if (status === "Working") {
      fillAttr = `fill="url(#plaidWorking${stage})"`;
    } else if (status === "Todo") {
      fillAttr = `fill="url(#plaidTodo${stage})"`;
    } else if (status === "Due") {
      fillAttr = `fill="var(--rt-color-due)"`;
    } else {
      fillAttr = `fill="#888888"`;
    }
    const cellOpacity = count <= 0 ? 0.1 : 1;
    const tooltipText = count > 0 ? `${stage} \u2022 ${status}: ${count}` : "";
    return `
      <g transform="translate(${x}, ${y})" ${tooltipText ? `class="rt-tooltip-target rt-grid-cell" data-tooltip="${tooltipText}" data-tooltip-placement="bottom"` : ""}>
        <rect x="0" y="0" width="${cellWidth}" height="${cellHeight}" ${fillAttr} fill-opacity="${cellOpacity}" pointer-events="all" />
        ${status === "Completed" && count > 0 ? `<text x="2" y="${cellHeight - 3}" text-anchor="start" dominant-baseline="alphabetic" class="grid-completed-count">${count}</text>` : ""}
      </g>
    `;
  };
  const header = `
    <g class="color-key-center">
      ${statusesForGrid.map((status, c) => {
    const label = status === "Todo" ? "Tdo" : status === "Working" ? "Wrk" : status === "Completed" ? "Cmt" : "Due";
    const x = startXGrid + c * (cellWidth + cellGapX) + cellWidth / 2;
    const y = headerY;
    const tip = params.statusTooltips[status] || status;
    return `
          <g class="status-header rt-tooltip-target" data-tooltip="${tip}" data-tooltip-placement="bottom">
            <text x="${x}" y="${y}" text-anchor="middle" dominant-baseline="alphabetic" class="center-key-text status-header-letter">${label}</text>
            <rect x="${x - 18}" y="${y - 18}" width="36" height="24" fill="transparent" pointer-events="all" />
          </g>
        `;
  }).join("")}
      <text x="${startXGrid + gridWidth}" y="${startYGrid + gridHeight + (cellGapY + 16)}" text-anchor="end" dominant-baseline="alphabetic" class="center-key-text">${currentYearLabel}//${estimatedTotalScenes}</text>
    `;
  const isBookComplete = (() => {
    const mostAdvancedStageIdx = stagesForGrid.reduce((acc, s, idx) => {
      const counts = gridCounts[s];
      const total = (counts.Todo || 0) + (counts.Working || 0) + (counts.Due || 0) + (counts.Completed || 0);
      return total > 0 ? Math.max(acc, idx) : acc;
    }, -1);
    if (mostAdvancedStageIdx === -1) return false;
    const finalStage = stagesForGrid[mostAdvancedStageIdx];
    if (finalStage !== "Press") return false;
    const pressCounts = gridCounts["Press"];
    const pressCompleted = pressCounts.Completed || 0;
    const pressIncomplete = (pressCounts.Todo || 0) + (pressCounts.Working || 0) + (pressCounts.Due || 0);
    return pressCompleted > 0 && pressIncomplete === 0;
  })();
  const rows = stagesForGrid.map((stage, r) => {
    const xh = startXGrid - 12;
    const yh = startYGrid + r * (cellHeight + cellGapY) + (cellHeight / 2 + 1);
    const stageTip = params.stageTooltips[stage] || stage;
    const stageHeader = `
      <g class="stage-header rt-tooltip-target" data-tooltip="${stageTip}" data-tooltip-placement="right">
        <text x="${xh}" y="${yh}" text-anchor="end" dominant-baseline="middle" class="center-key-text stage-header-letter">${stage === "Zero" ? "Z" : stage === "Author" ? "A" : stage === "House" ? "H" : "P"}</text>
        <rect x="${xh - 14}" y="${yh - 14}" width="28" height="28" fill="transparent" pointer-events="all" />
      </g>
    `;
    const cells = statusesForGrid.map((status, c) => {
      const count = gridCounts[stage][status] || 0;
      const x = startXGrid + c * (cellWidth + cellGapX);
      const y = startYGrid + r * (cellHeight + cellGapY);
      const completeRow = isStageCompleteForGridRow(r, gridCounts, stagesForGrid);
      if (completeRow) {
        const mostAdvancedStageIdx = stagesForGrid.reduce((acc, s, idx) => {
          const counts = gridCounts[s];
          const total = (counts.Todo || 0) + (counts.Working || 0) + (counts.Due || 0) + (counts.Completed || 0);
          return total > 0 ? Math.max(acc, idx) : acc;
        }, -1);
        const mostStage = stagesForGrid[Math.max(0, mostAdvancedStageIdx)];
        const solid = PUBLISH_STAGE_COLORS[mostStage] || "#888888";
        const iconId = isBookComplete ? "icon-smile" : "icon-bookmark-check";
        const completedTooltip = isBookComplete ? "Book Complete! \u{1F389}" : `${stage} stage complete`;
        return `
          <g transform="translate(${x}, ${y})" class="rt-tooltip-target rt-grid-cell-complete" data-tooltip="${completedTooltip}" data-tooltip-placement="bottom">
            <rect x="0" y="0" width="${cellWidth}" height="${cellHeight}" fill="${solid}" pointer-events="all" />
            <use href="#${iconId}" x="${(cellWidth - 18) / 2}" y="${(cellHeight - 18) / 2}" width="18" height="18" class="completed-icon" />
          </g>
        `;
      }
      return renderGridCell(stage, status, x, y, count);
    }).join("");
    return `${stageHeader}${cells}`;
  }).join("");
  const arrows = (() => {
    const maxStageIdxForGrid = stagesForGrid.reduce((acc, s, idx) => {
      const counts = gridCounts[s];
      const total = (counts.Todo || 0) + (counts.Working || 0) + (counts.Due || 0) + (counts.Completed || 0);
      return total > 0 ? Math.max(acc, idx) : acc;
    }, -1);
    if (maxStageIdxForGrid === -1) return "";
    return stagesForGrid.map((stage, r) => {
      let arrowId = "";
      if (r === maxStageIdxForGrid) arrowId = "icon-arrow-right-dash";
      else if (r < maxStageIdxForGrid) arrowId = "icon-arrow-down";
      else return "";
      const ax = startXGrid + gridWidth + 4;
      const ay = startYGrid + r * (cellHeight + cellGapY) + cellHeight / 2;
      return `<use href="#${arrowId}" x="${ax}" y="${ay - 12}" width="24" height="24" class="rt-grid-arrow" />`;
    }).join("");
  })();
  return `${header}${rows}${arrows}</g>`;
}

// src/renderer/layout/Paths.ts
init_svg();
function arcPath(radius, startAngle, endAngle) {
  return `
    M ${formatNumber(radius * Math.cos(startAngle))} ${formatNumber(radius * Math.sin(startAngle))}
    A ${formatNumber(radius)} ${formatNumber(radius)} 0 0 1 ${formatNumber(radius * Math.cos(endAngle))} ${formatNumber(radius * Math.sin(endAngle))}
  `;
}

// src/renderer/components/Months.ts
function renderMonthLabelDefs(params) {
  const { months, monthLabelRadius, chronologueDateRadius } = params;
  return months.map(({ angle, isFirst, isLast }, index) => {
    const angleOffset = 0.01;
    const startAngle = angle + angleOffset;
    const arcLength = isFirst || isLast ? Math.PI / 4 : Math.PI / 6;
    const endAngle = startAngle + arcLength;
    const pathId = `monthLabelPath-${index}`;
    let radius = isFirst || isLast ? chronologueDateRadius : monthLabelRadius;
    return `
      <path id="${pathId}" d="${arcPath(radius, startAngle, endAngle)}" fill="none" />
    `;
  }).join("");
}

// src/renderer/components/SubplotLabels.ts
init_svg();
function renderSubplotLabels(params) {
  const { NUM_RINGS, ringStartRadii, ringWidths, masterSubplotOrder, plugin } = params;
  const totalRings = NUM_RINGS;
  const subplotCount = masterSubplotOrder.length;
  const ringsToUse = Math.min(subplotCount, totalRings);
  let svg = "";
  const act = 3;
  for (let ringOffset = 0; ringOffset < ringsToUse; ringOffset++) {
    const ring = totalRings - ringOffset - 1;
    const subplot = masterSubplotOrder[ringOffset];
    if (!subplot || subplot === "Backdrop") continue;
    const innerR = ringStartRadii[ring];
    const outerR = innerR + ringWidths[ring];
    const labelPathId = `subplot-label-path-${ring}`;
    const labelRadius = (innerR + outerR) / 2;
    const availableHeight = ringWidths[ring];
    const fontSize = Math.floor(availableHeight * 0.95);
    const arcLength = Math.PI / 2;
    const endAngle = -Math.PI / 2;
    const startAngle = endAngle - arcLength;
    const arcPixelLength = labelRadius * arcLength;
    const d = `M ${formatNumber(labelRadius * Math.cos(startAngle))} ${formatNumber(labelRadius * Math.sin(startAngle))} A ${formatNumber(labelRadius)} ${formatNumber(labelRadius)} 0 0 1 ${formatNumber(labelRadius * Math.cos(endAngle))} ${formatNumber(labelRadius * Math.sin(endAngle))}`;
    const isOuterRing = ringOffset === 0;
    const labelRaw = getSubplotLabelText(plugin, subplot, isOuterRing);
    svg += `
      <path id="${labelPathId}" d="${d}" fill="none" />
      <g class="subplot-label-group" data-font-size="${fontSize}">
        <text class="rt-subplot-ring-label-text" data-subplot-index="${ringOffset}" data-subplot-name="${escapeXml(subplot)}" text-anchor="end">
          <textPath href="#${labelPathId}" startOffset="100%" textLength="${formatNumber(arcPixelLength)}" lengthAdjust="spacingAndGlyphs">${escapeXml(labelRaw)}</textPath>
        </text>
      </g>
    `;
  }
  return svg;
}

// src/renderer/components/Defs.ts
function renderDefs(PUBLISH_STAGE_COLORS) {
  const plaid = Object.entries(PUBLISH_STAGE_COLORS).map(([stage, color]) => {
    return `
      <pattern id="plaidWorking${stage}" patternUnits="userSpaceOnUse" width="80" height="20" patternTransform="rotate(-20)">
        <rect width="80" height="20" fill="var(--rt-color-working)" opacity="var(--rt-color-plaid-opacity)"/>
        <path d="M 0 10 Q 2.5 -5, 5 10 Q 7.5 25, 10 10 Q 12.5 5, 15 10 Q 17.5 25, 20 10 Q 22.5 -5, 25 10 Q 27.5 25, 30 10 Q 32.5 5, 35 10 Q 37.5 25, 40 10 Q 42.5 -5, 45 10 Q 47.5 25, 50 10 Q 52.5 5, 55 10 Q 57.5 25, 60 10 Q 62.5 -5, 65 10 Q 67.5 25, 70 10 Q 72.5 5, 75 10 Q 77.5 25, 80 10" 
          stroke="${color}" stroke-opacity="var(--rt-color-plaid-stroke-opacity)" stroke-width="1.5" fill="none" />
      </pattern>

      <pattern id="plaidTodo${stage}" patternUnits="userSpaceOnUse" width="10" height="10" patternTransform="rotate(45)">
        <rect width="10" height="10" fill="var(--rt-color-todo)" opacity="var(--rt-color-plaid-opacity)"/>
        <line x1="0" y1="0" x2="0" y2="10" stroke="${color}" stroke-width="1.5" stroke-opacity="0.5"/>
        <line x1="0" y1="0" x2="10" y2="0" stroke="${color}" stroke-width="1.5" stroke-opacity="0.5"/>
      </pattern>
    `;
  }).join("");
  const icons = `
    <symbol id="icon-circle-slash" viewBox="0 0 24 24">
      <circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <line x1="9" x2="15" y1="15" y2="9" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
    </symbol>
    <symbol id="icon-smile" viewBox="0 0 24 24">
      <circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" />
      <path d="M8 14s1.5 2 4 2 4-2 4-2" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" />
      <line x1="9" x2="9.01" y1="9" y2="9" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" />
      <line x1="15" x2="15.01" y1="9" y2="9" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" />
    </symbol>
    <symbol id="icon-house" viewBox="0 0 24 24">
      <path d="M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <path d="M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
    </symbol>
    <symbol id="icon-printer" viewBox="0 0 24 24">
      <path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <path d="M6 9V3a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <rect x="6" y="14" width="12" height="8" rx="1" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
    </symbol>
    <symbol id="icon-arrow-right-dash" viewBox="0 0 24 24">
      <path d="M11 9a1 1 0 0 0 1-1V5.061a1 1 0 0 1 1.811-.75l6.836 6.836a1.207 1.207 0 0 1 0 1.707l-6.836 6.835a1 1 0 0 1-1.811-.75V16a1 1 0 0 0-1-1H9a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1z" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M4 9v6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </symbol>
    <symbol id="icon-arrow-down" viewBox="0 0 24 24">
      <path d="M15 11a1 1 0 0 0 1 1h2.939a1 1 0 0 1 .75 1.811l-6.835 6.836a1.207 1.207 0 0 1-1.707 0L4.31 13.81a1 1 0 0 1 .75-1.811H8a1 1 0 0 0 1-1V5a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1z" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </symbol>
    <symbol id="icon-bookmark-check" viewBox="0 0 24 24">
      <path d="m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2Z" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="m9 10 2 2 4-4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </symbol>
    <!-- Arrow Up/Down From Line (toggle rotation) -->
    <symbol id="icon-arrow-up-from-line" viewBox="0 0 24 24">
      <path d="m18 9-6-6-6 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <path d="M12 3v14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <path d="M5 21h14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
    </symbol>
    <symbol id="icon-arrow-down-from-line" viewBox="0 0 24 24">
      <path d="M19 3H5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <path d="M12 21V7" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <path d="m6 15 6 6 6-6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
    </symbol>
  `;
  const filters = `
    <filter id="beatTextBg" x="-25%" y="-25%" width="150%" height="150%">
      <feMorphology in="SourceAlpha" operator="dilate" radius="1.8" result="DILATE"/>
      <feFlood flood-color="#000000" result="BLACK"/>
      <feComposite in="BLACK" in2="DILATE" operator="in" result="BG"/>
      <feMerge>
        <feMergeNode in="BG"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
    <filter id="sceneTitleHalo" x="-20%" y="-20%" width="140%" height="140%">
      <feMorphology in="SourceAlpha" operator="dilate" radius="1.2" result="expanded"/>
      <feGaussianBlur in="expanded" stdDeviation="0.8" result="blurred"/>
      <feFlood flood-color="#000000" flood-opacity="0.85" result="haloColor"/>
      <feComposite in="haloColor" in2="blurred" operator="in" result="halo"/>
      <feMerge>
        <feMergeNode in="halo"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
  `;
  return plaid + icons + filters;
}
function renderProgressRingGradients() {
  return `
    <defs>
      <linearGradient id="linearColors1" x1="0" y1="0" x2="1" y2="1">
        <stop offset="0%" stop-color="#FF0000"></stop>
        <stop offset="100%" stop-color="#FF7F00"></stop>
      </linearGradient>
      <linearGradient id="linearColors2" x1="0.5" y1="0" x2="0.5" y2="1">
        <stop offset="0%" stop-color="#FF7F00"></stop>
        <stop offset="100%" stop-color="#FFFF00"></stop>
      </linearGradient>
      <linearGradient id="linearColors3" x1="1" y1="0" x2="0" y2="1">
        <stop offset="0%" stop-color="#FFFF00"></stop>
        <stop offset="100%" stop-color="#00FF00"></stop>
      </linearGradient>
      <linearGradient id="linearColors4" x1="1" y1="1" x2="0" y2="0">
        <stop offset="0%" stop-color="#00FF00"></stop>
        <stop offset="100%" stop-color="#0000FF"></stop>
      </linearGradient>
      <linearGradient id="linearColors5" x1="0.5" y1="1" x2="0.5" y2="0">
        <stop offset="0%" stop-color="#0000FF"></stop>
        <stop offset="100%" stop-color="#4B0082"></stop>
      </linearGradient>
      <linearGradient id="linearColors6" x1="0" y1="1" x2="1" y2="0">
        <stop offset="0%" stop-color="#4B0082"></stop>
        <stop offset="100%" stop-color="#8F00FF"></stop>
      </linearGradient>
    </defs>`;
}

// src/renderer/components/Acts.ts
init_svg();
function renderActBorders(params) {
  const { numActs, innerRadius, outerRadius } = params;
  let svg = "";
  for (let act = 0; act < numActs; act++) {
    const angle = act * 2 * Math.PI / numActs - Math.PI / 2;
    svg += `
      <line x1="${formatNumber(innerRadius * Math.cos(angle))}" y1="${formatNumber(innerRadius * Math.sin(angle))}"
            x2="${formatNumber(outerRadius * Math.cos(angle))}" y2="${formatNumber(outerRadius * Math.sin(angle))}"
            class="act-border" />
    `;
  }
  return svg;
}

// src/renderer/components/ActLabels.ts
init_svg();
function renderActLabels(params) {
  const { numActs, actLabels, showActLabels, outerMostOuterRadius, actLabelOffset, maxStageColor } = params;
  let svg = "";
  const actLabelRadius = outerMostOuterRadius + actLabelOffset;
  for (let act = 0; act < numActs; act++) {
    const angle = act * 2 * Math.PI / numActs - Math.PI / 2;
    const anchorOffset = 0.02;
    const endAngleAct = angle - anchorOffset;
    const startAngleAct = endAngleAct - Math.PI / 3;
    const actPathId = `actPath-${act}`;
    const labelText = showActLabels ? actLabels[act] && actLabels[act].length > 0 ? actLabels[act] : `Act ${act + 1}` : `${act + 1}`;
    svg += `
      <path id="${actPathId}" d="
        M ${formatNumber(actLabelRadius * Math.cos(startAngleAct))} ${formatNumber(actLabelRadius * Math.sin(startAngleAct))}
        A ${formatNumber(actLabelRadius)} ${formatNumber(actLabelRadius)} 0 0 1 ${formatNumber(actLabelRadius * Math.cos(endAngleAct))} ${formatNumber(actLabelRadius * Math.sin(endAngleAct))}
      " fill="none" />
      <text class="rt-act-label" fill="${maxStageColor}">
        <textPath href="#${actPathId}" startOffset="100%" text-anchor="end">${labelText}</textPath>
      </text>
    `;
  }
  return svg;
}

// src/renderer/components/Synopses.ts
function serializeSynopsesToString(synopsesElements) {
  const synopsesContainer = document.createElementNS("http://www.w3.org/2000/svg", "g");
  synopsesContainer.setAttribute("class", "synopses-container");
  synopsesElements.forEach((element) => {
    synopsesContainer.appendChild(element);
  });
  const serializer = new XMLSerializer();
  return serializer.serializeToString(synopsesContainer);
}

// src/renderer/utils/MonthSpokes.ts
function renderCalendarSpokesLayer({
  months,
  lineInnerRadius,
  monthTickEnd,
  currentMonthIndex,
  subplotOuterRadius,
  isChronologueMode,
  numActs
}) {
  const includeIntermediateSpokes = !isChronologueMode;
  const outerSpokeInnerRadius = isChronologueMode ? void 0 : subplotOuterRadius;
  return renderMonthSpokesAndInnerLabels({
    months,
    lineInnerRadius,
    lineOuterRadius: monthTickEnd,
    currentMonthIndex,
    includeIntermediateSpokes,
    outerSpokeInnerRadius,
    numActs
  });
}

// src/renderer/TimelineRenderer.ts
init_ChronologueTimeline();

// src/renderer/utils/Gossamer.ts
init_sceneHelpers();
function renderGossamerOverlay({
  plugin,
  scenes,
  innerRadius,
  actualOuterRadius,
  ringStartRadii,
  numRings,
  publishStageColors
}) {
  var _a;
  if (numRings <= 0) {
    return "";
  }
  const views = plugin.app.workspace.getLeavesOfType("radial-timeline");
  const isGossamerMode = views.some((leaf) => {
    const view = leaf.view;
    return (view == null ? void 0 : view.currentMode) === "gossamer";
  });
  if (!isGossamerMode) {
    return "";
  }
  let svg = "";
  const polar = { innerRadius, outerRadius: actualOuterRadius };
  const outerRingInnerRadius = ringStartRadii[numRings - 1];
  const run = plugin._gossamerLastRun || null;
  const anglesByBeat = plugin._beatAngles || /* @__PURE__ */ new Map();
  const beatPathByName = /* @__PURE__ */ new Map();
  scenes.forEach((scene) => {
    if (!isBeatNote(scene) || !scene.title || !scene.path) return;
    const titleWithoutNumber = scene.title.replace(/^\s*\d+(?:\.\d+)?\s+/, "").trim();
    beatPathByName.set(titleWithoutNumber, scene.path);
  });
  const publishStageColorByBeat = /* @__PURE__ */ new Map();
  scenes.forEach((scene) => {
    if (!isBeatNote(scene) || !scene.title) return;
    const titleWithoutNumber = scene.title.replace(/^\s*\d+(?:\.\d+)?\s+/, "").trim();
    const publishStage = scene["Publish Stage"] || "Zero";
    const stageColor = publishStageColors[publishStage] || publishStageColors.Zero;
    publishStageColorByBeat.set(titleWithoutNumber, stageColor);
  });
  const beatSlicesByName = plugin._beatSlices || /* @__PURE__ */ new Map();
  const numActs = Math.max(3, Math.floor((_a = plugin.settings.actCount) != null ? _a : 3));
  svg += renderGossamerMonthSpokes({ innerRadius, outerRadius: actualOuterRadius, numActs });
  const historicalRuns = plugin._gossamerHistoricalRuns || [];
  const minMax = plugin._gossamerMinMax || null;
  const hasAnyScores = plugin._gossamerHasAnyScores || false;
  const layer = renderGossamerLayer(
    scenes,
    run,
    polar,
    anglesByBeat.size ? anglesByBeat : void 0,
    beatPathByName,
    historicalRuns,
    minMax,
    outerRingInnerRadius,
    publishStageColorByBeat,
    beatSlicesByName,
    publishStageColors,
    hasAnyScores
  );
  if (layer) {
    svg += layer;
  }
  return svg;
}

// src/renderer/utils/RotationToggle.ts
init_svg();
function renderRotationToggle({ numActs, actualOuterRadius }) {
  const act2BaseAngle = 1 * 2 * Math.PI / numActs - Math.PI / 2;
  const arrowRadius = actualOuterRadius + 46;
  const arrowAngleAdjust = -(0.6 * Math.PI) / 180;
  const arrowAngle = act2BaseAngle + arrowAngleAdjust;
  const arrowX = formatNumber(arrowRadius * Math.cos(arrowAngle));
  const arrowY = formatNumber(arrowRadius * Math.sin(arrowAngle));
  const arrowRotateDeg = (act2BaseAngle + Math.PI / 2) * 180 / Math.PI - 90;
  return `
        <g id="rotation-toggle" class="rotation-toggle" transform="translate(${arrowX}, ${arrowY}) rotate(${formatNumber(arrowRotateDeg)})">
            <use id="rotation-arrow-up" class="arrow-icon" href="#icon-arrow-up-from-line" x="-14.4" y="-14.4" width="26" height="26" />
            <use id="rotation-arrow-down" class="arrow-icon is-hidden" href="#icon-arrow-down-from-line" x="-14.4" y="-14.4" width="26" height="26" />
            <rect x="-18" y="-18" width="36" height="36" fill="transparent" pointer-events="all">
                <title>Rotate timeline</title>
            </rect>
        </g>
    `;
}

// src/renderer/components/VersionIndicator.ts
init_svg();
init_LayoutConstants();
var BADGE_ALERT_ICON = `
<path d="M12 16h.01"/>
<path d="M12 8v4"/>
<path d="M15.312 2a2 2 0 0 1 1.414.586l4.688 4.688A2 2 0 0 1 22 8.688v6.624a2 2 0 0 1-.586 1.414l-4.688 4.688a2 2 0 0 1-1.414.586H8.688a2 2 0 0 1-1.414-.586l-4.688-4.688A2 2 0 0 1 2 15.312V8.688a2 2 0 0 1 .586-1.414l4.688-4.688A2 2 0 0 1 8.688 2z"/>
`;
var BUG_ICON = `
<path d="M12 20v-9"/>
<path d="M14 7a4 4 0 0 1 4 4v3a6 6 0 0 1-12 0v-3a4 4 0 0 1 4-4z"/>
<path d="M14.12 3.88 16 2"/>
<path d="M21 21a4 4 0 0 0-3.81-4"/>
<path d="M21 5a4 4 0 0 1-3.55 3.97"/>
<path d="M22 13h-4"/>
<path d="M3 21a4 4 0 0 1 3.81-4"/>
<path d="M3 5a4 4 0 0 0 3.55 3.97"/>
<path d="M6 13H2"/>
<path d="m8 2 1.88 1.88"/>
<path d="M9 7.13V6a3 3 0 1 1 6 0v1.13"/>
`;
var VERSION_TEXT_FONT_SIZE_PX = 20;
var VERSION_TEXT_CHAR_WIDTH_RATIO = 0.62;
var VERSION_INDICATOR_SAFE_PADDING = 32;
var ICON_HITAREA_SIZE = 32;
var ICON_HITAREA_HALF_WIDTH = ICON_HITAREA_SIZE / 2;
var HITAREA_HORIZONTAL_PADDING = 12;
var HITAREA_VERTICAL_PADDING = 10;
function estimateTextHalfWidth(text) {
  const trimmed = text.trim();
  const effectiveText = trimmed.length ? trimmed : text;
  const charCount = effectiveText.length || 4;
  const approxCharWidthPx = VERSION_TEXT_FONT_SIZE_PX * VERSION_TEXT_CHAR_WIDTH_RATIO;
  return charCount * approxCharWidthPx / 2;
}
function getUpdateSeverity(current, latest) {
  if (!latest) return "none";
  const parseVersion = (v) => {
    return v.replace(/^v/, "").split(".").map((n) => parseInt(n, 10) || 0);
  };
  const [curMajor] = parseVersion(current);
  const [latMajor] = parseVersion(latest);
  if (latMajor > curMajor) {
    return "major";
  }
  return "minor";
}
function renderVersionIndicator(options) {
  const { version, hasUpdate, latestVersion } = options;
  const currentVersionLabel = version.trim() || version;
  const latestVersionLabel = (latestVersion != null ? latestVersion : "").trim();
  const updateRangeText = latestVersionLabel ? `${currentVersionLabel} -> ${latestVersionLabel}` : currentVersionLabel;
  const rawVersionText = hasUpdate ? "NEW RELEASE" : currentVersionLabel;
  const versionText = rawVersionText.trim() || rawVersionText;
  const actionText = hasUpdate ? updateRangeText || "UPDATE TO LATEST VERSION" : "REPORT BUG";
  const versionTextHalfWidth = estimateTextHalfWidth(versionText);
  const actionTextHalfWidth = estimateTextHalfWidth(actionText);
  const maxHalfWidth = Math.max(versionTextHalfWidth, actionTextHalfWidth, ICON_HITAREA_HALF_WIDTH);
  const viewboxLeftEdge = -(SVG_SIZE / 2);
  const circleLeftEdge = -MONTH_LABEL_RADIUS;
  const safeCanvasCenterX = viewboxLeftEdge + VERSION_INDICATOR_SAFE_PADDING + maxHalfWidth;
  const safeCircleCenterX = circleLeftEdge + VERSION_INDICATOR_SAFE_PADDING + maxHalfWidth;
  const computedX = Math.max(VERSION_INDICATOR_POS_X, safeCanvasCenterX, safeCircleCenterX);
  const x = formatNumber(computedX);
  const y = formatNumber(VERSION_INDICATOR_POS_Y);
  const severity = hasUpdate ? getUpdateSeverity(version, latestVersion) : "none";
  const groupClasses = ["rt-version-indicator", `rt-update-${severity}`];
  if (hasUpdate) {
    groupClasses.push("rt-has-update");
  }
  const iconScale = 1;
  const iconSize = 24 * iconScale;
  const iconX = -(iconSize / 2);
  const iconY = 10;
  const hitAreaWidth = Math.max(
    ICON_HITAREA_SIZE + HITAREA_HORIZONTAL_PADDING * 2,
    maxHalfWidth * 2 + HITAREA_HORIZONTAL_PADDING * 2
  );
  const hitAreaX = -(hitAreaWidth / 2);
  const hitAreaY = -(VERSION_TEXT_FONT_SIZE_PX + HITAREA_VERTICAL_PADDING);
  const hitAreaHeight = VERSION_TEXT_FONT_SIZE_PX + HITAREA_VERTICAL_PADDING + (iconY + iconSize + HITAREA_VERTICAL_PADDING);
  const iconContent = hasUpdate ? BADGE_ALERT_ICON : BUG_ICON;
  const iconClass = hasUpdate ? "rt-version-alert-icon" : "rt-version-bug-icon";
  return `
        <g id="version-indicator" class="${groupClasses.join(" ")}" transform="translate(${x}, ${y})">
            <title>${hasUpdate ? updateRangeText : currentVersionLabel}</title>

            <!-- Unified hit area covers text and icon for consistent hover/click -->
            <rect class="rt-version-hitarea"
                x="${formatNumber(hitAreaX)}"
                y="${formatNumber(hitAreaY)}"
                width="${formatNumber(hitAreaWidth)}"
                height="${formatNumber(hitAreaHeight)}"
                rx="6" ry="6"
                fill="white" fill-opacity="0" stroke="none" pointer-events="all">
                <title>${hasUpdate ? updateRangeText : currentVersionLabel}</title>
            </rect>

            <!-- Version text (visible by default) -->
            <text class="rt-version-text rt-version-number" x="0" y="0">
                ${versionText}
            </text>

            <!-- Action text (visible on hover) -->
            <text class="rt-version-text rt-version-action" x="0" y="0">
                ${actionText}
            </text>
            
            <!-- Icon below version: Bug icon (no update) or Alert icon (update available) -->
            <g class="${iconClass}" transform="translate(${formatNumber(iconX)}, ${formatNumber(iconY)}) scale(${iconScale})">
                <title>${hasUpdate ? updateRangeText : currentVersionLabel}</title>
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
                    ${iconContent}
                </svg>
            </g>
        </g>
    `;
}

// src/renderer/components/HelpIcon.ts
init_svg();
init_LayoutConstants();
var LIFE_BUOY_ICON = `
<circle cx="12" cy="12" r="10"/>
<path d="m4.93 4.93 4.24 4.24"/>
<path d="m14.83 9.17 4.24-4.24"/>
<path d="m14.83 14.83 4.24 4.24"/>
<path d="m9.17 14.83-4.24 4.24"/>
<circle cx="12" cy="12" r="4"/>
`;
function renderHelpIcon() {
  const x = formatNumber(HELP_ICON_POS_X);
  const y = formatNumber(HELP_ICON_POS_Y);
  const iconSize = 24;
  const iconHalfSize = iconSize / 2;
  const iconX = -iconHalfSize;
  const iconY = 10;
  return `
        <g id="help-icon" class="rt-help-icon" transform="translate(${x}, ${y})">
            <!-- Hover Text: "GET HELP" -->
            <text class="rt-help-text" x="0" y="0">GET HELP</text>

            <g transform="translate(${formatNumber(iconX)}, ${formatNumber(iconY)})">
                 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-life-buoy-icon lucide-life-buoy">
                    ${LIFE_BUOY_ICON}
                </svg>
            </g>
            
            <!-- Hit area -->
             <rect class="rt-help-icon-hitarea" x="${formatNumber(iconX - 8)}" y="${formatNumber(iconY - 8)}" width="${iconSize + 16}" height="${iconSize + 16}" fill="white" fill-opacity="0" stroke="none" pointer-events="all">
            </rect>
        </g>
    `;
}

// src/renderer/utils/Estimation.ts
function renderCompletionEstimateLayer({
  estimateResult,
  progressRadius
}) {
  if (!estimateResult || !estimateResult.date) {
    return "";
  }
  const estimatedCompletionDate = estimateResult.date;
  const now = /* @__PURE__ */ new Date();
  const yearsDiff = estimatedCompletionDate.getFullYear() - now.getFullYear();
  if (yearsDiff > 0) {
    return "";
  }
  return renderEstimationArc({ estimateDate: estimatedCompletionDate, progressRadius });
}

// src/renderer/utils/ProgressRing.ts
function renderProgressRingBaseLayer({
  progressRadius,
  estimateResult
}) {
  let svg = "";
  svg += renderProgressRingGradients();
  svg += `
        <circle
            cx="0"
            cy="0"
            r="${progressRadius}"
            class="progress-ring-base"
        />
    `;
  svg += renderCompletionEstimateLayer({ estimateResult, progressRadius });
  return svg;
}

// src/renderer/TimelineRenderer.ts
var STAGE_HEADER_TOOLTIPS = {
  Zero: "Zero stage \u2014 The raw first draft. Unpolished ideas on the page, no revisions yet.",
  Author: "Author stage \u2014 The author revises and refines the draft after letting it rest.",
  House: "House stage \u2014 Alpha and beta readers give feedback. Publisher or editor reviews the manuscript. Copy-edited and proofed.",
  Press: "Press stage \u2014 Final version is ready for publication."
};
var STATUS_HEADER_TOOLTIPS = {
  Todo: "Todo \u2014 tasks or scenes not yet started",
  Working: "Working \u2014 tasks or scenes currently in progress",
  Due: "Due \u2014 tasks or scenes with a past-due date",
  Completed: "Completed \u2014 tasks or scenes finished"
};
function computeSceneTitleInset(fontScale) {
  if (!Number.isFinite(fontScale) || fontScale <= 1) return SCENE_TITLE_INSET;
  const extraInset = (fontScale - 1) * 18;
  return SCENE_TITLE_INSET + extraInset;
}
function createTimelineSVG(plugin, scenes) {
  var _a;
  const stopTotalPerf = startPerfSegment(plugin, "timeline.total");
  const sceneCount = scenes.length;
  const size = SVG_SIZE;
  const innerRadius = INNER_RADIUS;
  const monthLabelRadius = MONTH_LABEL_RADIUS;
  const chronologueDateRadius = CHRONOLOGUE_DATE_RADIUS;
  const monthTickStart = MONTH_TICK_START;
  const monthTickEnd = MONTH_TICK_END;
  const readabilityScale = getReadabilityScale(plugin.settings);
  const fontScale = getReadabilityMultiplier(plugin.settings);
  const maxTextWidth = MAX_TEXT_WIDTH * fontScale;
  const readabilityClass = `rt-font-scale-${readabilityScale}`;
  const sceneTitleInset = computeSceneTitleInset(fontScale);
  const stopPrepPerf = startPerfSegment(plugin, "timeline.scene-prep");
  const precomputed = computeCacheableValues(plugin, scenes);
  stopPrepPerf();
  const {
    scenesByActAndSubplot,
    masterSubplotOrder,
    colorIndexBySubplot,
    totalPlotNotes,
    plotIndexByKey,
    plotsBySubplot,
    ringWidths,
    ringStartRadii,
    lineInnerRadius,
    maxStageColor,
    subplotDominanceStates
  } = precomputed;
  const NUM_RINGS = masterSubplotOrder.length;
  const currentMode = plugin.settings.currentMode || "narrative";
  const shouldApplyNumberSquareColors = currentMode !== "gossamer";
  const resolveSubplotColorIndex = (subplotName) => {
    const key = subplotName && subplotName.trim().length > 0 ? subplotName : "Main Plot";
    if (colorIndexBySubplot.has(key)) return colorIndexBySubplot.get(key);
    const fallback = colorIndexBySubplot.get("Main Plot");
    return fallback !== void 0 ? fallback : 0;
  };
  const numberSquareVisualResolver = shouldApplyNumberSquareColors ? (scene) => ({
    subplotIndex: resolveSubplotColorIndex(scene.subplot || "Main Plot")
  }) : null;
  const subplotColorFor = (subplotName) => {
    const idx = resolveSubplotColorIndex(subplotName);
    const normalized = idx % 16;
    const varName = `--rt-subplot-colors-${normalized}`;
    const computed = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    return computed || "#EFBDEB";
  };
  const forceSubplotFillColors = currentMode === "narrative" || currentMode === "chronologue";
  const numActs = getConfiguredActCount(plugin.settings);
  const actLabels = parseActLabels(plugin.settings, numActs);
  const showActLabels = shouldShowActLabels(plugin.settings);
  const isChronologueMode = currentMode === "chronologue";
  const isSubplotMode = currentMode === "subplot";
  const sortByWhen = isChronologueMode ? true : (_a = plugin.settings.sortByWhenDate) != null ? _a : false;
  const forceChronological = isChronologueMode;
  const chronologueSceneEntries = isChronologueMode ? collectChronologueSceneEntries(scenes) : void 0;
  let svg = `<svg width="${size}" height="${size}" viewBox="-${size / 2} -${size / 2} ${size} ${size}" 
                       xmlns="http://www.w3.org/2000/svg" class="radial-timeline-svg ${readabilityClass}" data-font-scale="${readabilityScale}" data-num-acts="${numActs}"
                       preserveAspectRatio="xMidYMid meet">`;
  svg += `<g id="timeline-config-data" data-max-stage-color="${maxStageColor}"></g>`;
  const sceneNumbersMap = /* @__PURE__ */ new Map();
  const subplotOuterRadius = isChronologueMode ? SUBPLOT_OUTER_RADIUS_CHRONOLOGUE : isSubplotMode ? SUBPLOT_OUTER_RADIUS_MAINPLOT : SUBPLOT_OUTER_RADIUS_STANDARD[readabilityScale];
  const beatTextRadius = BEAT_TEXT_RADIUS[readabilityScale];
  const standardMonths = Array.from({ length: 12 }, (_, i) => {
    const angle = i / 12 * 2 * Math.PI - Math.PI / 2;
    const name = new Date(2e3, i).toLocaleString("en-US", { month: "long" });
    const shortName = new Date(2e3, i).toLocaleString("en-US", { month: "short" }).slice(0, 3);
    return { name, shortName, angle };
  });
  const months = standardMonths;
  let outerLabels;
  if (isChronologueMode) {
    outerLabels = buildChronologueOuterLabels(plugin, scenes);
  } else {
    outerLabels = standardMonths;
  }
  if (shouldShowAllScenesInOuterRing(plugin)) {
  }
  const PUBLISH_STAGE_COLORS = plugin.settings.publishStageColors;
  svg += `<defs>`;
  svg += renderDefs(PUBLISH_STAGE_COLORS);
  svg += renderMonthLabelDefs({ months: outerLabels, monthLabelRadius, chronologueDateRadius });
  svg += `</defs>`;
  svg += `<g id="timeline-root">`;
  const currentMonthIndex = (/* @__PURE__ */ new Date()).getMonth();
  let boundaryLabelsHtml = "";
  const outerLabelRender = renderOuterLabelTexts({
    outerLabels,
    isChronologueMode,
    currentMonthIndex
  });
  svg += outerLabelRender.labelsSvg;
  boundaryLabelsHtml = outerLabelRender.boundaryLabelsHtml;
  const now = /* @__PURE__ */ new Date();
  const startOfYear = new Date(now.getFullYear(), 0, 1);
  const yearProgress = (now.getTime() - startOfYear.getTime()) / (1e3 * 60 * 60 * 24 * 365);
  const progressRadius = lineInnerRadius + 15;
  const estimateResult = plugin.calculateCompletionEstimate(scenes);
  const circumference = 2 * Math.PI * progressRadius;
  const currentYearStartAngle = -Math.PI / 2;
  const currentYearEndAngle = currentYearStartAngle + 2 * Math.PI * yearProgress;
  svg += renderProgressRingBaseLayer({
    progressRadius,
    estimateResult
  });
  svg += renderCalendarSpokesLayer({
    months,
    lineInnerRadius,
    monthTickEnd,
    currentMonthIndex,
    subplotOuterRadius,
    isChronologueMode,
    numActs
  });
  if (isChronologueMode) {
    const ticksSvg = renderChronologueOuterTicks({
      outerLabels,
      monthTickStart,
      monthTickEnd
    });
    if (ticksSvg) {
      svg += ticksSvg;
    }
  }
  svg += renderProgressRing({ progressRadius, yearProgress, currentYearStartAngle, segmentCount: 6 });
  svg += renderTargetDateTick({ plugin, progressRadius, dateToAngle });
  const synopsesElements = [];
  const sceneGrades = /* @__PURE__ */ new Map();
  scenes.forEach((scene) => {
    var _a2, _b, _c;
    const subplot = scene.subplot && scene.subplot.trim().length > 0 ? scene.subplot : "Main Plot";
    const subplotIndex = masterSubplotOrder.indexOf(subplot);
    const ring = NUM_RINGS - 1 - subplotIndex;
    const actNumber = scene.actNumber !== void 0 ? scene.actNumber : 1;
    const currentMode2 = plugin.settings.currentMode || "narrative";
    const isChronologueMode2 = currentMode2 === "chronologue";
    const sortByWhen2 = isChronologueMode2 ? true : (_a2 = plugin.settings.sortByWhenDate) != null ? _a2 : false;
    const sceneActNumber = scene.actNumber !== void 0 ? scene.actNumber : 1;
    const actIndex = sortByWhen2 ? 0 : sceneActNumber - 1;
    const scenesInActAndSubplot = scenesByActAndSubplot[actIndex] && scenesByActAndSubplot[actIndex][subplot] || [];
    if (isBeatNote(scene)) {
      return;
    }
    const filteredScenesForIndex = scenesInActAndSubplot.filter((s) => !isBeatNote(s));
    const sceneIndex = filteredScenesForIndex.indexOf(scene);
    const sceneUniqueKey = scene.path || `${scene.title || ""}::${(_b = scene.number) != null ? _b : ""}::${(_c = scene.when) != null ? _c : ""}`;
    const sceneId = makeSceneId(actIndex, ring, sceneIndex, false, false, sceneUniqueKey);
    extractGradeFromScene(scene, sceneId, sceneGrades, plugin);
    appendSynopsisElementForScene({
      plugin,
      scene,
      sceneId,
      maxTextWidth,
      masterSubplotOrder,
      scenes,
      targets: synopsesElements
    });
  });
  svg += `<g id="timeline-rotatable">`;
  const lastBeatEndByAct = {};
  if (!sortByWhen) {
    svg += renderActLabels({
      numActs,
      actLabels,
      showActLabels,
      outerMostOuterRadius: ACT_LABEL_RADIUS,
      actLabelOffset: 0,
      maxStageColor
    });
  }
  plugin._beatAngles = /* @__PURE__ */ new Map();
  const manuscriptOrderPositions = isChronologueMode ? /* @__PURE__ */ new Map() : void 0;
  const actsToRender = sortByWhen ? 1 : numActs;
  const stopRingRender = startPerfSegment(plugin, "timeline.render-rings");
  const ringRenderContext = {
    plugin,
    scenes,
    actsToRender,
    sortByWhen,
    isChronologueMode,
    forceChronological,
    masterSubplotOrder,
    colorIndexBySubplot,
    ringStartRadii,
    ringWidths,
    scenesByActAndSubplot,
    PUBLISH_STAGE_COLORS,
    maxTextWidth,
    synopsesElements,
    sceneGrades,
    manuscriptOrderPositions,
    numActs
  };
  svg += renderRings(ringRenderContext);
  stopRingRender();
  svg += renderActBorders({ numActs, innerRadius, outerRadius: subplotOuterRadius });
  if (shouldShowSubplotRings(plugin)) {
    svg += renderSubplotDominanceIndicators({
      masterSubplotOrder,
      ringStartRadii,
      ringWidths,
      subplotStates: subplotDominanceStates,
      subplotColorFor
    });
  }
  const actualOuterRadius = ringStartRadii[NUM_RINGS - 1] + ringWidths[NUM_RINGS - 1];
  const keyX = size / 2 - 200;
  const keyY = -size / 2 + 50;
  const swatchSize = 20;
  const textOffset = 30;
  const lineHeight = GRID_LINE_HEIGHT;
  const { statusCounts, gridCounts, estimatedTotalScenes } = computeGridData(scenes);
  plugin.latestStatusCounts = statusCounts;
  const centerRadius = innerRadius * 0.7;
  const centerKeySize = 20;
  const centerLineHeight = 44;
  const stageColorEntries = Object.entries(PUBLISH_STAGE_COLORS);
  const ICON_ID_MAP = {
    Zero: "icon-circle-slash",
    Author: "icon-smile",
    House: "icon-house",
    Press: "icon-printer"
  };
  const statusColorEntries = Object.entries(STATUS_COLORS).filter(([status]) => status !== "Empty" && status !== "Complete");
  const maxEntries = Math.max(stageColorEntries.length, statusColorEntries.length);
  const totalHeight = maxEntries * centerLineHeight;
  const startY = -totalHeight / 2 + centerLineHeight / 2;
  const stagesForGrid = [...STAGES_FOR_GRID];
  const statusesForGrid = [...STATUSES_FOR_GRID];
  const cellBase = GRID_CELL_BASE;
  const cellWidth = Math.round(cellBase * 1.5) + GRID_CELL_WIDTH_EXTRA;
  const cellHeight = cellBase;
  const cellGapY = GRID_CELL_GAP_Y;
  const cellGapX = GRID_CELL_GAP_X;
  const gridWidth = statusesForGrid.length * cellWidth + (statusesForGrid.length - 1) * cellGapX;
  const gridHeight = stagesForGrid.length * cellHeight + (stagesForGrid.length - 1) * cellGapY;
  const startXGrid = -gridWidth / 2;
  const startYGrid = -gridHeight / 2;
  const currentYearLabel = String((/* @__PURE__ */ new Date()).getFullYear());
  const headerY = startYGrid - (cellGapY + GRID_HEADER_OFFSET_Y);
  let maxStageIdxForGrid = -1;
  for (let i = 0; i < stagesForGrid.length; i++) {
    const rc = gridCounts[stagesForGrid[i]];
    const rowTotal = (rc.Todo || 0) + (rc.Working || 0) + (rc.Due || 0) + (rc.Completed || 0);
    if (rowTotal > 0) maxStageIdxForGrid = i;
  }
  svg += renderCenterGrid({
    statusesForGrid,
    stagesForGrid,
    gridCounts,
    PUBLISH_STAGE_COLORS,
    currentYearLabel,
    estimatedTotalScenes,
    startXGrid,
    startYGrid,
    cellWidth,
    cellHeight,
    cellGapX,
    cellGapY,
    headerY,
    stageTooltips: STAGE_HEADER_TOOLTIPS,
    statusTooltips: STATUS_HEADER_TOOLTIPS
  });
  if (estimateResult && plugin.settings.showCompletionEstimate !== false) {
    svg += renderEstimatedDateElements({ estimateDate: estimateResult.date, progressRadius });
  }
  const numberSquareContext = {
    plugin,
    scenes,
    scenesByActAndSubplot,
    masterSubplotOrder,
    ringStartRadii,
    ringWidths,
    sceneGrades,
    sceneNumbersMap,
    numberSquareVisualResolver: numberSquareVisualResolver || null,
    shouldApplyNumberSquareColors,
    numActs
  };
  svg += renderNumberSquares(numberSquareContext);
  svg += `</g>`;
  svg += `<g class="background-layer subplot-labels-fixed">`;
  svg += renderSubplotLabels({ NUM_RINGS, ringStartRadii, ringWidths, masterSubplotOrder, plugin });
  svg += `</g>`;
  let chronologueOverlaysHtml = "";
  if (isChronologueMode) {
    chronologueOverlaysHtml = renderChronologueOverlays({
      plugin,
      scenes,
      subplotOuterRadius,
      manuscriptOrderPositions,
      ringStartRadii,
      ringWidths,
      masterSubplotOrder,
      chronologueSceneEntries,
      durationArcRadius: CHRONOLOGUE_DURATION_ARC_RADIUS,
      synopsesElements,
      maxTextWidth
    });
  }
  const synopsisHTML = serializeSynopsesToString(synopsesElements);
  svg += renderGossamerOverlay({
    plugin,
    scenes,
    innerRadius,
    actualOuterRadius,
    ringStartRadii,
    numRings: NUM_RINGS,
    publishStageColors: PUBLISH_STAGE_COLORS
  });
  svg += chronologueOverlaysHtml;
  if (isChronologueMode && boundaryLabelsHtml) {
    svg += boundaryLabelsHtml;
  }
  svg += synopsisHTML;
  svg += `</g>`;
  svg += renderRotationToggle({ numActs, actualOuterRadius });
  try {
    const versionService = getVersionCheckService();
    svg += renderVersionIndicator({
      version: versionService.getCurrentVersion(),
      hasUpdate: versionService.isUpdateAvailable(),
      latestVersion: versionService.getLatestVersion() || void 0
    });
  } catch (e) {
  }
  svg += renderHelpIcon();
  const scriptSection = ``;
  svg += `${scriptSection}</svg>`;
  const generatedSvgString = svg;
  stopTotalPerf();
  return { svgString: generatedSvgString, maxStageColor };
}

// src/renderer/dom/BeatLabelAdjuster.ts
init_svg();
init_LayoutConstants();
var beatLabelAdjustState = /* @__PURE__ */ new WeakMap();
function getLabelSignature(container) {
  const ids = Array.from(container.querySelectorAll(".rt-storybeat-title textPath")).map((tp) => tp.getAttribute("href") || "").join("|");
  return ids;
}
function adjustBeatLabelsAfterRender(container, attempt = 0) {
  const state = beatLabelAdjustState.get(container) || {};
  if (!container.isConnected) return;
  const labels = container.querySelectorAll(".rt-storybeat-title");
  if (labels.length === 0) return;
  const SPACE_BEFORE_DASH = 6;
  const SPACE_AFTER_DASH = 4;
  const TEXT_START_OFFSET = 2;
  const EXTRA_BREATHING_ROOM = BEAT_LABEL_BREATHING_ROOM_PX;
  const svgRoot = container.querySelector("svg.radial-timeline-svg");
  const isHidden = !svgRoot || svgRoot.getBoundingClientRect().width === 0 || document.visibilityState === "hidden";
  const MAX_ATTEMPTS = 10;
  const signature = getLabelSignature(container);
  if (state.signature !== signature) {
    state.signature = signature;
    state.success = false;
    if (state.retryId) cancelAnimationFrame(state.retryId);
    beatLabelAdjustState.set(container, state);
  }
  if (state.signature === signature && state.success) {
    return;
  }
  if (isHidden && attempt < MAX_ATTEMPTS) {
    const rafId = requestAnimationFrame(() => adjustBeatLabelsAfterRender(container, attempt + 1));
    state.retryId = rafId;
    beatLabelAdjustState.set(container, state);
    return;
  }
  const labelData = [];
  let measurableCount = 0;
  labels.forEach((label) => {
    var _a;
    const textElement = label;
    const textPath = textElement.querySelector("textPath");
    if (!textPath) return;
    const pathId = (_a = textPath.getAttribute("href")) == null ? void 0 : _a.substring(1);
    if (!pathId) return;
    const pathElement = container.querySelector(`#${pathId}`);
    if (!pathElement) return;
    const textLength = textPath.getComputedTextLength();
    if (textLength === 0) {
      return;
    }
    measurableCount++;
    const d = pathElement.getAttribute("d");
    if (!d) return;
    const arcMatch = d.match(/M\s+([-\d.]+)\s+([-\d.]+)\s+A\s+([-\d.]+)/);
    if (!arcMatch) return;
    const x = parseFloat(arcMatch[1]);
    const y = parseFloat(arcMatch[2]);
    const radius = parseFloat(arcMatch[3]);
    const originalStartAngle = Math.atan2(y, x);
    labelData.push({
      element: textElement,
      textPath,
      pathElement,
      pathId,
      originalStartAngle,
      textLength,
      radius
    });
  });
  if (measurableCount < labels.length && attempt < MAX_ATTEMPTS) {
    state.signature = signature;
    state.success = false;
    beatLabelAdjustState.set(container, state);
    window.setTimeout(() => adjustBeatLabelsAfterRender(container, attempt + 1), 50);
    return;
  }
  if (measurableCount === 0 && attempt >= MAX_ATTEMPTS) {
    state.lastAbortSignature = signature;
    beatLabelAdjustState.set(container, state);
    return;
  }
  labelData.sort((a, b) => {
    if (a.originalStartAngle === b.originalStartAngle) return a.pathId.localeCompare(b.pathId);
    return a.originalStartAngle - b.originalStartAngle;
  });
  let lastEnd = Number.NEGATIVE_INFINITY;
  const adjustments = [];
  labelData.forEach((data) => {
    const pathWidth = TEXT_START_OFFSET + data.textLength + EXTRA_BREATHING_ROOM;
    const pathAngleSpan = pathWidth / Math.max(1, data.radius);
    const textOnlyWidth = TEXT_START_OFFSET + data.textLength;
    const textAngleSpan = textOnlyWidth / Math.max(1, data.radius);
    let startAngle = data.originalStartAngle;
    let needsDash = false;
    let dashAngle;
    if (startAngle < lastEnd) {
      const shift = lastEnd - startAngle;
      startAngle += shift + EXTRA_BREATHING_ROOM / Math.max(1, data.radius);
      needsDash = true;
      dashAngle = startAngle - SPACE_BEFORE_DASH / Math.max(1, data.radius);
    }
    lastEnd = startAngle + textAngleSpan + SPACE_AFTER_DASH / Math.max(1, data.radius);
    adjustments.push({ data, newStartAngle: startAngle, needsDash, dashAngle, pathAngleSpan });
  });
  adjustments.forEach(({ data, newStartAngle, needsDash, dashAngle, pathAngleSpan }) => {
    var _a;
    const pathElement = data.pathElement;
    const radius = data.radius;
    const endAngle = newStartAngle + pathAngleSpan;
    const x1 = radius * Math.cos(newStartAngle);
    const y1 = radius * Math.sin(newStartAngle);
    const x2 = radius * Math.cos(endAngle);
    const y2 = radius * Math.sin(endAngle);
    const largeArc = pathAngleSpan > Math.PI ? 1 : 0;
    const newPath = `M ${formatNumber(x1)} ${formatNumber(y1)} A ${formatNumber(radius)} ${formatNumber(radius)} 0 ${largeArc} 1 ${formatNumber(x2)} ${formatNumber(y2)}`;
    pathElement.setAttribute("d", newPath);
    if (needsDash && typeof dashAngle === "number") {
      const dashRadius = radius + 1;
      const dashAngleMid = dashAngle;
      const x = dashRadius * Math.cos(dashAngleMid);
      const y = dashRadius * Math.sin(dashAngleMid);
      const deg = (dashAngleMid + Math.PI / 2) * 180 / Math.PI;
      let separator = container.querySelector(`#plot-separator-${data.pathId}`);
      if (!separator) {
        separator = document.createElementNS("http://www.w3.org/2000/svg", "text");
        separator.setAttribute("id", `plot-separator-${data.pathId}`);
        separator.setAttribute("class", "rt-storybeat-title rt-plot-dash-separator");
        separator.setAttribute("text-anchor", "middle");
        separator.setAttribute("dy", "-3");
        separator.textContent = "\u2014";
        (_a = data.pathElement.parentElement) == null ? void 0 : _a.appendChild(separator);
      }
      separator.setAttribute("transform", `translate(${formatNumber(x)}, ${formatNumber(y)}) rotate(${formatNumber(deg)})`);
    } else {
      const separator = container.querySelector(`#plot-separator-${data.pathId}`);
      separator == null ? void 0 : separator.remove();
    }
  });
  state.success = true;
  beatLabelAdjustState.set(container, state);
}

// src/services/RendererService.ts
var RendererService = class {
  constructor(app) {
    this.app = app;
  }
  generateTimeline(plugin, scenes) {
    return createTimelineSVG(plugin, scenes);
  }
  adjustBeatLabelsAfterRender(container) {
    adjustBeatLabelsAfterRender(container);
  }
  /**
   * Update scene colors for dominant subplot changes (DOM update)
   */
  updateSceneColorsDOM(container, plugin, changedScenes) {
    const svg = container.querySelector(".radial-timeline-svg");
    if (!svg) return false;
    return updateSceneColors(svg, plugin, changedScenes);
  }
  /**
   * Update number square states (status, AI grades) (DOM update)
   */
  updateNumberSquaresDOM(container, plugin, scenes) {
    const svg = container.querySelector(".radial-timeline-svg");
    if (!svg) return false;
    return updateNumberSquareStates(svg, plugin, scenes);
  }
  /**
   * Update synopsis text content (DOM update)
   */
  updateSynopsisDOM(container, changedScenes) {
    const svg = container.querySelector(".radial-timeline-svg");
    if (!svg) return false;
    return updateSynopsisText(svg, changedScenes);
  }
  /**
   * Update subplot labels for mode changes (DOM update)
   */
  updateSubplotLabelsDOM(container, newLabels) {
    const svg = container.querySelector(".radial-timeline-svg");
    if (!svg) return false;
    return updateSubplotLabels(svg, newLabels);
  }
  /**
   * Update open-file visual state without full re-render.
   * Adds/removes rt-scene-is-open classes on scene groups and associated number elements.
   */
  updateOpenClasses(container, openPaths) {
    const svg = container.querySelector(".radial-timeline-svg");
    if (!svg) return false;
    const sceneGroups = Array.from(svg.querySelectorAll(".rt-scene-group"));
    sceneGroups.forEach((group) => {
      const encPath = group.getAttribute("data-path");
      const path = encPath ? decodeURIComponent(encPath) : "";
      const isOpen = path !== "" && openPaths.has(path);
      group.classList.toggle("rt-scene-is-open", isOpen);
      const scenePath = group.querySelector(".rt-scene-path");
      const sceneTitle = group.querySelector(".rt-scene-title");
      if (scenePath) scenePath.classList.toggle("rt-scene-is-open", isOpen);
      if (sceneTitle) sceneTitle.classList.toggle("rt-scene-is-open", isOpen);
      const sceneId = scenePath == null ? void 0 : scenePath.id;
      if (sceneId) {
        const numSquare = svg.querySelector(`.rt-number-square[data-scene-id="${sceneId}"]`);
        const numText = svg.querySelector(`.rt-number-text[data-scene-id="${sceneId}"]`);
        if (numSquare) numSquare.classList.toggle("rt-scene-is-open", isOpen);
        if (numText) numText.classList.toggle("rt-scene-is-open", isOpen);
      }
    });
    return true;
  }
  /**
   * Rebuild search highlights without full re-render.
   * Clears previous rt-search-term nodes and rt-search-result classes,
   * then re-applies highlights using existing logic.
   */
  updateSearchHighlights(view) {
    const container = view.containerEl.children[1];
    if (!container) return false;
    const svg = container.querySelector(".radial-timeline-svg");
    if (!svg) return false;
    const existing = svg.querySelectorAll(".rt-search-term");
    existing.forEach((node) => {
      const parent = node.parentNode;
      if (!parent) return node.remove();
      const textNode = document.createTextNode(node.textContent || "");
      parent.replaceChild(textNode, node);
    });
    try {
      addHighlightRectangles(view);
    } catch (e) {
    }
    return true;
  }
  /**
   * Selectively rebuild or remove the Gossamer layer and spokes inside the existing SVG.
   * - If the view is in gossamer mode, (re)generates spokes + layer and inserts them before synopses.
   * - If not in gossamer mode, removes any existing gossamer elements.
   * Returns true on success, false if SVG or required data is missing (caller may fall back to full refresh).
   */
  updateGossamerLayer(view) {
    var _a, _b, _c, _d, _e;
    const container = view.containerEl.children[1];
    if (!container) return false;
    const svg = container.querySelector(".radial-timeline-svg");
    if (!svg) return false;
    const applyGossamerMask = () => {
      if (view.currentMode === "gossamer") {
        svg.setAttribute("data-gossamer-mode", "true");
        const elements = svg.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title");
        elements.forEach((el) => {
          const group = el.closest(".rt-scene-group");
          const itemType = group == null ? void 0 : group.getAttribute("data-item-type");
          if (itemType !== "Beat") {
            el.classList.add("rt-non-selected");
          }
        });
      } else {
        svg.removeAttribute("data-gossamer-mode");
      }
    };
    const removeExisting = () => {
      svg.querySelectorAll(".rt-gossamer-layer, .rt-gossamer-spokes").forEach((node) => {
        var _a2;
        return (_a2 = node.parentNode) == null ? void 0 : _a2.removeChild(node);
      });
    };
    const captureGeometry = () => {
      let innerRadius2 = null;
      let outerRadius2 = null;
      const existingGossamerSpoke = svg.querySelector(".rt-gossamer-spokes line");
      if (existingGossamerSpoke) {
        const x1 = Number(existingGossamerSpoke.getAttribute("x1") || "0");
        const y1 = Number(existingGossamerSpoke.getAttribute("y1") || "0");
        const x2 = Number(existingGossamerSpoke.getAttribute("x2") || "0");
        const y2 = Number(existingGossamerSpoke.getAttribute("y2") || "0");
        innerRadius2 = Math.hypot(x1, y1);
        outerRadius2 = Math.hypot(x2, y2);
      }
      const beatGroups = Array.from(svg.querySelectorAll('.rt-scene-group[data-item-type="Beat"]'));
      if (beatGroups.length > 0) {
        if (innerRadius2 === null || !Number.isFinite(innerRadius2)) {
          const inners = beatGroups.map((g) => Number(g.getAttribute("data-inner-r") || "0")).filter((n) => Number.isFinite(n));
          if (inners.length > 0) innerRadius2 = Math.min(...inners);
        }
        if (outerRadius2 === null || !Number.isFinite(outerRadius2)) {
          const outers = beatGroups.map((g) => Number(g.getAttribute("data-outer-r") || "0")).filter((n) => Number.isFinite(n));
          if (outers.length > 0) outerRadius2 = Math.max(...outers);
        }
      }
      if (innerRadius2 === null || !Number.isFinite(innerRadius2)) innerRadius2 = 200;
      if (outerRadius2 === null || !Number.isFinite(outerRadius2)) outerRadius2 = innerRadius2 + 300;
      let outerRingInnerRadius2 = innerRadius2;
      if (beatGroups.length > 0) {
        const inners = beatGroups.map((g) => Number(g.getAttribute("data-inner-r") || "0")).filter((n) => Number.isFinite(n));
        if (inners.length > 0) outerRingInnerRadius2 = Math.min(...inners);
      }
      return { innerRadius: innerRadius2, outerRadius: outerRadius2, outerRingInnerRadius: outerRingInnerRadius2 };
    };
    const isGossamerMode = view.currentMode === "gossamer";
    if (!isGossamerMode) {
      removeExisting();
      applyGossamerMask();
      return true;
    }
    const pluginAny = view.plugin;
    const run = pluginAny._gossamerLastRun || null;
    if (!run) {
      removeExisting();
      applyGossamerMask();
      return false;
    }
    const scenes = Array.isArray(view.sceneData) && view.sceneData.length > 0 ? view.sceneData : view.plugin.lastSceneData || [];
    const anglesByBeat = pluginAny._beatAngles || /* @__PURE__ */ new Map();
    const beatSlicesByName = pluginAny._beatSlices || /* @__PURE__ */ new Map();
    const beatPathByName = /* @__PURE__ */ new Map();
    const publishStageColorByBeat = /* @__PURE__ */ new Map();
    if (scenes.length > 0) {
      scenes.forEach((s) => {
        if (s.itemType !== "Plot" || !s.title) return;
        const titleWithoutNumber = (s.title || "").replace(/^\s*\d+(?:\.\d+)?\s+/, "").trim();
        if (s.path) beatPathByName.set(titleWithoutNumber, s.path);
        const publishStage = s["Publish Stage"] || "Zero";
        const PUBLISH_STAGE_COLORS = view.plugin.PUBLISH_STAGE_COLORS;
        if (PUBLISH_STAGE_COLORS) {
          const stageColor = PUBLISH_STAGE_COLORS[publishStage] || PUBLISH_STAGE_COLORS.Zero;
          publishStageColorByBeat.set(titleWithoutNumber, stageColor);
        }
      });
    }
    const { innerRadius, outerRadius, outerRingInnerRadius } = captureGeometry();
    removeExisting();
    const historicalRuns = pluginAny._gossamerHistoricalRuns || [];
    const minMax = pluginAny._gossamerMinMax || null;
    const spokesHtml = renderGossamerMonthSpokes({
      innerRadius,
      outerRadius,
      numActs: (_b = (_a = view.plugin.settings) == null ? void 0 : _a.actCount) != null ? _b : 3
    });
    const layerHtml = renderGossamerLayer(
      scenes || [],
      run,
      { innerRadius, outerRadius },
      anglesByBeat.size ? anglesByBeat : void 0,
      beatPathByName.size ? beatPathByName : void 0,
      historicalRuns,
      minMax,
      outerRingInnerRadius,
      publishStageColorByBeat.size ? publishStageColorByBeat : void 0,
      beatSlicesByName,
      (_c = view.plugin.settings) == null ? void 0 : _c.publishStageColors
    );
    const toNode = (html) => {
      if (!html) return null;
      const parser = new DOMParser();
      const doc = parser.parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${html}</svg>`, "image/svg+xml");
      return doc.documentElement.firstElementChild;
    };
    const spokesNode = toNode(spokesHtml);
    const layerNode = toNode(layerHtml);
    if (!spokesNode && !layerNode) {
      applyGossamerMask();
      return false;
    }
    const firstSynopsis = svg.querySelector(".rt-scene-info");
    if (firstSynopsis) {
      if (spokesNode) (_d = firstSynopsis.parentNode) == null ? void 0 : _d.insertBefore(spokesNode, firstSynopsis);
      if (layerNode) (_e = firstSynopsis.parentNode) == null ? void 0 : _e.insertBefore(layerNode, firstSynopsis);
    } else {
      if (spokesNode) svg.appendChild(spokesNode);
      if (layerNode) svg.appendChild(layerNode);
    }
    applyGossamerMask();
    return true;
  }
  /**
   * Selectively update the year progress ring, target-date tick/marker,
   * and estimated date elements without full re-render.
   */
  updateProgressAndTicks(view) {
    const container = view.containerEl.children[1];
    if (!container) return false;
    const svg = container.querySelector(".radial-timeline-svg");
    if (!svg) return false;
    const baseCircle = svg.querySelector("circle.progress-ring-base");
    if (!baseCircle) return false;
    const progressRadius = Number(baseCircle.getAttribute("r") || "0");
    if (!Number.isFinite(progressRadius) || progressRadius <= 0) return false;
    svg.querySelectorAll("path.progress-ring-fill").forEach((n) => {
      var _a;
      return (_a = n.parentNode) == null ? void 0 : _a.removeChild(n);
    });
    svg.querySelectorAll("line.target-date-tick, rect.target-date-marker").forEach((n) => {
      var _a;
      return (_a = n.parentNode) == null ? void 0 : _a.removeChild(n);
    });
    svg.querySelectorAll("line.estimated-date-tick, circle.estimated-date-dot, text.estimation-date-label").forEach((n) => {
      var _a;
      return (_a = n.parentNode) == null ? void 0 : _a.removeChild(n);
    });
    svg.querySelectorAll("path.progress-ring-base").forEach((n) => {
      var _a;
      return (_a = n.parentNode) == null ? void 0 : _a.removeChild(n);
    });
    const now = /* @__PURE__ */ new Date();
    const startOfYear = new Date(now.getFullYear(), 0, 1);
    const yearProgress = (now.getTime() - startOfYear.getTime()) / (1e3 * 60 * 60 * 24 * 365);
    const currentYearStartAngle = -Math.PI / 2;
    const segmentsHtml = renderProgressRing({ progressRadius, yearProgress, currentYearStartAngle, segmentCount: 6 });
    const tickHtml = renderTargetDateTick({ plugin: view.plugin, progressRadius, dateToAngle });
    let estimationHtml = "";
    try {
      if (typeof view.plugin.calculateCompletionEstimate === "function") {
        const scenes = view.sceneData || view.plugin.lastSceneData || [];
        const estimateResult = view.plugin.calculateCompletionEstimate(scenes);
        if (estimateResult && view.plugin.settings.showCompletionEstimate !== false) {
          const yearsDiff = estimateResult.date.getFullYear() - now.getFullYear();
          if (yearsDiff <= 0) {
            estimationHtml += renderEstimationArc({ estimateDate: estimateResult.date, progressRadius });
          }
          estimationHtml += renderEstimatedDateElements({ estimateDate: estimateResult.date, progressRadius });
        }
      }
    } catch (e) {
    }
    const combined = `${estimationHtml}${segmentsHtml}${tickHtml}`;
    const parser = new DOMParser();
    const doc = parser.parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${combined}</svg>`, "image/svg+xml");
    const toInsert = Array.from(doc.documentElement.children);
    if (toInsert.length === 0) return true;
    const parent = baseCircle.parentNode;
    if (!parent) return false;
    const nextSibling = baseCircle.nextSibling;
    toInsert.forEach((el) => parent.insertBefore(svg.ownerDocument.importNode(el, true), nextSibling));
    return true;
  }
};

// src/settings/SettingsTab.ts
var import_obsidian46 = require("obsidian");

// src/settings/FolderSuggest.ts
var import_obsidian26 = require("obsidian");
var FolderSuggest = class extends import_obsidian26.AbstractInputSuggest {
  constructor(app, input, plugin, text) {
    super(app, input);
    this.plugin = plugin;
    this.text = text;
  }
  getSuggestions(query) {
    var _a, _b, _c, _d;
    const q = (_a = query == null ? void 0 : query.toLowerCase()) != null ? _a : "";
    const folders = (_d = (_c = (_b = this.app.vault).getAllFolders) == null ? void 0 : _c.call(_b)) != null ? _d : this.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian26.TFolder);
    if (!q) return folders;
    return folders.filter((f) => f.path.toLowerCase().includes(q));
  }
  renderSuggestion(folder, el) {
    el.setText(folder.path);
  }
  selectSuggestion(folder, _evt) {
    const inputEl = this.text.inputEl;
    const normalized = (0, import_obsidian26.normalizePath)(folder.path);
    try {
      this.text.setValue(normalized);
    } catch (e) {
    }
    if (this.inputEl) {
      try {
        this.inputEl.value = normalized;
      } catch (e) {
      }
    }
    void this.plugin.validateAndRememberPath(normalized).then(async (ok) => {
      if (ok) {
        this.plugin.settings.sourcePath = normalized;
        await this.plugin.saveSettings();
        inputEl.removeClass("setting-input-error");
        inputEl.addClass("setting-input-success");
        window.setTimeout(() => inputEl.removeClass("setting-input-success"), 1e3);
      } else {
        inputEl.addClass("setting-input-error");
        window.setTimeout(() => inputEl.removeClass("setting-input-error"), 2e3);
      }
      try {
        this.close();
      } catch (e) {
      }
      try {
        inputEl.focus();
      } catch (e) {
      }
    });
  }
};

// src/settings/sections/GeneralSection.ts
var import_obsidian27 = require("obsidian");
function renderGeneralSection(params) {
  const { app, plugin, attachFolderSuggest, containerEl } = params;
  const sourcePathSetting = new import_obsidian27.Setting(containerEl).setName("Source path").setDesc("Specify the root folder containing your manuscript scene files.");
  let textInput;
  sourcePathSetting.addText((text) => {
    textInput = text;
    text.setPlaceholder("Example: Book 1").setValue(plugin.settings.sourcePath);
    text.inputEl.addClass("rt-input-full");
    attachFolderSuggest(text);
    text.onChange(() => {
      text.inputEl.removeClass("rt-setting-input-success");
      text.inputEl.removeClass("rt-setting-input-error");
    });
    plugin.registerDomEvent(text.inputEl, "keydown", (evt) => {
      if (evt.key === "Enter") {
        evt.preventDefault();
        text.inputEl.blur();
      }
    });
    const handleBlur = async () => {
      var _a;
      const value = text.getValue();
      const trimmed = value.trim();
      const normalizedValue = trimmed ? (0, import_obsidian27.normalizePath)(trimmed) : "";
      if (trimmed) {
        const isValid = await plugin.validateAndRememberPath(normalizedValue);
        if (isValid) {
          plugin.settings.sourcePath = normalizedValue;
          await plugin.saveSettings();
          text.inputEl.addClass("rt-setting-input-success");
          window.setTimeout(() => {
            text.inputEl.removeClass("rt-setting-input-success");
          }, 1e3);
        } else {
          text.inputEl.addClass("rt-setting-input-error");
          window.setTimeout(() => {
            text.inputEl.removeClass("rt-setting-input-error");
          }, 2e3);
        }
      } else {
        plugin.settings.sourcePath = normalizedValue;
        await plugin.saveSettings();
        plugin.refreshTimelineIfNeeded(null);
        const suggestions = (_a = text.inputEl.closest(".setting-item")) == null ? void 0 : _a.querySelector(".source-path-suggestions");
        suggestions == null ? void 0 : suggestions.classList.add("hidden");
        text.inputEl.addClass("rt-setting-input-success");
        window.setTimeout(() => {
          text.inputEl.removeClass("rt-setting-input-success");
        }, 1e3);
      }
    };
    plugin.registerDomEvent(text.inputEl, "blur", () => {
      void handleBlur();
    });
  });
  new import_obsidian27.Setting(containerEl).setName("Show source path as title").setDesc('Display the source folder name as the title of your work. When off, displays "Work in Progress" instead.').addToggle((toggle) => {
    toggle.setValue(plugin.settings.showSourcePathAsTitle !== false).onChange(async (value) => {
      plugin.settings.showSourcePathAsTitle = value;
      await plugin.saveSettings();
      plugin.refreshTimelineIfNeeded(null);
    });
  });
}

// src/settings/sections/PublicationSection.ts
var import_obsidian30 = require("obsidian");

// src/i18n/index.ts
var import_obsidian28 = require("obsidian");

// src/i18n/locales/en.ts
var en = {
  settings: {
    general: {
      sourcePath: {
        name: "Source path",
        desc: "Specify the root folder containing your manuscript scene files.",
        placeholder: "Example: Manuscript/Scenes"
      },
      showTitle: {
        name: "Show source path as title",
        desc: 'Display the source folder name as the title of your work. When off, displays "Work in Progress" instead.'
      }
    },
    pov: {
      heading: "Point of view",
      global: {
        name: "Global POV",
        desc: "Choose a default mode to apply. Scene level POV will override this global setting."
      },
      yamlOverrides: {
        name: "Scene level YAML overrides",
        desc: "Values you can use for `POV:` first, second, third, omni, objective, or a number such as two, four, count, or all to designate more than one character is carrying the scene POV. If two, for example, then the first two characters in `Character:` YAML list will get a POV mark for scene synopsis."
      },
      modes: {
        off: "Legacy (first listed character, POV)",
        first: "First-person voice (\xB9)",
        second: "Second-person voice (You\xB2)",
        third: "Third-person limited (\xB3)",
        omni: "Omni narrator (Omni\xB3)",
        objective: "Objective \u2014 camera-eye narrator (Narrator\xB0)"
      }
    },
    advanced: {
      heading: "Advanced",
      aiOutputFolder: {
        name: "Logs & generated files output folder",
        desc: "Folder where AI logs and generated files (manuscripts, local LLM reports) are saved. Uses your vault folder structure.",
        placeholder: "AI"
      },
      autoExpand: {
        name: "Auto-expand clipped scene titles",
        desc: "When hovering over a scene, automatically expand it if the title text is clipped. Disable this if you prefer to quickly slide through scenes and read titles from the synopsis instead."
      },
      readability: {
        name: "Readability size",
        desc: "Choose a curated font sizing profile for timeline text. Large is tuned for low-res or low-vision viewing; Normal works for standard and high-dpi layouts.",
        normal: "Normal",
        large: "Large"
      },
      showEstimate: {
        name: "Show estimated completion date",
        desc: "Display a tick mark and label on the timeline for the estimated completion date. Tip: When you complete a scene, in addition to setting the Status to Complete, also set the Due date to the same day the scene was completed to improve the estimate."
      },
      debounce: {
        name: "Metadata refresh debounce (ms)",
        desc: "Delay before refreshing the timeline after YAML frontmatter changes. Increase if your vault is large and updates feel too frequent.",
        placeholder: "e.g., 10000",
        error: "Please enter a non-negative number."
      },
      resetSubplotColors: {
        name: "Reset subplot color dominance",
        desc: "Clear all saved subplot color dominance preferences for scenes that appear in multiple subplots. This resets to the default ordering (outermost to innermost rings based on subplot scene population).",
        button: "Reset to default",
        clearedNotice: "Cleared saved colors for {{count}} multi-subplot scene(s).",
        nothingToReset: "No subplot dominance preferences to reset."
      },
      sceneOrdering: {
        name: "Scene ordering based on When date",
        desc: "Under consideration. Sort scenes chronologically by When date instead of manuscript order for all modes."
      }
    },
    ai: {
      heading: "AI LLM for scene analysis",
      enable: {
        name: "Enable AI LLM features",
        desc: "Show command palette options and UI scene analysis colors and hover synopsis. When off, these visuals are hidden, but metadata remains unchanged."
      }
    },
    publication: {
      heading: "Publication & Progress"
    },
    chronologue: {
      heading: "Chronologue Mode"
    },
    storyBeats: {
      heading: "Story Beats & Gossamer"
    },
    colors: {
      heading: "Colors"
    }
  },
  timeline: {
    acts: {
      act1: "ACT I",
      act2: "ACT II",
      act3: "ACT III"
    },
    workInProgress: "Work in Progress"
  },
  common: {
    yes: "Yes",
    no: "No",
    cancel: "Cancel",
    save: "Save",
    reset: "Reset",
    enable: "Enable",
    disable: "Disable",
    loading: "Loading...",
    error: "Error",
    success: "Success"
  },
  notices: {
    settingsSaved: "Settings saved.",
    invalidInput: "Invalid input."
  },
  manuscriptModal: {
    title: "Generate manuscript",
    description: "Use markdown-linked TOC for Obsidian-friendly navigation, or plain TOC for AI processing. All orderings support custom ranges with the draggable selector.",
    heroLoading: "Loading scenes...",
    heroNarrativeMeta: "Drag handles to select range",
    tocHeading: "Table of contents",
    tocMarkdown: "Markdown links (default)",
    tocPlain: "Plain text",
    tocNone: "No TOC",
    tocNote: "Exactly one TOC format will be used. Markdown adds clickable scene anchors.",
    orderHeading: "Scene ordering",
    orderNarrative: "Narrative",
    orderReverseNarrative: "Reverse",
    orderChronological: "Chronological",
    orderReverseChronological: "Reverse chrono",
    orderNote: "Chronological follows When dates. Reverse options invert the ordering.",
    rangeHeading: "Scene range",
    rangeFirst: "First scene",
    rangeLast: "Last scene",
    rangeAllLabel: "All scenes",
    rangeSingleLabel: "Single scene",
    rangeSelectedLabel: "Scenes {{start}}\u2013{{end}}",
    rangeCountLabel: "{{count}} scenes selected",
    rangeStatus: "Scenes {{start}} \u2013 {{end}} of {{total}} ({{count}} selected)",
    rangeLoading: "Fetching scenes\u2026",
    actionCreate: "Generate manuscript",
    actionCancel: "Cancel",
    emptyNotice: "No scenes available to assemble.",
    rangeEmpty: "Selected range is empty.",
    loadError: "Failed to load scenes."
  },
  planetary: {
    heading: "Planetary calendar system",
    enable: {
      name: "Enable planetary conversions",
      desc: "Turns on the converter modal, Chronologue Alt/Option tooltip, and synopsis line for the active profile."
    },
    active: {
      name: "Active profile",
      desc: "Pick which planet or setting profile is used for conversions."
    },
    actions: {
      add: "Add profile",
      delete: "Delete profile"
    },
    fields: {
      profileName: "Profile name",
      hoursPerDay: "Hours per day",
      daysPerWeek: "Days per week",
      daysPerYear: "Days per year",
      epochOffset: "Epoch offset (Earth days)",
      epochLabel: "Epoch label (optional)",
      monthNames: "Month names (comma separated)",
      weekdayNames: "Weekday names (comma separated)"
    },
    preview: {
      heading: "Quick preview (Earth \u2192 local)",
      invalid: "Enter valid values to see a conversion preview.",
      empty: "Add a profile to start configuring planetary time."
    },
    modal: {
      title: "Planetary time converter",
      activeProfile: "Active profile",
      datetimeLabel: "Earth date & time",
      datetimeDesc: "Pick a local date and time to convert.",
      now: "Now",
      convert: "Convert",
      noProfile: "Add a planetary profile in Settings first.",
      disabled: "Enable planetary conversions in settings to use this tool.",
      invalid: "Enter a valid ISO datetime."
    },
    synopsis: { prefix: "Local: " },
    tooltip: { altHint: "Hold Alt/Option to show local time." }
  }
};

// src/i18n/locales/ja.ts
var ja = {
  settings: {
    general: {
      sourcePath: {
        name: "\u30BD\u30FC\u30B9\u30D1\u30B9",
        desc: "\u539F\u7A3F\u30B7\u30FC\u30F3\u30D5\u30A1\u30A4\u30EB\u3092\u542B\u3080\u30EB\u30FC\u30C8\u30D5\u30A9\u30EB\u30C0\u3092\u6307\u5B9A\u3057\u307E\u3059\u3002",
        placeholder: "\u4F8B: \u539F\u7A3F/\u30B7\u30FC\u30F3"
      },
      showTitle: {
        name: "\u30BD\u30FC\u30B9\u30D1\u30B9\u3092\u30BF\u30A4\u30C8\u30EB\u3068\u3057\u3066\u8868\u793A",
        desc: "\u30BD\u30FC\u30B9\u30D5\u30A9\u30EB\u30C0\u540D\u3092\u4F5C\u54C1\u306E\u30BF\u30A4\u30C8\u30EB\u3068\u3057\u3066\u8868\u793A\u3057\u307E\u3059\u3002\u30AA\u30D5\u306E\u5834\u5408\u3001\u300C\u9032\u884C\u4E2D\u306E\u4F5C\u54C1\u300D\u3068\u8868\u793A\u3055\u308C\u307E\u3059\u3002"
      }
    },
    pov: {
      heading: "\u8996\u70B9",
      global: {
        name: "\u30B0\u30ED\u30FC\u30D0\u30EBPOV",
        desc: "\u30AA\u30D7\u30B7\u30E7\u30F3\u3002\u9069\u7528\u3059\u308B\u30C7\u30D5\u30A9\u30EB\u30C8\u30E2\u30FC\u30C9\u3092\u9078\u629E\u3057\u307E\u3059\u3002\u30B7\u30FC\u30F3\u30EC\u30D9\u30EB\u306EPOV\u306F\u3053\u306E\u30B0\u30ED\u30FC\u30D0\u30EB\u8A2D\u5B9A\u3092\u4E0A\u66F8\u304D\u3057\u307E\u3059\u3002"
      },
      modes: {
        off: "\u30EC\u30AC\u30B7\u30FC\uFF08\u6700\u521D\u306B\u30EA\u30B9\u30C8\u3055\u308C\u305F\u30AD\u30E3\u30E9\u30AF\u30BF\u30FC\u3001\u300Cpov\u300D\u4E0A\u4ED8\u304D\u6587\u5B57\uFF09",
        first: "\u4E00\u4EBA\u79F0\u8996\u70B9\uFF08\u30AD\u30E3\u30E9\u30AF\u30BF\u30FC\u306B\xB9\u30DE\u30FC\u30AB\u30FC\uFF09",
        second: "\u4E8C\u4EBA\u79F0\u8996\u70B9\uFF08You\xB2\u30E9\u30D9\u30EB\uFF09",
        third: "\u4E09\u4EBA\u79F0\u9650\u5B9A\u8996\u70B9\uFF08\u30AD\u30E3\u30E9\u30AF\u30BF\u30FC\u306B\xB3\u30DE\u30FC\u30AB\u30FC\uFF09",
        omni: "\u5168\u77E5\u306E\u8A9E\u308A\u624B\uFF08Omni\xB3\u30E9\u30D9\u30EB\uFF09",
        objective: "\u5BA2\u89B3\u8996\u70B9 \u2014 \u30AB\u30E1\u30E9\u30A2\u30A4\u306E\u8A9E\u308A\u624B\uFF08Narrator\xB0\u30E9\u30D9\u30EB\uFF09"
      }
    },
    advanced: {
      heading: "\u8A73\u7D30\u8A2D\u5B9A",
      aiOutputFolder: {
        name: "AI\u51FA\u529B\u30D5\u30A9\u30EB\u30C0",
        desc: "AI\u30ED\u30B0\u3084\u751F\u6210\u30D5\u30A1\u30A4\u30EB\uFF08\u539F\u7A3F\u3001\u30EC\u30DD\u30FC\u30C8\u306A\u3069\uFF09\u3092\u4FDD\u5B58\u3059\u308B\u30D5\u30A9\u30EB\u30C0\u3067\u3059\u3002\u30DC\u30FC\u30EB\u30C8\u5185\u306E\u30D5\u30A9\u30EB\u30C0\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
        placeholder: "AI"
      },
      autoExpand: {
        name: "\u30AF\u30EA\u30C3\u30D7\u3055\u308C\u305F\u30B7\u30FC\u30F3\u30BF\u30A4\u30C8\u30EB\u3092\u81EA\u52D5\u5C55\u958B",
        desc: "\u30B7\u30FC\u30F3\u306B\u30DB\u30D0\u30FC\u3057\u305F\u3068\u304D\u3001\u30BF\u30A4\u30C8\u30EB\u30C6\u30AD\u30B9\u30C8\u304C\u30AF\u30EA\u30C3\u30D7\u3055\u308C\u3066\u3044\u308B\u5834\u5408\u306F\u81EA\u52D5\u7684\u306B\u5C55\u958B\u3057\u307E\u3059\u3002"
      },
      readability: {
        name: "\u53EF\u8AAD\u6027\u30B5\u30A4\u30BA",
        desc: "\u30BF\u30A4\u30E0\u30E9\u30A4\u30F3\u30C6\u30AD\u30B9\u30C8\u306E\u30D5\u30A9\u30F3\u30C8\u30B5\u30A4\u30BA\u30D7\u30ED\u30D5\u30A1\u30A4\u30EB\u3092\u9078\u629E\u3057\u307E\u3059\u3002",
        normal: "\u6A19\u6E96",
        large: "\u5927"
      }
    },
    ai: {
      heading: "\u30B7\u30FC\u30F3\u5206\u6790\u7528AI LLM",
      enable: {
        name: "AI LLM\u6A5F\u80FD\u3092\u6709\u52B9\u306B\u3059\u308B",
        desc: "\u30B3\u30DE\u30F3\u30C9\u30D1\u30EC\u30C3\u30C8\u30AA\u30D7\u30B7\u30E7\u30F3\u3068UI\u30B7\u30FC\u30F3\u5206\u6790\u306E\u8272\u3068\u30DB\u30D0\u30FC\u30B7\u30CE\u30D7\u30B7\u30B9\u3092\u8868\u793A\u3057\u307E\u3059\u3002"
      }
    }
  },
  timeline: {
    acts: {
      act1: "\u7B2C\u4E00\u5E55",
      act2: "\u7B2C\u4E8C\u5E55",
      act3: "\u7B2C\u4E09\u5E55"
    },
    workInProgress: "\u9032\u884C\u4E2D\u306E\u4F5C\u54C1"
  },
  common: {
    yes: "\u306F\u3044",
    no: "\u3044\u3044\u3048",
    cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB",
    save: "\u4FDD\u5B58",
    reset: "\u30EA\u30BB\u30C3\u30C8",
    enable: "\u6709\u52B9",
    disable: "\u7121\u52B9",
    loading: "\u8AAD\u307F\u8FBC\u307F\u4E2D...",
    error: "\u30A8\u30E9\u30FC",
    success: "\u6210\u529F"
  }
};

// src/i18n/index.ts
var locales = {
  en,
  ja
  // ar,
  // de,
};
var cachedLocale = null;
var cachedTranslations = null;
function getCurrentLocale() {
  const locale = import_obsidian28.moment.locale();
  const baseLocale = locale.split("-")[0];
  return baseLocale;
}
function deepMerge(target, source) {
  const result = { ...target };
  for (const key of Object.keys(source)) {
    const sourceVal = source[key];
    const targetVal = target[key];
    if (sourceVal !== void 0) {
      if (typeof sourceVal === "object" && sourceVal !== null && !Array.isArray(sourceVal) && typeof targetVal === "object" && targetVal !== null) {
        result[key] = deepMerge(
          targetVal,
          sourceVal
        );
      } else {
        result[key] = sourceVal;
      }
    }
  }
  return result;
}
function getTranslations() {
  const locale = getCurrentLocale();
  if (cachedLocale === locale && cachedTranslations) {
    return cachedTranslations;
  }
  cachedLocale = locale;
  if (locale === "en" || !locales[locale]) {
    cachedTranslations = en;
  } else {
    cachedTranslations = deepMerge(
      en,
      locales[locale]
    );
  }
  return cachedTranslations;
}
function t(key, vars) {
  const translations = getTranslations();
  const keys = key.split(".");
  let value = translations;
  for (const k of keys) {
    if (value && typeof value === "object" && k in value) {
      value = value[k];
    } else {
      console.warn(`[i18n] Missing translation key: ${key}`);
      return key;
    }
  }
  if (typeof value !== "string") {
    console.warn(`[i18n] Translation key "${key}" is not a string`);
    return key;
  }
  if (vars) {
    let result = value;
    for (const [varKey, varValue] of Object.entries(vars)) {
      result = result.replace(new RegExp(`\\{\\{${varKey}\\}\\}`, "g"), String(varValue));
    }
    return result;
  }
  return value;
}

// src/settings/wikiLink.ts
var import_obsidian29 = require("obsidian");
function addWikiLink(setting, wikiPage) {
  addWikiLinkToElement(setting.nameEl, wikiPage);
}
function addWikiLinkToElement(el, wikiPage) {
  if (!el) return;
  const pageName = wikiPage.replace(/\.md$/, "");
  const link = el.createEl("a", {
    href: `https://github.com/EricRhysTaylor/radial-timeline/wiki/${pageName}`,
    cls: "rt-wiki-link",
    attr: {
      "aria-label": "Read more in the Wiki",
      "target": "_blank",
      "rel": "noopener"
    }
  });
  (0, import_obsidian29.setIcon)(link, "external-link");
}

// src/settings/sections/PublicationSection.ts
function renderPublicationSection(params) {
  const { app, plugin, containerEl } = params;
  const pubHeading = new import_obsidian30.Setting(containerEl).setName("Publication and progress").setHeading();
  addWikiLink(pubHeading, "Settings#publication");
  new import_obsidian30.Setting(containerEl).setName("Target completion date").setDesc("Set a target date for project completion (YYYY-MM-DD). This will be shown on the timeline.").addText((text) => {
    text.inputEl.type = "date";
    text.inputEl.addClass("rt-input-md");
    text.setValue(plugin.settings.targetCompletionDate || "");
    text.onChange(() => {
      text.inputEl.removeClass("rt-setting-input-error");
    });
    plugin.registerDomEvent(text.inputEl, "keydown", (evt) => {
      if (evt.key === "Enter") {
        evt.preventDefault();
        text.inputEl.blur();
      }
    });
    const handleBlur = async () => {
      const value = text.getValue();
      const today = /* @__PURE__ */ new Date();
      today.setHours(0, 0, 0, 0);
      if (!value) {
        plugin.settings.targetCompletionDate = void 0;
        text.inputEl.removeClass("rt-setting-input-error");
        await plugin.saveSettings();
        plugin.refreshTimelineIfNeeded(null);
        return;
      }
      const selectedDate = /* @__PURE__ */ new Date(value + "T00:00:00");
      if (selectedDate > today) {
        plugin.settings.targetCompletionDate = value;
        text.inputEl.removeClass("rt-setting-input-error");
      } else {
        new import_obsidian30.Notice("Target date must be in the future.");
        text.setValue(plugin.settings.targetCompletionDate || "");
        return;
      }
      await plugin.saveSettings();
      plugin.refreshTimelineIfNeeded(null);
    };
    plugin.registerDomEvent(text.inputEl, "blur", () => {
      void handleBlur();
    });
  });
  new import_obsidian30.Setting(containerEl).setName("Zero draft mode").setDesc("Intercept clicks on scenes with Publish Stage = Zero and Status = Complete to capture Pending Edits without opening the scene.").addToggle((toggle) => {
    var _a;
    return toggle.setValue((_a = plugin.settings.enableZeroDraftMode) != null ? _a : false).onChange(async (value) => {
      plugin.settings.enableZeroDraftMode = value;
      await plugin.saveSettings();
    });
  });
  new import_obsidian30.Setting(containerEl).setName(t("settings.advanced.showEstimate.name")).setDesc(t("settings.advanced.showEstimate.desc")).addToggle((toggle) => {
    var _a;
    return toggle.setValue((_a = plugin.settings.showCompletionEstimate) != null ? _a : true).onChange(async (value) => {
      plugin.settings.showCompletionEstimate = value;
      await plugin.saveSettings();
      plugin.refreshTimelineIfNeeded(null);
    });
  });
}

// src/settings/sections/ChronologueSection.ts
var import_obsidian31 = require("obsidian");
init_date();
async function collectDurationCapOptions(plugin) {
  let scenes = plugin.lastSceneData;
  if (!Array.isArray(scenes) || scenes.length === 0) {
    try {
      scenes = await plugin.getSceneData();
    } catch (e) {
      return [];
    }
  }
  const dedupeKeys = /* @__PURE__ */ new Set();
  const optionsMap = /* @__PURE__ */ new Map();
  (scenes != null ? scenes : []).forEach((scene) => {
    var _a;
    if (scene.itemType === "Beat" || scene.itemType === "Plot") return;
    const identifier = scene.path || `${(_a = scene.title) != null ? _a : ""}|${scene.date}`;
    if (!identifier || dedupeKeys.has(identifier)) return;
    dedupeKeys.add(identifier);
    const detail = parseDurationDetail(scene.Duration);
    if (!detail) return;
    const key = `${detail.value}|${detail.unitKey}`;
    const unitLabel = detail.value === 1 ? detail.unitSingular : detail.unitPlural;
    const label = `${detail.valueText} ${unitLabel}`;
    const existing = optionsMap.get(key);
    if (existing) {
      existing.count += 1;
    } else {
      optionsMap.set(key, { label, count: 1, ms: detail.ms });
    }
  });
  return Array.from(optionsMap.entries()).map(([key, data]) => ({
    key,
    label: data.label,
    count: data.count,
    ms: data.ms
  })).sort((a, b) => a.ms - b.ms);
}
function renderChronologueSection(params) {
  var _a;
  const { app, plugin, containerEl } = params;
  const chronoHeading = new import_obsidian31.Setting(containerEl).setName("Chronologue mode settings").setHeading();
  addWikiLink(chronoHeading, "Settings#chronologue");
  const baseDurationDesc = "Scenes with durations at or above the selected value fill the entire segment. All other durations below this are proportionally scaled.";
  const durationSetting = new import_obsidian31.Setting(containerEl).setName("Chronologue duration arc cap").setDesc(baseDurationDesc);
  const savedCapSelection = (_a = plugin.settings.chronologueDurationCapSelection) != null ? _a : "auto";
  let durationDropdown;
  durationSetting.addDropdown((dropdown) => {
    durationDropdown = dropdown;
    dropdown.addOption("auto", "Longest observed duration (auto)");
    dropdown.setValue(savedCapSelection);
    dropdown.onChange(async (value) => {
      plugin.settings.chronologueDurationCapSelection = value;
      await plugin.saveSettings();
      plugin.refreshTimelineIfNeeded(null);
    });
    dropdown.selectEl.style.setProperty("width", "250px", "important");
    dropdown.selectEl.style.setProperty("min-width", "250px", "important");
    dropdown.selectEl.style.setProperty("max-width", "250px", "important");
  });
  collectDurationCapOptions(plugin).then((options) => {
    const dropdown = durationDropdown;
    if (!dropdown) return;
    if (options.length === 0) {
      durationSetting.setDesc(`${baseDurationDesc} No scene durations detected yet.`);
    } else {
      options.forEach((opt) => {
        if (!dropdown.selectEl.querySelector(`option[value="${opt.key}"]`)) {
          dropdown.addOption(opt.key, `${opt.label} (${opt.count})`);
        }
      });
    }
    if (savedCapSelection !== "auto" && dropdown.selectEl.querySelector(`option[value="${savedCapSelection}"]`) === null) {
      const fallbackLabel = formatDurationSelectionLabel(savedCapSelection);
      if (fallbackLabel) {
        dropdown.addOption(savedCapSelection, `${fallbackLabel} (0)`);
      }
    }
    dropdown.setValue(savedCapSelection);
  }).catch(() => {
    if (!durationDropdown) return;
    durationSetting.setDesc(`${baseDurationDesc} Unable to load duration data.`);
  });
  const getScenesForThreshold = async () => {
    if (Array.isArray(plugin.lastSceneData) && plugin.lastSceneData.length > 0) {
      return plugin.lastSceneData;
    }
    try {
      const fetched = await plugin.getSceneData();
      if (Array.isArray(fetched) && fetched.length > 0) {
        plugin.lastSceneData = fetched;
        return fetched;
      }
      return [];
    } catch (err) {
      console.error("[Settings] Failed to load scenes for discontinuity threshold:", err);
      return [];
    }
  };
  const calculateAutoThreshold = async () => {
    try {
      const scenes = await getScenesForThreshold();
      const thresholdMs = calculateAutoDiscontinuityThreshold(scenes);
      if (thresholdMs === null) {
        return { display: "not yet calculated", days: null };
      }
      const minutes = thresholdMs / (60 * 1e3);
      const hours = thresholdMs / (60 * 60 * 1e3);
      const days = thresholdMs / (24 * 60 * 60 * 1e3);
      let display;
      if (days >= 1) {
        display = `${Math.round(days)} ${Math.round(days) === 1 ? "day" : "days"}`;
      } else if (hours >= 1) {
        display = `${Math.round(hours)} ${Math.round(hours) === 1 ? "hour" : "hours"}`;
      } else {
        display = `${Math.round(minutes)} ${Math.round(minutes) === 1 ? "minute" : "minutes"}`;
      }
      return { display, days: Math.round(days * 100) / 100 };
    } catch (err) {
      console.error("[Settings] Error calculating threshold:", err);
      return { display: "not yet calculated", days: null };
    }
  };
  const discontinuitySetting = new import_obsidian31.Setting(containerEl).setName("Discontinuity gap threshold");
  let discontinuityText;
  const updateDescriptionAndPlaceholder = async () => {
    const autoThreshold = await calculateAutoThreshold();
    discontinuitySetting.setDesc(`In shift mode, the \u221E symbol marks large time gaps between scenes. By default, this is auto-calculated as 3\xD7 the median gap between scenes. Current auto value: ${autoThreshold.display}. You can override this with a custom gap threshold (e.g., "4 days", "1 week", "30 minutes").`);
    if (discontinuityText) {
      const currentValue = plugin.settings.discontinuityThreshold || "";
      discontinuityText.setPlaceholder(`${autoThreshold.display} (auto)`);
      if (!currentValue) {
        discontinuityText.setValue("");
      }
    }
  };
  void updateDescriptionAndPlaceholder();
  discontinuitySetting.addText((text) => {
    discontinuityText = text;
    const currentValue = plugin.settings.discontinuityThreshold || "";
    text.setPlaceholder("Calculating\u2026").setValue(currentValue);
    text.inputEl.addClass("rt-input-sm");
    void calculateAutoThreshold().then((autoThreshold) => {
      text.setPlaceholder(`${autoThreshold.display} (auto)`);
      if (!currentValue) {
        text.setValue("");
      }
    });
    const handleBlur = async () => {
      const trimmed = text.getValue().trim();
      text.inputEl.removeClass("rt-setting-input-success");
      text.inputEl.removeClass("rt-setting-input-error");
      if (!trimmed) {
        plugin.settings.discontinuityThreshold = void 0;
        await plugin.saveSettings();
        plugin.refreshTimelineIfNeeded(null);
        return;
      }
      const parsed = parseDurationDetail(trimmed);
      if (!parsed) {
        text.inputEl.addClass("rt-setting-input-error");
        new import_obsidian31.Notice('Invalid gap threshold format. Examples: "4 days", "1 week", "2 months"');
        return;
      }
      plugin.settings.discontinuityThreshold = trimmed;
      text.inputEl.addClass("rt-setting-input-success");
      await plugin.saveSettings();
      plugin.refreshTimelineIfNeeded(null);
      window.setTimeout(() => {
        text.inputEl.removeClass("rt-setting-input-success");
      }, 1e3);
    };
    plugin.registerDomEvent(text.inputEl, "blur", () => {
      void handleBlur();
    });
  });
  discontinuitySetting.addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to auto-calculated threshold").onClick(async () => {
    plugin.settings.discontinuityThreshold = void 0;
    await plugin.saveSettings();
    plugin.refreshTimelineIfNeeded(null);
    if (discontinuityText) {
      discontinuityText.setValue("");
      discontinuityText.inputEl.removeClass("rt-setting-input-error");
      discontinuityText.inputEl.removeClass("rt-setting-input-success");
    }
    new import_obsidian31.Notice("Discontinuity threshold reset to auto-calculated value");
  }));
}

// src/settings/sections/TemplatesSection.ts
var import_obsidian34 = require("obsidian");

// src/modals/CreateBeatsTemplatesModal.ts
var import_obsidian32 = require("obsidian");
var CreateBeatsTemplatesModal = class extends import_obsidian32.Modal {
  constructor(app, plugin, beatSystem, beatCount) {
    super(app);
    this.resolve = null;
    this.plugin = plugin;
    if (beatSystem === "Custom" && this.plugin.settings.customBeatSystemName) {
      this.beatSystem = this.plugin.settings.customBeatSystemName;
    } else {
      this.beatSystem = beatSystem;
    }
    this.beatCount = beatCount;
  }
  onOpen() {
    const { contentEl, modalEl, titleEl } = this;
    contentEl.empty();
    titleEl.setText("");
    if (modalEl) {
      modalEl.classList.add("rt-modal-shell");
      modalEl.style.width = "620px";
      modalEl.style.maxWidth = "92vw";
    }
    contentEl.addClass("rt-modal-container");
    contentEl.addClass("rt-create-plot-templates-modal");
    const header = contentEl.createDiv({ cls: "rt-modal-header" });
    header.createSpan({ cls: "rt-modal-badge", text: "Setup" });
    header.createDiv({ cls: "rt-modal-title", text: "Create beat template notes" });
    header.createDiv({ cls: "rt-modal-subtitle", text: `This will create ${this.beatCount} beat notes for "${this.beatSystem}".` });
    const card = contentEl.createDiv({ cls: "rt-glass-card" });
    card.createDiv({ cls: "rt-sub-card-note", text: "Each beat note will have the following YAML structure:" });
    const exampleCode = card.createEl("pre", { cls: "rt-code-block" });
    exampleCode.textContent = `---
Class: Beat
Act: 1
Description: [Beat description]
Beat Model: ${this.beatSystem}
Range: [Ideal momentum range]
Gossamer1:
---`;
    const sourcePath = this.plugin.settings.sourcePath.trim();
    const locationText = sourcePath ? `Notes will be created in: ${sourcePath}/` : "Notes will be created in the vault root (no source path set)";
    card.createDiv({ cls: "rt-sub-card-note", text: locationText });
    const buttonContainer = contentEl.createDiv({ cls: "rt-modal-actions" });
    new import_obsidian32.ButtonComponent(buttonContainer).setButtonText(`Create ${this.beatCount} notes`).setCta().onClick(() => {
      if (this.resolve) {
        this.resolve({ confirmed: true });
      }
      this.close();
    });
    new import_obsidian32.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => {
      if (this.resolve) {
        this.resolve({ confirmed: false });
      }
      this.close();
    });
  }
  waitForConfirmation() {
    return new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.resolve) {
      this.resolve({ confirmed: false });
    }
  }
};

// src/settings/sections/TemplatesSection.ts
init_beatsSystems();
init_defaults();

// src/settings/sections/MetadataSection.ts
var import_obsidian33 = require("obsidian");
var CANONICAL_KEYS = [
  "Class",
  "When",
  "Subplot",
  "Act",
  "Duration",
  "Character",
  "POV",
  "Place",
  "Synopsis",
  "Status",
  "Publish Stage",
  "Due",
  "Pending Edits",
  "Beat Model",
  "Range",
  "Description"
].sort();
var ALL_CANONICAL_KEYS = CANONICAL_KEYS;
function renderMetadataSection(params) {
  const { app, plugin, containerEl } = params;
  const pendingMappings = [];
  let nextPendingId = 1;
  new import_obsidian33.Setting(containerEl).setName("Custom Metadata Mapping").setDesc("Map your custom frontmatter keys to Radial Timeline keys. Useful for pre-existing vaults.").addToggle((toggle) => {
    var _a;
    toggle.setValue((_a = plugin.settings.enableCustomMetadataMapping) != null ? _a : false).onChange(async (value) => {
      plugin.settings.enableCustomMetadataMapping = value;
      await plugin.saveSettings();
      renderMappings();
    });
  });
  const mappingContainer = containerEl.createDiv({ cls: "rt-mapping-body" });
  const mappingListContainer = mappingContainer.createDiv({ cls: "rt-mapping-list" });
  const renderMappings = () => {
    if (!plugin.settings.enableCustomMetadataMapping) {
      mappingContainer.addClass("rt-settings-hidden");
      mappingListContainer.addClass("rt-mapping-hidden");
      mappingListContainer.empty();
      return;
    }
    mappingContainer.removeClass("rt-settings-hidden");
    mappingListContainer.removeClass("rt-mapping-hidden");
    mappingListContainer.empty();
    const mappings = plugin.settings.frontmatterMappings || {};
    const usedCanonicalKeys = new Set(Object.values(mappings));
    for (const [userKey, systemKey] of Object.entries(mappings)) {
      const setting = new import_obsidian33.Setting(mappingListContainer);
      setting.addText((text) => {
        text.setPlaceholder("Your Key (e.g. StoryLine)").setValue(userKey).onChange(async (_newValue) => {
        });
        text.inputEl.addEventListener("blur", async () => {
          const newValue = text.getValue().trim();
          if (newValue && newValue !== userKey) {
            if (!plugin.settings.frontmatterMappings) plugin.settings.frontmatterMappings = {};
            delete plugin.settings.frontmatterMappings[userKey];
            plugin.settings.frontmatterMappings[newValue] = systemKey;
            await plugin.saveSettings();
            renderMappings();
          } else if (!newValue) {
            text.setValue(userKey);
          }
        });
      });
      setting.addDropdown((dropdown) => {
        dropdown.addOption(systemKey, systemKey);
        ALL_CANONICAL_KEYS.forEach((key) => {
          if (key !== systemKey && !usedCanonicalKeys.has(key)) {
            dropdown.addOption(key, key);
          }
        });
        dropdown.setValue(systemKey);
        dropdown.onChange(async (newValue) => {
          if (plugin.settings.frontmatterMappings) {
            plugin.settings.frontmatterMappings[userKey] = newValue;
            await plugin.saveSettings();
            renderMappings();
          }
        });
      });
      setting.addButton((button) => button.setIcon("trash").setTooltip("Delete Mapping").onClick(async () => {
        if (plugin.settings.frontmatterMappings) {
          delete plugin.settings.frontmatterMappings[userKey];
          await plugin.saveSettings();
          renderMappings();
        }
      }));
    }
    for (const pending of pendingMappings) {
      const setting = new import_obsidian33.Setting(mappingListContainer);
      setting.addText((text) => {
        text.setPlaceholder("Your Key (required to save)");
        text.setValue("");
        plugin.registerDomEvent(text.inputEl, "blur", async () => {
          const newValue = text.getValue().trim();
          if (!newValue) {
            return;
          }
          if (!plugin.settings.frontmatterMappings) {
            plugin.settings.frontmatterMappings = {};
          }
          plugin.settings.frontmatterMappings[newValue] = pending.systemKey;
          const idx = pendingMappings.indexOf(pending);
          if (idx >= 0) pendingMappings.splice(idx, 1);
          await plugin.saveSettings();
          renderMappings();
        });
      });
      setting.addDropdown((dropdown) => {
        const usedCanonicalKeysForDraft = /* @__PURE__ */ new Set([
          ...Object.values(mappings),
          ...pendingMappings.filter((p) => p !== pending).map((p) => p.systemKey)
        ]);
        dropdown.addOption(pending.systemKey, pending.systemKey);
        ALL_CANONICAL_KEYS.forEach((key) => {
          if (key !== pending.systemKey && !usedCanonicalKeysForDraft.has(key)) {
            dropdown.addOption(key, key);
          }
        });
        dropdown.setValue(pending.systemKey);
        dropdown.onChange((newValue) => {
          pending.systemKey = newValue;
          renderMappings();
        });
      });
      setting.addButton((button) => button.setIcon("trash").setTooltip("Discard Draft").onClick(() => {
        const idx = pendingMappings.indexOf(pending);
        if (idx >= 0) pendingMappings.splice(idx, 1);
        renderMappings();
      }));
    }
    new import_obsidian33.Setting(mappingListContainer).addButton((button) => button.setButtonText("Add New Mapping").onClick(async () => {
      const currentUsed = /* @__PURE__ */ new Set([
        ...Object.values(plugin.settings.frontmatterMappings || {}),
        ...pendingMappings.map((pending) => pending.systemKey)
      ]);
      const firstAvailable = ALL_CANONICAL_KEYS.find((k) => !currentUsed.has(k));
      if (!firstAvailable) {
        new import_obsidian33.Notice("All supported system keys are already mapped.");
        return;
      }
      pendingMappings.push({ id: nextPendingId++, systemKey: firstAvailable });
      renderMappings();
    }));
  };
  renderMappings();
}

// src/settings/sections/TemplatesSection.ts
function renderStoryBeatsSection(params) {
  const { app, plugin, containerEl } = params;
  const actsHeading = new import_obsidian34.Setting(containerEl).setName("Acts").setHeading();
  addWikiLink(actsHeading, "Settings#acts");
  const getActCount = () => {
    var _a;
    return Math.max(3, (_a = plugin.settings.actCount) != null ? _a : 3);
  };
  const getActPreviewLabels = () => {
    var _a, _b;
    const count = getActCount();
    const raw = (_a = plugin.settings.actLabelsRaw) != null ? _a : "";
    const labels = raw.split(",").map((l) => l.trim()).filter(Boolean).slice(0, count);
    const showLabels = (_b = plugin.settings.showActLabels) != null ? _b : true;
    return Array.from({ length: count }, (_, idx) => {
      if (!showLabels) return `${idx + 1}`;
      return labels[idx] && labels[idx].length > 0 ? labels[idx] : `Act ${idx + 1}`;
    });
  };
  const updateActPreview = () => {
    const previewLabels = getActPreviewLabels();
    actsPreviewHeading.setText(`Preview (${previewLabels.length} acts)`);
    actsPreviewBody.setText(previewLabels.join(" \xB7 "));
  };
  new import_obsidian34.Setting(containerEl).setName("Act count").setDesc("Applies to Narrative, Subplot, and Gossamer modes. Scene and Beats YAML. (Minimum 3)").addText((text) => {
    text.setPlaceholder("3");
    text.setValue(String(getActCount()));
    text.inputEl.type = "number";
    text.inputEl.min = "3";
    text.inputEl.addClass("rt-input-xs");
    text.onChange(async (value) => {
      const parsed = parseInt(value, 10);
      const next = Number.isFinite(parsed) ? Math.max(3, parsed) : 3;
      plugin.settings.actCount = next;
      await plugin.saveSettings();
      updateActPreview();
    });
  });
  const actLabelsSetting = new import_obsidian34.Setting(containerEl).setName("Act labels (optional)").setDesc("Comma-separated labels. Extra labels are ignored; empty slots fall back to numbers.").addTextArea((text) => {
    var _a;
    text.setValue((_a = plugin.settings.actLabelsRaw) != null ? _a : "Act 1, Act 2, Act 3");
    text.inputEl.rows = 3;
    text.onChange(async (value) => {
      plugin.settings.actLabelsRaw = value;
      await plugin.saveSettings();
      updateActPreview();
    });
  });
  actLabelsSetting.settingEl.addClass("rt-setting-full-width-input");
  new import_obsidian34.Setting(containerEl).setName("Show act labels").setDesc("When off, acts show numbers only.").addToggle((toggle) => {
    var _a;
    toggle.setValue((_a = plugin.settings.showActLabels) != null ? _a : true);
    toggle.onChange(async (value) => {
      plugin.settings.showActLabels = value;
      await plugin.saveSettings();
      updateActPreview();
    });
  });
  const actsPreview = containerEl.createDiv({ cls: "rt-planetary-preview rt-acts-preview" });
  const actsPreviewHeading = actsPreview.createDiv({ cls: "rt-planetary-preview-heading", text: "Preview" });
  const actsPreviewBody = actsPreview.createDiv({ cls: "rt-planetary-preview-body rt-acts-preview-body" });
  updateActPreview();
  const beatsHeading = new import_obsidian34.Setting(containerEl).setName("Story beats system").setHeading();
  addWikiLink(beatsHeading, "Settings#story-beats");
  const beatSystemSetting = new import_obsidian34.Setting(containerEl).setName("Story beats system").setDesc("Select the story structure model for your manuscript. This will establish the story beat system and can be used to create beat notes and graph scores using Gossamer mode.").addDropdown((dropdown) => {
    dropdown.addOption("Save The Cat", "Save The Cat (15 beats)").addOption("Hero's Journey", "Hero's Journey (12 beats)").addOption("Story Grid", "Story Grid (5 Commandments)").addOption("Custom", "Custom (User defined beat structure)").setValue(plugin.settings.beatSystem || "Custom").onChange(async (value) => {
      plugin.settings.beatSystem = value;
      await plugin.saveSettings();
      updateStoryStructureDescription(storyStructureInfo, value);
      updateTemplateButton(templateSetting, value);
      updateCustomInputsVisibility(value);
    });
    dropdown.selectEl.style.minWidth = "200px";
  });
  beatSystemSetting.settingEl.classList.add("rt-setting-two-row");
  beatSystemSetting.settingEl.style.setProperty("display", "grid", "important");
  beatSystemSetting.settingEl.style.gridTemplateColumns = "1fr auto";
  beatSystemSetting.settingEl.style.gridTemplateRows = "auto auto";
  beatSystemSetting.controlEl.style.setProperty("align-self", "flex-start", "important");
  beatSystemSetting.controlEl.style.marginTop = "6px";
  const storyStructureInfo = beatSystemSetting.settingEl.createDiv({
    cls: "rt-story-structure-info setting-item-description"
  });
  storyStructureInfo.style.gridColumn = "1 / 3";
  storyStructureInfo.style.gridRow = "2 / 3";
  storyStructureInfo.style.marginTop = "8px";
  storyStructureInfo.style.marginBottom = "0";
  updateStoryStructureDescription(storyStructureInfo, plugin.settings.beatSystem || "Custom");
  const customConfigContainer = containerEl.createDiv({ cls: "rt-custom-beat-config" });
  const renderCustomConfig = () => {
    customConfigContainer.empty();
    new import_obsidian34.Setting(customConfigContainer).setName("Custom story beat system").setDesc('The name of your custom beat system (e.g. "7 Point Structure"). Assigned to the "Beat Model" field in YAML. Drag to reorder beats.').addText((text) => text.setPlaceholder("Custom").setValue(plugin.settings.customBeatSystemName || "Custom").then((t2) => {
      t2.inputEl.addClass("rt-input-md");
      return t2;
    }).onChange(async (value) => {
      plugin.settings.customBeatSystemName = value;
      await plugin.saveSettings();
      updateTemplateButton(templateSetting, "Custom");
    }));
    const beatWrapper = customConfigContainer.createDiv({ cls: "rt-custom-beat-wrapper" });
    const listContainer = beatWrapper.createDiv({ cls: "rt-custom-beat-list" });
    const parseBeatRow = (item) => {
      var _a;
      if (typeof item === "object" && item !== null && item.name) {
        const obj = item;
        const objName = typeof obj.name === "string" ? obj.name : String((_a = obj.name) != null ? _a : "");
        const objAct = typeof obj.act === "number" ? obj.act : 1;
        return { name: objName, act: objAct };
      }
      const raw = String(item != null ? item : "").trim();
      if (!raw) return { name: "", act: 1 };
      const m = raw.match(/^(.*?)\[(\d+)\]$/);
      if (m) {
        const actNum = parseInt(m[2], 10);
        return { name: m[1].trim(), act: !Number.isNaN(actNum) ? actNum : 1 };
      }
      return { name: raw, act: 1 };
    };
    const saveBeats = async (beats) => {
      plugin.settings.customBeatSystemBeats = beats;
      await plugin.saveSettings();
      updateTemplateButton(templateSetting, "Custom");
    };
    const buildActLabels = (count) => {
      var _a, _b;
      const raw = (_a = plugin.settings.actLabelsRaw) != null ? _a : "";
      const showLabels = (_b = plugin.settings.showActLabels) != null ? _b : true;
      const labels = raw.split(",").map((l) => l.trim()).filter(Boolean);
      return Array.from({ length: count }, (_, idx) => {
        if (!showLabels) return `Act ${idx + 1}`;
        return labels[idx] && labels[idx].length > 0 ? labels[idx] : `Act ${idx + 1}`;
      });
    };
    const clampAct = (val, maxActs) => {
      const n = Number.isFinite(val) ? val : 1;
      return Math.min(Math.max(1, n), maxActs);
    };
    const renderList = () => {
      listContainer.empty();
      const maxActs = getActCount();
      const actLabels = buildActLabels(maxActs);
      const beats = (plugin.settings.customBeatSystemBeats || []).map(parseBeatRow).map((b) => ({ ...b, act: clampAct(b.act, maxActs) }));
      beats.forEach((beatLine, index) => {
        const row = listContainer.createDiv({ cls: "rt-custom-beat-row" });
        row.draggable = true;
        const handle = row.createDiv({ cls: "rt-drag-handle" });
        (0, import_obsidian34.setIcon)(handle, "grip-vertical");
        (0, import_obsidian34.setTooltip)(handle, "Drag to reorder beat");
        row.createDiv({ cls: "rt-grid-spacer" });
        const idxEl = row.createDiv({ text: `${index + 1}.`, cls: "rt-beat-index" });
        idxEl.style.minWidth = "24px";
        let name = beatLine.name;
        let act = clampAct(beatLine.act, maxActs).toString();
        const nameInput = row.createEl("input", { type: "text", cls: "rt-beat-name-input rt-template-input" });
        nameInput.value = name;
        nameInput.placeholder = "Beat name";
        plugin.registerDomEvent(nameInput, "change", () => {
          const newName = nameInput.value.trim();
          if (!newName) return;
          const updated = [...beats];
          updated[index] = { name: newName, act: parseInt(act, 10) || 1 };
          saveBeats(updated);
          renderList();
        });
        const actSelect = row.createEl("select", { cls: "rt-beat-act-select rt-template-input" });
        Array.from({ length: maxActs }, (_, i) => i + 1).forEach((n) => {
          const opt = actSelect.createEl("option", { value: n.toString(), text: actLabels[n - 1] });
          if (act === n.toString()) opt.selected = true;
        });
        plugin.registerDomEvent(actSelect, "change", () => {
          act = actSelect.value;
          const updated = [...beats];
          const currentName = nameInput.value.trim() || name;
          const actNum = clampAct(parseInt(act, 10) || 1, maxActs);
          updated[index] = { name: currentName, act: actNum };
          saveBeats(updated);
          renderList();
        });
        const delBtn = row.createEl("button", { cls: "rt-template-icon-btn" });
        (0, import_obsidian34.setIcon)(delBtn, "trash");
        delBtn.onclick = () => {
          const updated = [...beats];
          updated.splice(index, 1);
          saveBeats(updated);
          renderList();
        };
        plugin.registerDomEvent(row, "dragstart", (e) => {
          var _a;
          (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", index.toString());
          row.classList.add("rt-dragging");
        });
        plugin.registerDomEvent(row, "dragend", () => {
          row.classList.remove("rt-dragging");
        });
        plugin.registerDomEvent(row, "dragover", (e) => {
          e.preventDefault();
        });
        plugin.registerDomEvent(row, "drop", (e) => {
          var _a;
          e.preventDefault();
          const from = parseInt(((_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain")) || "-1", 10);
          if (Number.isNaN(from) || from === index || from < 0) return;
          const updated = [...beats];
          const [moved] = updated.splice(from, 1);
          updated.splice(index, 0, moved);
          saveBeats(updated);
          renderList();
        });
      });
      const defaultAct = beats.length > 0 ? clampAct(beats[beats.length - 1].act, maxActs) : 1;
      const addRow = listContainer.createDiv({ cls: "rt-custom-beat-row rt-custom-beat-add-row" });
      addRow.createDiv({ cls: "rt-drag-handle rt-drag-placeholder" });
      addRow.createDiv({ cls: "rt-grid-spacer" });
      addRow.createDiv({ cls: "rt-beat-index rt-beat-add-index", text: "" });
      const addNameInput = addRow.createEl("input", { type: "text", cls: "rt-beat-name-input rt-template-input", placeholder: "New beat" });
      const addActSelect = addRow.createEl("select", { cls: "rt-beat-act-select rt-template-input" });
      Array.from({ length: maxActs }, (_, i) => i + 1).forEach((n) => {
        const opt = addActSelect.createEl("option", { value: n.toString(), text: actLabels[n - 1] });
        if (defaultAct === n) opt.selected = true;
      });
      const addBtn = addRow.createEl("button", { cls: "rt-beat-add-btn", attr: { "aria-label": "Add beat" } });
      (0, import_obsidian34.setIcon)(addBtn, "plus");
      const commitAdd = () => {
        const name = (addNameInput.value || "New Beat").trim();
        const act = clampAct(parseInt(addActSelect.value, 10) || defaultAct || 1, maxActs);
        const updated = [...beats, { name, act }];
        saveBeats(updated);
        renderList();
      };
      addBtn.onclick = commitAdd;
      plugin.registerDomEvent(addNameInput, "keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          commitAdd();
        }
      });
    };
    renderList();
  };
  renderCustomConfig();
  const updateCustomInputsVisibility = (system) => {
    if (system === "Custom") {
      customConfigContainer.style.display = "block";
    } else {
      customConfigContainer.style.display = "none";
    }
  };
  updateCustomInputsVisibility(plugin.settings.beatSystem || "Custom");
  const templateSetting = new import_obsidian34.Setting(containerEl).setName("Create story beat template notes").setDesc("Generate template beat notes based on the selected story structure system including YAML frontmatter and body summary.").addButton((button) => button.setButtonText("Create templates").setTooltip("Creates story beat note templates in your source path").onClick(async () => {
    await createBeatTemplates();
  }));
  updateTemplateButton(templateSetting, plugin.settings.beatSystem || "Custom");
  const yamlHeading = new import_obsidian34.Setting(containerEl).setName("Scene YAML templates & remapping").setHeading();
  addWikiLink(yamlHeading, "Settings#yaml-templates");
  const remapContainer = containerEl.createDiv();
  renderMetadataSection({ app, plugin, containerEl: remapContainer });
  let onAdvancedToggle;
  new import_obsidian34.Setting(containerEl).setName("Advanced YAML editor").setDesc("Enable editing of custom YAML keys for the advanced scene template.").addExtraButton((button) => {
    const refreshButton = () => {
      var _a;
      const expanded = (_a = plugin.settings.enableAdvancedYamlEditor) != null ? _a : false;
      button.setIcon("chevrons-up-down");
      button.setTooltip(expanded ? "Hide advanced YAML editor" : "Show advanced YAML editor");
    };
    refreshButton();
    button.onClick(async () => {
      var _a;
      const next = !((_a = plugin.settings.enableAdvancedYamlEditor) != null ? _a : false);
      plugin.settings.enableAdvancedYamlEditor = next;
      refreshButton();
      await plugin.saveSettings();
      onAdvancedToggle == null ? void 0 : onAdvancedToggle();
    });
  });
  const templateSection = containerEl.createDiv({ cls: "rt-scene-template-editor" });
  const advancedContainer = templateSection.createDiv({ cls: "rt-advanced-template-card" });
  const renderAdvancedTemplateEditor = () => {
    var _a, _b, _c;
    advancedContainer.empty();
    const isEnabled = (_a = plugin.settings.enableAdvancedYamlEditor) != null ? _a : false;
    advancedContainer.toggleClass("rt-settings-hidden", !isEnabled);
    if (!isEnabled) return;
    const defaultTemplate = DEFAULT_SETTINGS.sceneYamlTemplates.advanced;
    const currentTemplate = (_c = (_b = plugin.settings.sceneYamlTemplates) == null ? void 0 : _b.advanced) != null ? _c : "";
    const baseTemplate = DEFAULT_SETTINGS.sceneYamlTemplates.base;
    const requiredOrder = extractKeysInOrder(baseTemplate);
    const defaultObj = safeParseYaml(defaultTemplate);
    const currentObj = safeParseYaml(currentTemplate);
    const requiredValues = {};
    requiredOrder.forEach((key) => {
      var _a2, _b2;
      requiredValues[key] = (_b2 = (_a2 = currentObj[key]) != null ? _a2 : defaultObj[key]) != null ? _b2 : "";
    });
    if (!requiredValues["Class"]) {
      requiredValues["Class"] = "Scene";
    }
    const optionalOrder = mergeOrders(
      extractKeysInOrder(currentTemplate).filter((k) => !requiredOrder.includes(k)),
      extractKeysInOrder(defaultTemplate).filter((k) => !requiredOrder.includes(k))
    );
    const entries = optionalOrder.map((key) => {
      var _a2, _b2;
      const value = (_b2 = (_a2 = currentObj[key]) != null ? _a2 : defaultObj[key]) != null ? _b2 : "";
      return { key, value, required: false };
    });
    let workingEntries = entries;
    let dragIndex = null;
    const advancedComments = {
      Duration: 'Free text duration (e.g., "45 minutes", "2 hours", "PT45M")',
      "Reader Emotion": "Describe the intended reader emotion"
    };
    const guessTypeIcon = (raw) => {
      const value = raw.trim();
      if (!value) return null;
      const isBool = /^(true|false)$/i.test(value);
      if (isBool) return "check";
      const isNumber = /^-?\d+(\.\d+)?$/.test(value);
      if (isNumber) return "hash";
      const isIsoDateTime = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}(:\d{2})?$/.test(value);
      if (isIsoDateTime) return "calendar-clock";
      const isIsoDate = /^\d{4}-\d{2}-\d{2}$/.test(value);
      if (isIsoDate) return "calendar";
      const isTime = /^\d{1,2}:\d{2}(:\d{2})?$/.test(value);
      if (isTime) return "clock";
      const isList = value.includes(",");
      if (isList) return "list";
      const isDuration = /^\d+\s*(s|sec|secs|seconds|m|min|mins|minutes|h|hr|hrs|hours|d|day|days|wk|wks|weeks)$/i.test(value);
      if (isDuration) return "timer";
      return "type";
    };
    const guessYamlHint = (raw) => {
      const value = raw.trim();
      if (!value) return null;
      const boolMatch = /^(true|false)$/i;
      const numberMatch = /^-?\d+(\.\d+)?$/;
      const isoDate = /^\d{4}-\d{2}-\d{2}$/;
      const isoDateTime = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}(:\d{2})?$/;
      const shortDate = /^\d{1,2}\/\d{1,2}(\/\d{2,4})?$/;
      const partialDate = /[/-]/;
      const timeOnly = /^\d{1,2}:\d{2}(:\d{2})?$/;
      const partialTime = /:\d?$/;
      const durationMatch = /^\d+\s*(s|sec|secs|seconds|m|min|mins|minutes|h|hr|hrs|hours|d|day|days|wk|wks|weeks)$/i;
      if (boolMatch.test(value)) return "Boolean: Use true/false.";
      if (numberMatch.test(value)) return "Number: 42 or 3.14";
      if (isoDateTime.test(value)) return "Datetime: YYYY-MM-DDTHH:MM";
      if (isoDate.test(value)) return "Date: YYYY-MM-DD (e.g., 2025-07-23)";
      if (shortDate.test(value) || partialDate.test(value)) return "Looks like a date. Prefer ISO: 2025-07-23 or 2025-07-23T14:30";
      if (timeOnly.test(value) || partialTime.test(value)) return "Time: Use HH:MM or full ISO timestamp 2025-07-23T14:30";
      if (durationMatch.test(value)) return "Duration: text like 45 minutes or ISO PT45M";
      if (value.includes(",")) return "Multiple values? YAML list example:\\n- Item 1\\n- Item 2";
      return null;
    };
    const attachHint = (inputEl, hintEl, rowEl) => {
      const applyHint = () => {
        const hint = guessYamlHint(inputEl.value);
        if (hint) {
          hintEl.removeClass("rt-template-hint-hidden");
          hintEl.setText(hint);
          inputEl.setAttribute("title", hint);
          rowEl == null ? void 0 : rowEl.addClass("rt-template-hint-row");
        } else {
          hintEl.addClass("rt-template-hint-hidden");
          hintEl.setText("");
          inputEl.removeAttribute("title");
          rowEl == null ? void 0 : rowEl.removeClass("rt-template-hint-row");
        }
      };
      plugin.registerDomEvent(inputEl, "input", applyHint);
      applyHint();
    };
    const attachTypeIcon = (inputEl, iconEl) => {
      const applyIcon = () => {
        const icon = guessTypeIcon(inputEl.value);
        if (icon) (0, import_obsidian34.setIcon)(iconEl, icon);
      };
      plugin.registerDomEvent(inputEl, "input", applyIcon);
      applyIcon();
    };
    const saveEntries = (nextEntries) => {
      workingEntries = nextEntries;
      const yaml = buildYamlWithRequired(requiredOrder, requiredValues, nextEntries, advancedComments);
      if (!plugin.settings.sceneYamlTemplates) plugin.settings.sceneYamlTemplates = { base: DEFAULT_SETTINGS.sceneYamlTemplates.base, advanced: "" };
      plugin.settings.sceneYamlTemplates.advanced = yaml;
      void plugin.saveSettings();
    };
    const rerender = (next) => {
      const data = next != null ? next : workingEntries;
      workingEntries = data;
      advancedContainer.empty();
      advancedContainer.toggleClass("rt-settings-hidden", !isEnabled);
      if (!isEnabled) return;
      const listEl = advancedContainer.createDiv({ cls: "rt-template-entries rt-template-indent" });
      const renderEntryRow = (entry, idx, list) => {
        const row = listEl.createDiv({ cls: "rt-yaml-row" });
        const dragHandle = row.createDiv({ cls: "rt-drag-handle" });
        dragHandle.draggable = true;
        (0, import_obsidian34.setIcon)(dragHandle, "grip-vertical");
        (0, import_obsidian34.setTooltip)(dragHandle, "Drag to reorder key");
        row.createDiv({ cls: "rt-grid-spacer" });
        const keyInput2 = row.createEl("input", { type: "text", cls: "rt-template-input rt-input-md" });
        keyInput2.value = entry.key;
        keyInput2.placeholder = "Key";
        keyInput2.onchange = () => {
          const newKey = keyInput2.value.trim();
          if (!newKey) {
            keyInput2.value = entry.key;
            return;
          }
          if (requiredOrder.includes(newKey)) {
            new import_obsidian34.Notice(`"${newKey}" is a required base key and is auto-included. Choose another name.`);
            keyInput2.value = entry.key;
            return;
          }
          if (list.some((e, i) => i !== idx && e.key === newKey)) {
            new import_obsidian34.Notice(`Key "${newKey}" already exists.`);
            keyInput2.value = entry.key;
            return;
          }
          const nextList = [...list];
          nextList[idx] = { ...entry, key: newKey };
          saveEntries(nextList);
          rerender(nextList);
        };
        const value = entry.value;
        const valInput2 = row.createEl("input", { type: "text", cls: "rt-template-input rt-input-md" });
        if (Array.isArray(value)) {
          valInput2.value = value.join(", ");
          valInput2.placeholder = "Comma-separated values";
          valInput2.onchange = () => {
            const nextList = [...list];
            nextList[idx] = { ...entry, value: valInput2.value.split(",").map((s) => s.trim()).filter(Boolean) };
            saveEntries(nextList);
          };
        } else {
          valInput2.value = value != null ? value : "";
          valInput2.placeholder = "Value";
          valInput2.onchange = () => {
            const nextList = [...list];
            nextList[idx] = { ...entry, value: valInput2.value };
            saveEntries(nextList);
          };
        }
        const delBtn = row.createEl("button", { cls: "rt-template-icon-btn" });
        (0, import_obsidian34.setIcon)(delBtn, "trash");
        delBtn.onclick = () => {
          const nextList = list.filter((_, i) => i !== idx);
          saveEntries(nextList);
          rerender(nextList);
        };
        plugin.registerDomEvent(dragHandle, "dragstart", (e) => {
          var _a2;
          dragIndex = idx;
          row.classList.add("rt-template-dragging");
          (_a2 = e.dataTransfer) == null ? void 0 : _a2.setData("text/plain", idx.toString());
          if (e.dataTransfer) e.dataTransfer.effectAllowed = "move";
        });
        plugin.registerDomEvent(dragHandle, "dragend", () => {
          row.classList.remove("rt-template-dragging");
          row.classList.remove("rt-template-dragover");
          dragIndex = null;
        });
        plugin.registerDomEvent(row, "dragover", (e) => {
          e.preventDefault();
          row.classList.add("rt-template-dragover");
        });
        plugin.registerDomEvent(row, "dragleave", () => {
          row.classList.remove("rt-template-dragover");
        });
        plugin.registerDomEvent(row, "drop", (e) => {
          var _a2;
          e.preventDefault();
          row.classList.remove("rt-template-dragover");
          const from = dragIndex != null ? dragIndex : parseInt(((_a2 = e.dataTransfer) == null ? void 0 : _a2.getData("text/plain")) || "-1", 10);
          if (Number.isNaN(from) || from < 0 || from >= list.length || from === idx) {
            dragIndex = null;
            return;
          }
          const nextList = [...list];
          const [moved] = nextList.splice(from, 1);
          nextList.splice(idx, 0, moved);
          dragIndex = null;
          saveEntries(nextList);
          rerender(nextList);
        });
      };
      data.forEach((entry, idx, arr) => renderEntryRow(entry, idx, arr));
      const addRow = listEl.createDiv({ cls: "rt-yaml-row rt-yaml-add-row" });
      addRow.createDiv({ cls: "rt-drag-handle rt-drag-placeholder" });
      addRow.createDiv({ cls: "rt-grid-spacer" });
      const keyInput = addRow.createEl("input", { type: "text", cls: "rt-template-input rt-input-md", attr: { placeholder: "New key" } });
      const valInput = addRow.createEl("input", { type: "text", cls: "rt-template-input rt-input-md", attr: { placeholder: "Value" } });
      const btnWrap = addRow.createDiv({ cls: "rt-template-add-buttons" });
      const addBtn = btnWrap.createEl("button", { cls: "rt-template-icon-btn rt-mod-cta" });
      (0, import_obsidian34.setIcon)(addBtn, "plus");
      (0, import_obsidian34.setTooltip)(addBtn, "Add key");
      addBtn.onclick = () => {
        const k = (keyInput.value || "").trim();
        if (!k) return;
        if (requiredOrder.includes(k)) {
          new import_obsidian34.Notice(`"${k}" is required and already present via the base template.`);
          return;
        }
        if (data.some((e) => e.key === k)) {
          new import_obsidian34.Notice(`Key "${k}" already exists.`);
          return;
        }
        const nextList = [...data, { key: k, value: valInput.value || "", required: false }];
        saveEntries(nextList);
        rerender(nextList);
      };
      const revertBtn = btnWrap.createEl("button", { cls: "rt-template-icon-btn rt-template-reset-btn" });
      (0, import_obsidian34.setIcon)(revertBtn, "rotate-ccw");
      (0, import_obsidian34.setTooltip)(revertBtn, "Revert to original template");
      revertBtn.onclick = async () => {
        const confirmed = await new Promise((resolve) => {
          const modal = new import_obsidian34.Modal(app);
          const { modalEl, contentEl } = modal;
          modal.titleEl.setText("");
          contentEl.empty();
          modalEl.classList.add("rt-modal-shell");
          contentEl.addClass("rt-modal-container");
          const header = contentEl.createDiv({ cls: "rt-modal-header" });
          header.createSpan({ text: "Warning", cls: "rt-modal-badge" });
          header.createDiv({ text: "Reset advanced YAML template", cls: "rt-modal-title" });
          header.createDiv({ text: "Resetting will delete all custom changes and restore the default template.", cls: "rt-modal-subtitle" });
          const body = contentEl.createDiv({ cls: "rt-glass-card" });
          body.createDiv({ text: "Are you sure you want to reset? This cannot be undone.", cls: "rt-purge-warning" });
          const actionsRow = contentEl.createDiv({ cls: ["rt-modal-actions", "rt-inline-actions"] });
          new import_obsidian34.ButtonComponent(actionsRow).setButtonText("Reset to default").setWarning().onClick(() => {
            modal.close();
            resolve(true);
          });
          new import_obsidian34.ButtonComponent(actionsRow).setButtonText("Cancel").onClick(() => {
            modal.close();
            resolve(false);
          });
          modal.open();
        });
        if (!confirmed) return;
        if (!plugin.settings.sceneYamlTemplates) plugin.settings.sceneYamlTemplates = { base: DEFAULT_SETTINGS.sceneYamlTemplates.base, advanced: "" };
        plugin.settings.sceneYamlTemplates.advanced = defaultTemplate;
        await plugin.saveSettings();
        const resetEntries = entriesFromTemplate(defaultTemplate, requiredOrder).filter((e) => !e.required);
        rerender(resetEntries);
      };
    };
    rerender(entries);
  };
  renderAdvancedTemplateEditor();
  const refreshVisibility = () => {
    renderAdvancedTemplateEditor();
  };
  onAdvancedToggle = refreshVisibility;
  refreshVisibility();
  function updateStoryStructureDescription(container, selectedSystem) {
    const descriptions = {
      "Save The Cat": "Commercial fiction, screenplays, and genre stories. Emphasizes clear emotional beats and audience engagement. <i>The Hunger Games</i>, <i>The Martian</i>, <i>The Fault in Our Stars</i>.",
      "Hero's Journey": "Mythic, adventure, and transformation stories. Focuses on the protagonist's arc through trials and self-discovery. <i>The Odyssey</i>, <i>The Hobbit</i>, <i>Harry Potter and the Sorcerer's Stone</i>.",
      "Story Grid": "Scene-driven structure built around the 5 Commandments: Inciting Incident, Progressive Complications, Crisis, Climax, Resolution. Useful per-scene and at the global level. <i>The Silence of the Lambs</i>, <i>Pride and Prejudice</i>.",
      "Custom": "Uses any story beat notes you create. Perfect for when you don't follow a traditional story structure."
    };
    container.empty();
    for (const [system, desc] of Object.entries(descriptions)) {
      const isSelected = system === selectedSystem;
      const lineDiv = container.createDiv();
      if (isSelected) {
        lineDiv.classList.add("rt-story-structure-selected");
      }
      const boldSpan = lineDiv.createEl("b");
      boldSpan.textContent = system;
      lineDiv.createSpan().innerHTML = `: ${desc}`;
    }
  }
  function updateTemplateButton(setting, selectedSystem) {
    const isCustom = selectedSystem === "Custom";
    let displayName = selectedSystem;
    if (isCustom) {
      displayName = plugin.settings.customBeatSystemName || "Custom";
      const beats = (plugin.settings.customBeatSystemBeats || []).map((b) => {
        if (typeof b === "string") return b.trim();
        if (typeof b === "object" && b !== null && b.name) {
          return String(b.name).trim();
        }
        return "";
      });
      const hasBeats = beats.some((b) => b.length > 0);
      if (hasBeats) {
        setting.setName(`Create story beat template notes for ${displayName}`);
        setting.setDesc(`Generate ${beats.length} template beat notes for your custom system.`);
        setting.settingEl.style.opacity = "1";
        const btn = setting.controlEl.querySelector("button");
        if (btn) btn.disabled = false;
      } else {
        setting.setName("Create story beat template notes");
        setting.setDesc("Define your custom beat list above to generate templates.");
        setting.settingEl.style.opacity = "0.6";
        const btn = setting.controlEl.querySelector("button");
        if (btn) btn.disabled = true;
      }
    } else {
      setting.setName(`Create story beat template notes for ${selectedSystem}`);
      setting.setDesc(`Generate ${selectedSystem} template beat notes including YAML frontmatter and body summary.`);
      setting.settingEl.style.opacity = "1";
      const btn = setting.controlEl.querySelector("button");
      if (btn) btn.disabled = false;
    }
  }
  async function createBeatTemplates() {
    const storyStructureName = plugin.settings.beatSystem || "Custom";
    let storyStructure = getPlotSystem(storyStructureName);
    if (storyStructureName === "Custom") {
      const customSystem = getCustomSystemFromSettings(plugin.settings);
      if (customSystem.beats.length > 0) {
        storyStructure = customSystem;
      } else {
        new import_obsidian34.Notice("No custom beats defined. Add beats in the list above.");
        return;
      }
    }
    if (!storyStructure) {
      new import_obsidian34.Notice(`Unknown story structure: ${storyStructureName}`);
      return;
    }
    const modal = new CreateBeatsTemplatesModal(
      app,
      plugin,
      storyStructureName,
      storyStructure.beatCount || storyStructure.beats.length
    );
    modal.open();
    const result = await modal.waitForConfirmation();
    if (!result.confirmed) return;
    try {
      const sourcePath = plugin.settings.sourcePath || "";
      const { created, skipped, errors } = await createBeatTemplateNotes(
        app.vault,
        storyStructureName,
        sourcePath,
        storyStructureName === "Custom" ? storyStructure : void 0
      );
      if (errors.length > 0) {
        new import_obsidian34.Notice(`Created ${created} notes. ${skipped} skipped. ${errors.length} errors. Check console.`);
        console.error("[Beat Templates] Errors:", errors);
      } else if (created === 0 && skipped > 0) {
        new import_obsidian34.Notice(`All ${skipped} Beat notes already exist. No new notes created.`);
      } else {
        new import_obsidian34.Notice(`\u2713 Successfully created ${created} Beat template notes!`);
      }
    } catch (error) {
      console.error("[Beat Templates] Failed:", error);
      new import_obsidian34.Notice(`Failed to create story beat templates: ${error}`);
    }
  }
}
function extractKeysInOrder(template) {
  const keys = [];
  const lines = (template || "").split("\n");
  for (const line of lines) {
    const match = line.match(/^([A-Za-z0-9 _'-]+):/);
    if (match) {
      const key = match[1].trim();
      if (key && !keys.includes(key)) keys.push(key);
    }
  }
  return keys;
}
function safeParseYaml(template) {
  try {
    const parsed = (0, import_obsidian34.parseYaml)(template);
    if (!parsed || typeof parsed !== "object") return {};
    const entries = {};
    Object.entries(parsed).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        entries[key] = value.map((v) => String(v));
      } else if (value === void 0 || value === null) {
        entries[key] = "";
      } else {
        entries[key] = String(value);
      }
    });
    return entries;
  } catch (e) {
    return {};
  }
}
function mergeOrders(primary, secondary) {
  const seen = /* @__PURE__ */ new Set();
  const result = [];
  [...primary, ...secondary].forEach((key) => {
    if (!key || seen.has(key)) return;
    seen.add(key);
    result.push(key);
  });
  return result;
}
function buildYamlFromEntries(entries, commentMap) {
  const lines = [];
  entries.forEach((entry) => {
    var _a;
    const comment = commentMap == null ? void 0 : commentMap[entry.key];
    if (Array.isArray(entry.value)) {
      lines.push(comment ? `${entry.key}: # ${comment}` : `${entry.key}:`);
      entry.value.forEach((v) => {
        lines.push(`  - ${v}`);
      });
    } else {
      const valueStr = (_a = entry.value) != null ? _a : "";
      lines.push(comment ? `${entry.key}: ${valueStr} # ${comment}` : `${entry.key}: ${valueStr}`);
    }
  });
  return lines.join("\n");
}
function buildYamlWithRequired(requiredOrder, requiredValues, optionalEntries, commentMap) {
  const combined = [
    ...requiredOrder.map((key) => {
      var _a;
      return {
        key,
        value: (_a = requiredValues[key]) != null ? _a : "",
        required: true
      };
    }),
    ...optionalEntries
  ];
  return buildYamlFromEntries(combined, commentMap);
}
function entriesFromTemplate(template, requiredOrder) {
  const order = mergeOrders(extractKeysInOrder(template), requiredOrder);
  const obj = safeParseYaml(template);
  return order.map((key) => {
    var _a;
    return {
      key,
      value: (_a = obj[key]) != null ? _a : "",
      required: requiredOrder.includes(key)
    };
  });
}

// src/settings/SettingsTab.ts
init_anthropicApi();
init_openaiApi();
init_geminiApi();

// src/settings/sections/ColorsSection.ts
var import_obsidian37 = require("obsidian");
init_defaults();
function renderColorsSection(containerEl, plugin) {
  const pubHeading = new import_obsidian37.Setting(containerEl).setName("Publishing stage colors").setHeading();
  pubHeading.settingEl.classList.add("rt-section-heading");
  containerEl.createEl("p", { cls: "rt-color-section-desc", text: "Used for completed scenes, stage matrix, act labels and more." });
  const stageGrid = containerEl.createDiv({ cls: "rt-color-grid" });
  const stages = Object.entries(plugin.settings.publishStageColors);
  stages.forEach(([stage, color]) => {
    const cell = stageGrid.createDiv({ cls: "rt-color-grid-item" });
    const label = cell.createDiv({ cls: "rt-color-grid-label" });
    label.setText(stage);
    let textInputRef;
    let colorPickerRef;
    const control = cell.createDiv({ cls: "rt-color-grid-controls" });
    colorPickerRef = new import_obsidian37.ColorComponent(control).setValue(color).onChange(async (value) => {
      if (/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(value)) {
        plugin.settings.publishStageColors[stage] = value;
        await plugin.saveSettings();
        plugin.setCSSColorVariables();
        textInputRef == null ? void 0 : textInputRef.setValue(value);
      }
    });
    const colorInput = control.querySelector('input[type="color"]:last-of-type');
    if (colorInput) colorInput.classList.add("rt-hidden-color-input");
    const swatchEl = control.createDiv({ cls: `rt-swatch-trigger rt-stage-${stage}` });
    plugin.registerDomEvent(swatchEl, "click", () => {
      colorInput == null ? void 0 : colorInput.click();
    });
    new import_obsidian37.Setting(control).addText((textInput) => {
      textInputRef = textInput;
      textInput.inputEl.classList.add("rt-hex-input");
      textInput.setValue(color).onChange(async (value) => {
        if (/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(value)) {
          plugin.settings.publishStageColors[stage] = value;
          await plugin.saveSettings();
          plugin.setCSSColorVariables();
          colorPickerRef == null ? void 0 : colorPickerRef.setValue(value);
        }
      });
    }).addExtraButton((button) => {
      button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        const defaultColor = DEFAULT_SETTINGS.publishStageColors[stage];
        plugin.settings.publishStageColors[stage] = defaultColor;
        await plugin.saveSettings();
        plugin.setCSSColorVariables();
        textInputRef == null ? void 0 : textInputRef.setValue(defaultColor);
        colorPickerRef == null ? void 0 : colorPickerRef.setValue(defaultColor);
      });
    });
  });
  const subplotHeading = new import_obsidian37.Setting(containerEl).setName("Subplot ring colors").setHeading();
  subplotHeading.settingEl.classList.add("rt-section-heading");
  containerEl.createEl("p", { cls: "rt-color-section-desc", text: "Subplot ring colors used for rings 1 through 16 moving inward." });
  const subplotGrid = containerEl.createDiv({ cls: "rt-color-grid" });
  const ensureArray = (arr) => Array.isArray(arr) ? arr : [];
  const subplotColors = ensureArray(plugin.settings.subplotColors);
  for (let i = 0; i < 16; i++) {
    const labelText = i === 0 ? "MAIN PLOT" : `Ring ${i + 1}`;
    const current = subplotColors[i] || DEFAULT_SETTINGS.subplotColors[i];
    const cell = subplotGrid.createDiv({ cls: "rt-color-grid-item" });
    const label = cell.createDiv({ cls: "rt-color-grid-label" });
    label.setText(labelText);
    const control = cell.createDiv({ cls: "rt-color-grid-controls" });
    let inputRef;
    let colorPickerRef;
    colorPickerRef = new import_obsidian37.ColorComponent(control).setValue(current).onChange(async (value) => {
      if (/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(value)) {
        const next = [...plugin.settings.subplotColors || DEFAULT_SETTINGS.subplotColors];
        next[i] = value;
        plugin.settings.subplotColors = next;
        await plugin.saveSettings();
        plugin.setCSSColorVariables();
        inputRef == null ? void 0 : inputRef.setValue(value);
      }
    });
    const colorInput2 = control.querySelector('input[type="color"]:last-of-type');
    if (colorInput2) colorInput2.classList.add("rt-hidden-color-input");
    const swatchEl2 = control.createDiv({ cls: `rt-swatch-trigger rt-subplot-${i}` });
    plugin.registerDomEvent(swatchEl2, "click", () => {
      colorInput2 == null ? void 0 : colorInput2.click();
    });
    new import_obsidian37.Setting(control).addText((text) => {
      inputRef = text;
      text.inputEl.classList.add("rt-hex-input");
      text.setValue(current).onChange(async (value) => {
        if (/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(value)) {
          const next = [...plugin.settings.subplotColors || DEFAULT_SETTINGS.subplotColors];
          next[i] = value;
          plugin.settings.subplotColors = next;
          await plugin.saveSettings();
          plugin.setCSSColorVariables();
          colorPickerRef == null ? void 0 : colorPickerRef.setValue(value);
        }
      });
    }).addExtraButton((button) => {
      button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        const value = DEFAULT_SETTINGS.subplotColors[i];
        const next = [...plugin.settings.subplotColors || DEFAULT_SETTINGS.subplotColors];
        next[i] = value;
        plugin.settings.subplotColors = next;
        await plugin.saveSettings();
        plugin.setCSSColorVariables();
        inputRef == null ? void 0 : inputRef.setValue(value);
        colorPickerRef == null ? void 0 : colorPickerRef.setValue(value);
      });
    });
  }
}

// src/settings/sections/ReadmeSection.ts
var import_obsidian38 = require("obsidian");
function renderReadmeSection(params) {
  const { app, containerEl, setComponentRef } = params;
  containerEl.createEl("hr", { cls: "rt-settings-separator" });
  const readmeContainer = containerEl.createDiv({ cls: "rt-manuscript-readme-container" });
  const readmeMarkdown = true ? `<p align="center">
  <img src="https://raw.githubusercontent.com/EricRhysTaylor/radial-timeline/master/logo.png" alt="Radial Timeline Logo" width="10%">
</p>
<p align="center" style="font-family: sans-serif; font-weight: 100; font-size: 14px; margin-top: 12px; margin-bottom: 0; letter-spacing: 8px;">
  Radial Timeline\u2122
</p>
<p align="center" style="font-family: sans-serif; font-size: 14px; margin-top: 4px;">
  by Eric Rhys Taylor
</p>


<p align="center">
    <a href="https://github.com/EricRhysTaylor/radial-timeline/stargazers" target="_blank" rel="noopener"><img src="https://img.shields.io/github/stars/EricRhysTaylor/radial-timeline?colorA=363a4f&colorB=e0ac00&style=for-the-badge" alt="GitHub star count"></a><!-- Enhancements --><a href="https://github.com/EricRhysTaylor/radial-timeline/issues?q=is%3Aissue+is%3Aopen+label%3Aenhancement" target="_blank" rel="noopener">
  <img src="https://img.shields.io/github/issues/EricRhysTaylor/radial-timeline/enhancement?colorA=363a4f&colorB=00bfa5&style=for-the-badge&label=enhancements" alt="Open enhancements on GitHub">
</a><a href="https://github.com/EricRhysTaylor/radial-timeline/issues?q=is%3Aclosed+label%3Aenhancement" target="_blank" rel="noopener">
  <img src="https://img.shields.io/github/issues-closed/EricRhysTaylor/radial-timeline/enhancement?colorA=363a4f&colorB=4a90e2&style=for-the-badge&label=closed%20enhancements" alt="Closed enhancements on GitHub">
</a>
<a href="https://github.com/EricRhysTaylor/radial-timeline/issues?q=is%3Aissue+is%3Aopen+label%3Abug" target="_blank" rel="noopener">
  <img src="https://img.shields.io/github/issues/EricRhysTaylor/radial-timeline/bug?colorA=363a4f&colorB=e93147&style=for-the-badge&label=bugs" alt="Open bugs on GitHub">
</a>
    <br/>
	<a href="https://obsidian.md/plugins?id=radial-timeline" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/dynamic/json?url=https://raw.githubusercontent.com/obsidianmd/obsidian-releases/master/community-plugin-stats.json&query=$.radial-timeline.downloads&label=Downloads&style=for-the-badge&colorA=363a4f&colorB=d53984" alt="Plugin Downloads"/></a>
	<a href="https://github.com/EricRhysTaylor/radial-timeline/blob/master/LICENSE" target="_blank" rel="noopener"><img src="https://img.shields.io/static/v1.svg?style=for-the-badge&label=License&message=Non-Commercial&colorA=363a4f&colorB=b7bdf8" alt="Non-Commercial license"/></a>
</p>

---


The manuscript visualization plugin for Obsidian.

**Stop losing track of subplot threads across dozens of scenes.** Radial Timeline\u2122 transforms your manuscript into a live visual map where you can see your entire story structure at a glance.

## What It Does

Radial Timeline\u2122 arranges your scenes by act, subplot, narrative or chronological order in a striking radial layout\u2014revealing the structure, rhythm, and scope of your story. Each ring represents a subplot; hover interactions surface important details like scene synopsis and story beats. Scenes highlight across subplots to show interrelationships. Multiple view modes dissect your novel like an X-ray.

**Before**: Scrolling through line after line of spreadsheet tables and files, losing sight of how your B-plot interweaves with the main storyline.  

**After**: One visual map showing every scene, every subplot, every beat color coded and connected to the big picture.

Radial Timeline\u2122 captures and visualizes all 4 critical timelines, revealing the big picture as your manuscript evolves from the nucleus of an idea to the final polished novel.

1. **Narrative time**: the sequence you reveal events to readers.
2. **Chronological time**: when events happen in your story's world. (Includes Planetary Time calculator for sci-fi/fantasy calendars).
3. **Author time**: your scene writing progress with target completion dates from Todo to Complete.
4. **Publishing time**: manuscript revision stages from Zero draft through Press-ready.

Narrative and Chronologue modes keep subplot colors front-and-center so you can compare structure without workflow noise. When you need to see Todo/Working/Overdue progress or publish stage colors, jump into Subplot Mode where all scenes is replaced by Main Plot and scenes inherit the author-status and publish-stage palette.

---

## Docs (How-to & setup)

If you want the \u201Chow-to\u201D details (setup, templates, YAML, reordering, advanced options), they live in the wiki:

- [Wiki Home](https://github.com/EricRhysTaylor/Radial-Timeline/wiki)
- [How-to](https://github.com/EricRhysTaylor/Radial-Timeline/wiki/How-to)
- [Settings](https://github.com/EricRhysTaylor/Radial-Timeline/wiki/Settings)
- [Commands](https://github.com/EricRhysTaylor/Radial-Timeline/wiki/Commands)
- [YAML Frontmatter](https://github.com/EricRhysTaylor/Radial-Timeline/wiki/YAML-Frontmatter)

<br>
<a href="https://youtu.be/7noTSFaj8Eo" target="_blank" rel="noopener">
  <p align="center">
    <img src="https://i.ytimg.com/vi/7noTSFaj8Eo/maxresdefault.jpg" alt="Plan your novel with radial timeline in obsidian | complete author walkthrough & setup guide" style="max-width: 80%; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
  </p>
  <p align="center" style="font-family: sans-serif; font-size: 16px; margin-top: 10px;">
    Plan your novel with radial timeline in obsidian<br>
    Complete author walkthrough & setup guide
  </p>
</a>


---

## Installation

**From Obsidian**
1.  Open settings \u2192 community plugins.
2.  Click browse and search for "radial timeline".
3.  Click install and then enable.

**Manual installation**
1.  Download the latest main.js, styles.css, and manifest.json from the <a href="https://github.com/EricRhysTaylor/radial-timeline/releases" target="_blank" rel="noopener">releases</a> page.
2.  Extract the files to your vault's .obsidian/plugins/radial-timeline (may be hidden by file system)

---

## Known Conflicts

*   **Plugin Conflicts**: If you experience visual glitches or strange behavior (such as the timeline overlapping with other UI elements), it may be due to a conflict with another plugin. Try disabling other plugins to isolate the issue. Please see [known plugin conflicts](https://github.com/EricRhysTaylor/Radial-Timeline/issues?q=label%3A%22Plugin+Conflict%22).



---

## Technical Notes

### Screen Resolution
The radial timeline is designed for high pixel density displays (around 200 ppi or higher) for optimal visual quality.
*   All Apple Retina displays \u2014 2x pixel density.
*   Recommend Windows systems with 4k displays or higher. (Tested down to 1080p 2550x1440)
*   Tablets.

If you're experiencing visual quality issues on Windows, please check your display scaling settings.

## Acknowledgments

*   [d3.js](https://d3js.org) \u2014 powerful data-driven, SVG-based visualization patterns that present complex statistical data in a visually appealing and approachable format.
*   [Save the Cat! Writes a Novel](https://www.jessicabrody.com/books/non-fiction/save-cat-writes-novel/about/) (2018), Jessica Brody \u2014 a practical articulation of the Save the Cat beats.
*   [The Story Grid](https://storygrid.com), Shawn Coyne \u2014 a rigorous methodology for analyzing scenes and beat flow.
*   [Obsidian](https://obsidian.md) \u2014 for a thriving plugin ecosystem and thoughtful feature development.
*   [W3C SVG specification](https://www.w3.org/Graphics/SVG/) \u2014 for making vector graphics on the web dependable.
*   **04 Font** by Yuji Oshimoto \u2014 a beautiful Japanese freeware font. \xA9 1998\u20132003 Yuji Oshimoto. [04.jp.org](http://www.04.jp.org/)
    <br>\u3053\u306E\u30D5\u30A9\u30F3\u30C8\u306F\u30D5\u30EA\u30FC\u30A6\u30A7\u30A2\u3067\u3059\u3002\u975E\u55B6\u5229\u76EE\u7684\u3067\u306E\u914D\u5E03\u3001\u8B72\u6E21\u3001\u8EE2\u8F09\u306F\u81EA\u7531\u3067\u3059\u304C\u3001\u4F5C\u8005\u306E\u8A31\u53EF\u306A\u304F\u8CA9\u58F2\u3057\u305F\u308A\u3001\u55B6\u5229\u76EE\u7684\u306E\u88FD\u54C1\u306B\u6DFB\u4ED8\u3059\u308B\u4E8B\u306F\u56FA\u304F\u7981\u3058\u3055\u305B\u3066\u9802\u304D\u307E\u3059\u3002\u306A\u304A\u3001\u3053\u306E\u30D5\u30A9\u30F3\u30C8\u3092\u4F7F\u7528\u3057\u3066\u3044\u304B\u306A\u308B\u640D\u5BB3\u306B\u3064\u3044\u3066\u3082\u4F5C\u8005\u306F\u8CAC\u4EFB\u3092\u8CA0\u308F\u306A\u3044\u3082\u306E\u3068\u3057\u307E\u3059\u3002\u5FA1\u610F\u898B\u3001\u5FA1\u611F\u60F3\u306A\u3069\u3088\u308D\u3057\u3051\u308C\u3070\u30E1\u30FC\u30EB\u304F\u3060\u3055\u3044\u3002

---

## Feedback and support

Check out the Discussions group at <a href="https://github.com/EricRhysTaylor/Radial-Timeline/discussions" target="_blank" rel="noopener">Discussions</a>. If you encounter issues or have feature requests, please file an issue on the <a href="https://github.com/EricRhysTaylor/radial-timeline/issues" target="_blank" rel="noopener">Github Repository Issues page</a>. If you find the radial timeline plugin useful and would like to encourage continued development, please consider joining my <a href="https://www.patreon.com/c/EricRhysTaylor" target="_blank" rel="noopener">Patreon</a> or just buying me a coffee:

<a href="https://www.buymeacoffee.com/ericrhysTaylor" target="_blank" rel="noopener">
  <img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="buy me a coffee" style="width: 150px;"></a>
&nbsp;&nbsp;&nbsp;&nbsp;
<a href='https://ko-fi.com/Z8Z21NMQRN' target='_blank'><img style='border:0px;width:150px;' src='https://storage.ko-fi.com/cdn/kofi4.png?v=6' border='0' alt='Buy Me a Coffee at ko-fi.com' /></a>

---

## Author

Created by Eric Rhys Taylor

Reviewed and approved for the Obsidian Community Plugins directory. Developed with best practices in mind.

## License & Intellectual Property

Radial Timeline\u2122 \xA9 2025 Eric Rhys Taylor  
Released under a **Source-Available, Non-Commercial License**.  

- You may view, install, and use this plugin for personal or educational purposes.
- Commercial use, redistribution, or creation of derivative works using this source code is prohibited without written permission.
- The "Radial Timeline" name is a trademark of Eric Rhys Taylor.  

See the [License](https://github.com/EricRhysTaylor/Radial-Timeline/wiki/License) and [Notice](https://github.com/EricRhysTaylor/Radial-Timeline/wiki/Notice) pages for full details.

## Disclaimer & Limitation of Liability

This software is provided "as is" without warranty of any kind, express or implied.
The author makes no guarantees regarding performance, reliability, or compatibility with third-party plugins, APIs, or services.` : "README content could not be loaded. Please ensure the plugin was built correctly or view the README.md file directly.";
  const ytThumbRe = /!\[[^\]]*\]\((https?:\/\/i\.ytimg\.com\/vi\/([a-zA-Z0-9_-]+)\/[^)]+)\)/gi;
  const externalImgRe = /!\[([^\]]*)\]\((https?:\/\/[^)]+)\)/gi;
  const safeReadme = readmeMarkdown.replace(ytThumbRe, (_m, _url, vid) => `[Watch on YouTube](https://youtu.be/${vid})`).replace(externalImgRe, (_m, alt, url) => `[${alt || "Open link"}](${url})`);
  const component = new import_obsidian38.Component();
  setComponentRef(component);
  import_obsidian38.MarkdownRenderer.render(
    app,
    safeReadme,
    readmeContainer,
    "",
    component
  );
}

// src/settings/sections/AdvancedSection.ts
var import_obsidian39 = require("obsidian");
init_FontMetricsCache();
function renderAdvancedSection(params) {
  const { app, plugin, containerEl } = params;
  const advancedHeading = new import_obsidian39.Setting(containerEl).setName(t("settings.advanced.heading")).setHeading();
  addWikiLink(advancedHeading, "Settings#advanced");
  new import_obsidian39.Setting(containerEl).setName(t("settings.advanced.aiOutputFolder.name")).setDesc(t("settings.advanced.aiOutputFolder.desc")).addText((text) => {
    var _a;
    const fallbackFolder = ((_a = plugin.settings.aiOutputFolder) == null ? void 0 : _a.trim()) || "AI";
    const illegalChars = /[<>:"|?*]/;
    text.setPlaceholder(t("settings.advanced.aiOutputFolder.placeholder")).setValue(fallbackFolder);
    text.inputEl.addClass("rt-input-full");
    const inputEl = text.inputEl;
    const flashClass = (cls) => {
      inputEl.addClass(cls);
      window.setTimeout(() => inputEl.removeClass(cls), cls === "rt-setting-input-success" ? 1e3 : 2e3);
    };
    const validatePath = async () => {
      inputEl.removeClass("rt-setting-input-success");
      inputEl.removeClass("rt-setting-input-error");
      const rawValue = text.getValue();
      const trimmed = rawValue.trim() || fallbackFolder;
      if (illegalChars.test(trimmed)) {
        flashClass("rt-setting-input-error");
        new import_obsidian39.Notice('Folder path cannot contain the characters < > : " | ? *');
        return;
      }
      const normalized = (0, import_obsidian39.normalizePath)(trimmed);
      try {
        await plugin.app.vault.createFolder(normalized);
      } catch (e) {
      }
      const isValid = await plugin.validateAndRememberPath(normalized);
      if (!isValid) {
        flashClass("rt-setting-input-error");
        return;
      }
      plugin.settings.aiOutputFolder = normalized;
      await plugin.saveSettings();
      flashClass("rt-setting-input-success");
    };
    text.onChange(() => {
      inputEl.removeClass("rt-setting-input-success");
      inputEl.removeClass("rt-setting-input-error");
    });
    plugin.registerDomEvent(text.inputEl, "blur", () => {
      void validatePath();
    });
  });
  new import_obsidian39.Setting(containerEl).setName(t("settings.advanced.autoExpand.name")).setDesc(t("settings.advanced.autoExpand.desc")).addToggle((toggle) => {
    var _a;
    return toggle.setValue((_a = plugin.settings.enableSceneTitleAutoExpand) != null ? _a : true).onChange(async (value) => {
      plugin.settings.enableSceneTitleAutoExpand = value;
      await plugin.saveSettings();
    });
  });
  new import_obsidian39.Setting(containerEl).setName(t("settings.advanced.readability.name")).setDesc(t("settings.advanced.readability.desc")).addDropdown((drop) => {
    var _a;
    drop.addOption("normal", t("settings.advanced.readability.normal"));
    drop.addOption("large", t("settings.advanced.readability.large"));
    drop.setValue((_a = plugin.settings.readabilityScale) != null ? _a : "normal");
    drop.onChange(async (value) => {
      plugin.settings.readabilityScale = value;
      await plugin.saveSettings();
      clearFontMetricsCaches();
      plugin.refreshTimelineIfNeeded(null);
    });
    drop.selectEl.addClass("rt-setting-dropdown");
  });
  new import_obsidian39.Setting(containerEl).setName(t("settings.advanced.debounce.name")).setDesc(t("settings.advanced.debounce.desc")).addText((text) => {
    var _a;
    const current = String((_a = plugin.settings.metadataRefreshDebounceMs) != null ? _a : 1e4);
    text.setPlaceholder(t("settings.advanced.debounce.placeholder"));
    text.setValue(current);
    text.inputEl.addClass("rt-input-xs");
    plugin.registerDomEvent(text.inputEl, "keydown", (evt) => {
      if (evt.key === "Enter") {
        evt.preventDefault();
        text.inputEl.blur();
      }
    });
    const handleBlur = async () => {
      var _a2;
      const n = Number(text.getValue().trim());
      if (!Number.isFinite(n) || n < 0) {
        new import_obsidian39.Notice(t("settings.advanced.debounce.error"));
        text.setValue(String((_a2 = plugin.settings.metadataRefreshDebounceMs) != null ? _a2 : 1e4));
        return;
      }
      plugin.settings.metadataRefreshDebounceMs = n;
      await plugin.saveSettings();
    };
    plugin.registerDomEvent(text.inputEl, "blur", () => {
      void handleBlur();
    });
  });
  new import_obsidian39.Setting(containerEl).setName(t("settings.advanced.resetSubplotColors.name")).setDesc(t("settings.advanced.resetSubplotColors.desc")).addButton((button) => button.setButtonText(t("settings.advanced.resetSubplotColors.button")).setWarning().onClick(async () => {
    const count = Object.keys(plugin.settings.dominantSubplots || {}).length;
    plugin.settings.dominantSubplots = {};
    await plugin.saveSettings();
    plugin.refreshTimelineIfNeeded(null);
    if (count > 0) {
      new import_obsidian39.Notice(t("settings.advanced.resetSubplotColors.clearedNotice", { count: String(count) }));
    } else {
      new import_obsidian39.Notice(t("settings.advanced.resetSubplotColors.nothingToReset"));
    }
  }));
  const sortSetting = new import_obsidian39.Setting(containerEl).setName(t("settings.advanced.sceneOrdering.name")).setDesc(t("settings.advanced.sceneOrdering.desc")).addToggle((toggle) => toggle.setValue(false).setDisabled(true).onChange(async () => {
  }));
  sortSetting.settingEl.style.opacity = "0.5";
  sortSetting.settingEl.style.cursor = "not-allowed";
}

// src/settings/sections/AiSection.ts
var import_obsidian42 = require("obsidian");

// src/api/localAiApi.ts
var import_obsidian40 = require("obsidian");
function buildEndpoint(baseUrl, path) {
  const trimmed = baseUrl.replace(/\/+$/, "");
  if (trimmed.endsWith(path)) return trimmed;
  return `${trimmed}${path}`;
}
async function fetchLocalModels(baseUrl, apiKey) {
  var _a;
  const normalizedBase = baseUrl == null ? void 0 : baseUrl.trim();
  if (!normalizedBase) throw new Error("Base URL is required.");
  const url = buildEndpoint(normalizedBase, "/models");
  const headers = {};
  if (apiKey) headers.Authorization = `Bearer ${apiKey}`;
  const response = await (0, import_obsidian40.requestUrl)({
    url,
    method: "GET",
    headers,
    throw: false
  });
  const json = response.json;
  if (response.status >= 400) {
    const message = ((_a = json == null ? void 0 : json.error) == null ? void 0 : _a.message) || `HTTP ${response.status}`;
    throw new Error(message);
  }
  if (!Array.isArray(json == null ? void 0 : json.data)) {
    throw new Error("Local AI server returned an unexpected response.");
  }
  return json.data;
}
async function validateLocalModelAvailability(baseUrl, modelId, apiKey) {
  try {
    const models = await fetchLocalModels(baseUrl, apiKey);
    const desired = modelId.trim();
    const hasModel = models.some((model) => model.id === desired);
    return {
      reachable: true,
      hasModel,
      message: hasModel ? void 0 : `Model "${desired}" was not found on the server.`
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return { reachable: false, hasModel: false, message };
  }
}

// src/data/aiModels.ts
var CURATED_MODELS = {
  openai: [
    {
      id: "gpt-5.2-chat-latest",
      label: "GPT-5.2 (Latest)",
      guidance: "\u2192 GPT-5.2. Exceptional instruction following and structured output for precise scene analysis."
    }
  ],
  anthropic: [
    {
      id: "claude-opus-4-5-20251101",
      label: "Claude Opus 4.5",
      guidance: "Most powerful Claude. Unparalleled nuance and deep structural analysis for complex narratives. [FYI](https://docs.anthropic.com/en/docs/about-claude/models)"
    },
    {
      id: "claude-sonnet-4-5-20250929",
      label: "Claude Sonnet 4.5",
      guidance: "Balanced creative specialist\u2014excellent narrative instincts and polished first-draft feedback. [FYI](https://docs.anthropic.com/en/docs/about-claude/models)"
    }
  ],
  gemini: [
    {
      id: "gemini-pro-latest",
      label: "Gemini Pro (Latest)",
      guidance: "\u2192 Gemini 3 Pro. 1M+ token context, advanced multimodal reasoning for complex narrative structures."
    }
  ]
};

// src/settings/AiContextModal.ts
var import_obsidian41 = require("obsidian");
var TextInputModal = class extends import_obsidian41.Modal {
  constructor(app, title, defaultValue, onSubmit) {
    super(app);
    this.result = null;
    this.title = title;
    this.defaultValue = defaultValue;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl, titleEl, modalEl } = this;
    titleEl.setText("");
    if (modalEl) {
      modalEl.classList.add("rt-modal-shell");
      modalEl.style.width = "480px";
      modalEl.style.maxWidth = "92vw";
    }
    contentEl.addClass("rt-modal-container");
    contentEl.addClass("rt-text-input-modal");
    const header = contentEl.createDiv({ cls: "rt-modal-header" });
    header.createDiv({ cls: "rt-modal-title", text: this.title });
    const inputContainer = contentEl.createDiv({ cls: "rt-search-input-container" });
    this.inputEl = inputContainer.createEl("input", {
      type: "text",
      value: this.defaultValue,
      cls: "rt-input-full"
    });
    window.setTimeout(() => {
      var _a, _b;
      (_a = this.inputEl) == null ? void 0 : _a.focus();
      (_b = this.inputEl) == null ? void 0 : _b.select();
    }, 10);
    const handleKeydown = (e) => {
      var _a;
      if (e.key === "Enter") {
        e.preventDefault();
        this.submit(((_a = this.inputEl) == null ? void 0 : _a.value) || "");
      } else if (e.key === "Escape") {
        this.close();
      }
    };
    this.inputEl.addEventListener("keydown", handleKeydown);
    this._keydownHandler = handleKeydown;
    const buttonRow = contentEl.createDiv({ cls: "rt-modal-actions" });
    new import_obsidian41.ButtonComponent(buttonRow).setButtonText("OK").setCta().onClick(() => {
      var _a;
      return this.submit(((_a = this.inputEl) == null ? void 0 : _a.value) || "");
    });
    new import_obsidian41.ButtonComponent(buttonRow).setButtonText("Cancel").onClick(() => this.close());
  }
  onClose() {
    if (this.inputEl && this._keydownHandler) {
      this.inputEl.removeEventListener("keydown", this._keydownHandler);
    }
  }
  submit(value) {
    const trimmedValue = value.trim();
    if (trimmedValue) {
      this.onSubmit(trimmedValue);
      this.close();
    } else {
      new import_obsidian41.Notice("Please enter a template name");
    }
  }
};
var AiContextModal = class extends import_obsidian41.Modal {
  constructor(app, plugin, onSave) {
    super(app);
    this.isDirty = false;
    this.plugin = plugin;
    this.onSave = onSave;
    this.templates = JSON.parse(JSON.stringify(plugin.settings.aiContextTemplates || []));
    this.currentTemplateId = plugin.settings.activeAiContextTemplateId || "commercial_genre";
  }
  onOpen() {
    const { contentEl, titleEl, modalEl } = this;
    if (modalEl) {
      modalEl.classList.add("rt-modal-shell");
      modalEl.style.width = "660px";
      modalEl.style.maxWidth = "92vw";
      modalEl.style.maxHeight = "92vh";
    }
    titleEl.setText("");
    contentEl.addClass("rt-modal-container");
    contentEl.addClass("rt-ai-context-modal");
    const hero = contentEl.createDiv({ cls: "rt-modal-header" });
    hero.createDiv({ cls: "rt-modal-title", text: "AI context templates" });
    hero.createDiv({
      cls: "rt-modal-subtitle",
      text: "Define context prepended to AI prompts and Gossamer scoring."
    });
    const infoEl = contentEl.createDiv({ cls: "rt-ai-context-info" });
    infoEl.setText("Define context for AI LLM analysis and Gossamer score generation. This text prepends all prompts sent to LLM to establish role and context and is used for the copy template button to generate Gossamer scores.");
    const selectorSection = contentEl.createDiv({ cls: "rt-ai-context-selector-section" });
    const selectorLabel = selectorSection.createDiv({ cls: "rt-ai-context-label" });
    selectorLabel.setText("Template:");
    const selectorRow = selectorSection.createDiv({ cls: "rt-ai-context-selector-row" });
    this.dropdownComponent = new import_obsidian41.DropdownComponent(selectorRow);
    this.updateDropdownOptions();
    this.dropdownComponent.setValue(this.currentTemplateId);
    this.dropdownComponent.onChange((value) => {
      var _a;
      if (this.isDirty) {
        const discard = window.confirm("You have unsaved changes. Discard them?");
        if (!discard) {
          (_a = this.dropdownComponent) == null ? void 0 : _a.setValue(this.currentTemplateId);
          return;
        }
        this.isDirty = false;
      }
      this.currentTemplateId = value;
      this.updateEditorSection();
    });
    const buttonRow = selectorSection.createDiv({ cls: "rt-ai-context-button-row" });
    new import_obsidian41.ButtonComponent(buttonRow).setButtonText("New template").onClick(() => this.createNewTemplate());
    this.renameButton = new import_obsidian41.ButtonComponent(buttonRow).setButtonText("Rename").onClick(() => this.renameTemplate());
    this.copyButton = new import_obsidian41.ButtonComponent(buttonRow).setButtonText("Create copy").onClick(() => this.copyTemplate());
    this.deleteButton = new import_obsidian41.ButtonComponent(buttonRow).setButtonText("Delete").setWarning().onClick(() => this.deleteTemplate());
    const editorSection = contentEl.createDiv({ cls: "rt-ai-context-editor-section" });
    const editorLabel = editorSection.createDiv({ cls: "rt-ai-context-label" });
    editorLabel.setText("Prompt:");
    this.textareaEl = editorSection.createEl("textarea", { cls: "rt-ai-context-textarea" });
    this.textareaEl.placeholder = "Enter your AI context prompt here...";
    const handleInput = () => {
      const currentTemplate = this.getCurrentTemplate();
      if (currentTemplate && !currentTemplate.isBuiltIn) {
        this.isDirty = true;
        this.updateButtonStates();
      }
    };
    this.textareaEl.addEventListener("input", handleInput);
    this._inputHandler = handleInput;
    const actionRow = contentEl.createDiv({ cls: "rt-modal-actions" });
    this.saveButton = new import_obsidian41.ButtonComponent(actionRow).setButtonText("Save changes").setCta().onClick(() => this.saveChanges());
    new import_obsidian41.ButtonComponent(actionRow).setButtonText("Set as active & close").onClick(() => this.setActiveAndClose());
    new import_obsidian41.ButtonComponent(actionRow).setButtonText("Cancel").onClick(() => {
      if (this.isDirty) {
        const discard = window.confirm("You have unsaved changes. Discard them?");
        if (!discard) return;
      }
      this.close();
    });
    this.updateEditorSection();
    this.updateButtonStates();
  }
  onClose() {
    if (this.textareaEl && this._inputHandler) {
      this.textareaEl.removeEventListener("input", this._inputHandler);
    }
  }
  updateDropdownOptions() {
    if (!this.dropdownComponent) return;
    this.dropdownComponent.selectEl.empty();
    this.templates.forEach((template) => {
      const label = template.isBuiltIn ? `${template.name} (Built-in)` : template.name;
      this.dropdownComponent.addOption(template.id, label);
    });
  }
  getCurrentTemplate() {
    return this.templates.find((t2) => t2.id === this.currentTemplateId);
  }
  updateEditorSection() {
    const currentTemplate = this.getCurrentTemplate();
    if (!currentTemplate) return;
    if (this.textareaEl) {
      this.textareaEl.value = currentTemplate.prompt;
      this.textareaEl.disabled = currentTemplate.isBuiltIn;
    }
    this.isDirty = false;
    this.updateButtonStates();
  }
  updateButtonStates() {
    const currentTemplate = this.getCurrentTemplate();
    if (!currentTemplate) return;
    const isBuiltIn = currentTemplate.isBuiltIn;
    if (this.saveButton) {
      this.saveButton.setDisabled(isBuiltIn || !this.isDirty);
    }
    if (this.deleteButton) {
      this.deleteButton.setDisabled(isBuiltIn);
    }
    if (this.renameButton) {
      this.renameButton.setDisabled(isBuiltIn);
    }
    if (this.copyButton) {
      this.copyButton.setDisabled(!isBuiltIn);
    }
  }
  createNewTemplate() {
    const currentTemplate = this.getCurrentTemplate();
    const basePrompt = (currentTemplate == null ? void 0 : currentTemplate.prompt) || "";
    const modal = new TextInputModal(
      this.app,
      "Enter template name",
      "",
      (name) => {
        var _a;
        const id = `custom-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
        const newTemplate = {
          id,
          name,
          prompt: basePrompt,
          isBuiltIn: false
        };
        this.templates.push(newTemplate);
        this.updateDropdownOptions();
        (_a = this.dropdownComponent) == null ? void 0 : _a.setValue(id);
        this.currentTemplateId = id;
        this.updateEditorSection();
        new import_obsidian41.Notice(`Created template: ${name}`);
      }
    );
    modal.open();
  }
  renameTemplate() {
    const currentTemplate = this.getCurrentTemplate();
    if (!currentTemplate || currentTemplate.isBuiltIn) return;
    const modal = new TextInputModal(
      this.app,
      "Enter new name",
      currentTemplate.name,
      (newName) => {
        var _a;
        currentTemplate.name = newName;
        this.updateDropdownOptions();
        (_a = this.dropdownComponent) == null ? void 0 : _a.setValue(this.currentTemplateId);
        new import_obsidian41.Notice(`Renamed to: ${newName}`);
      }
    );
    modal.open();
  }
  copyTemplate() {
    const currentTemplate = this.getCurrentTemplate();
    if (!currentTemplate) return;
    const modal = new TextInputModal(
      this.app,
      "Enter name for copy",
      `${currentTemplate.name} (Copy)`,
      (name) => {
        var _a;
        const id = `custom-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
        const newTemplate = {
          id,
          name,
          prompt: currentTemplate.prompt,
          isBuiltIn: false
        };
        this.templates.push(newTemplate);
        this.updateDropdownOptions();
        (_a = this.dropdownComponent) == null ? void 0 : _a.setValue(id);
        this.currentTemplateId = id;
        this.updateEditorSection();
        new import_obsidian41.Notice(`Created copy: ${name}`);
      }
    );
    modal.open();
  }
  deleteTemplate() {
    var _a;
    const currentTemplate = this.getCurrentTemplate();
    if (!currentTemplate || currentTemplate.isBuiltIn) return;
    const confirmed = window.confirm(`Delete template "${currentTemplate.name}"? This cannot be undone.`);
    if (!confirmed) return;
    this.templates = this.templates.filter((t2) => t2.id !== this.currentTemplateId);
    if (this.templates.length > 0) {
      this.currentTemplateId = this.templates[0].id;
    } else {
      this.currentTemplateId = "commercial_genre";
    }
    this.updateDropdownOptions();
    (_a = this.dropdownComponent) == null ? void 0 : _a.setValue(this.currentTemplateId);
    this.updateEditorSection();
    new import_obsidian41.Notice(`Deleted template: ${currentTemplate.name}`);
  }
  saveChanges() {
    const currentTemplate = this.getCurrentTemplate();
    if (!currentTemplate || currentTemplate.isBuiltIn) return;
    if (this.textareaEl) {
      currentTemplate.prompt = this.textareaEl.value;
    }
    this.isDirty = false;
    this.updateButtonStates();
    new import_obsidian41.Notice("Template saved");
  }
  async setActiveAndClose() {
    if (this.isDirty) {
      this.saveChanges();
    }
    this.plugin.settings.aiContextTemplates = this.templates;
    this.plugin.settings.activeAiContextTemplateId = this.currentTemplateId;
    await this.plugin.saveSettings();
    const currentTemplate = this.getCurrentTemplate();
    new import_obsidian41.Notice(`Active template: ${(currentTemplate == null ? void 0 : currentTemplate.name) || "Unknown"}`);
    this.onSave();
    this.close();
  }
};

// src/settings/sections/AiSection.ts
init_aiOutput();
function renderAiSection(params) {
  var _a;
  const { app, plugin, containerEl } = params;
  const aiHeading = new import_obsidian42.Setting(containerEl).setName("AI LLM for scene analysis").setHeading();
  addWikiLink(aiHeading, "Settings#ai");
  const getActiveTemplateName = () => {
    const templates = plugin.settings.aiContextTemplates || [];
    const activeId = plugin.settings.activeAiContextTemplateId;
    const active = templates.find((t2) => t2.id === activeId);
    return (active == null ? void 0 : active.name) || "Generic Editor";
  };
  const contextTemplateSetting = new import_obsidian42.Setting(containerEl).setName("AI prompt role & context template").setDesc(`Active: ${getActiveTemplateName()}`).addExtraButton((button) => button.setIcon("gear").setTooltip("Manage context templates for AI prompt generation and Gossamer score generation").onClick(() => {
    const modal = new AiContextModal(app, plugin, () => {
      contextTemplateSetting.setDesc(`Active: ${getActiveTemplateName()}`);
    });
    modal.open();
  }));
  new import_obsidian42.Setting(containerEl).setName("Enable AI LLM features").setDesc("Show command palette options and UI scene analysis colors and hover synopsis. When off, these visuals are hidden, but metadata remains unchanged.").addToggle((toggle) => {
    var _a2;
    return toggle.setValue((_a2 = plugin.settings.enableAiSceneAnalysis) != null ? _a2 : true).onChange(async (value) => {
      plugin.settings.enableAiSceneAnalysis = value;
      await plugin.saveSettings();
      params.toggleAiSettingsVisibility(value);
      plugin.refreshTimelineIfNeeded(null);
    });
  });
  const tripletDisplaySetting = new import_obsidian42.Setting(containerEl).setName("Show previous and next scene analysis").setDesc("When enabled, scene hover metadata include the AI pulse for the previous and next scenes. Turn off to display only the current scene for a more compact view.").addToggle((toggle) => {
    var _a2;
    return toggle.setValue((_a2 = plugin.settings.showFullTripletAnalysis) != null ? _a2 : true).onChange(async (value) => {
      plugin.settings.showFullTripletAnalysis = value;
      await plugin.saveSettings();
      plugin.refreshTimelineIfNeeded(null);
    });
  });
  params.addAiRelatedElement(tripletDisplaySetting.settingEl);
  const modelPickerSetting = new import_obsidian42.Setting(containerEl).setName("Model").setDesc('Pick preferred model for advanced writing analysis. Models marked "Latest" auto-update to the newest version.');
  const controlRow = modelPickerSetting.controlEl.createDiv({ cls: "rt-model-picker-row" });
  const guidanceEl = controlRow.createDiv({ cls: "rt-model-guidance" });
  const dropdownContainer = controlRow.createDiv({ cls: "rt-model-picker-select" });
  const dropdownComponent = new import_obsidian42.DropdownComponent(dropdownContainer);
  dropdownComponent.selectEl.classList.add("rt-setting-dropdown", "rt-provider-dropdown");
  {
    const providerLabel = {
      anthropic: "Anthropic",
      gemini: "Gemini",
      openai: "OpenAI",
      local: "Local / OpenAI Compatible"
    };
    const orderedProviders = ["anthropic", "gemini", "openai"];
    const choices = orderedProviders.flatMap((provider) => {
      const models = CURATED_MODELS[provider] || [];
      return models.map((model) => ({
        optionId: `${provider}:${model.id}`,
        provider,
        modelId: model.id,
        label: `${providerLabel[provider]} \u2014 ${model.label}`,
        guidance: model.guidance
      }));
    });
    choices.push({
      optionId: "local:custom",
      provider: "local",
      modelId: "custom",
      label: "Local / OpenAI Compatible",
      guidance: "Use a local LLM (like Ollama) or any OpenAI-compatible API. Configure URL and Model ID below."
    });
    choices.forEach((opt) => {
      dropdownComponent.addOption(opt.optionId, opt.label);
    });
    const findDefaultChoice = () => {
      const provider = plugin.settings.defaultAiProvider || "openai";
      if (provider === "local") {
        return choices.find((c) => c.provider === "local");
      }
      const modelId = provider === "anthropic" ? plugin.settings.anthropicModelId : provider === "gemini" ? plugin.settings.geminiModelId : plugin.settings.openaiModelId;
      return choices.find((choice) => choice.provider === provider && choice.modelId === modelId) || choices.find((choice) => choice.provider === provider) || choices[0];
    };
    const updateGuidance = (choice) => {
      guidanceEl.empty();
      if (!choice) {
        guidanceEl.setText("Select a model to see guidance on when to use it.");
        return;
      }
      const match = choice.guidance.match(/\[FYI\]\((https?:\/\/[^\s)]+)\)/i);
      const summary = match ? choice.guidance.replace(match[0], "").trim() : choice.guidance;
      const text = document.createElement("span");
      text.textContent = summary;
      guidanceEl.appendChild(text);
      if (match) {
        guidanceEl.appendChild(document.createTextNode(" "));
        const anchor = guidanceEl.createEl("a", { text: "FYI", href: match[1] });
        anchor.target = "_blank";
        anchor.rel = "noopener";
      }
    };
    const defaultChoice = findDefaultChoice();
    if (defaultChoice) {
      dropdownComponent.setValue(defaultChoice.optionId);
      updateGuidance(defaultChoice);
    } else {
      updateGuidance();
    }
    dropdownComponent.onChange(async (value) => {
      const choice = choices.find((c) => c.optionId === value);
      if (!choice) return;
      plugin.settings.defaultAiProvider = choice.provider;
      if (choice.provider === "anthropic") plugin.settings.anthropicModelId = choice.modelId;
      if (choice.provider === "gemini") plugin.settings.geminiModelId = choice.modelId;
      if (choice.provider === "openai") plugin.settings.openaiModelId = choice.modelId;
      await plugin.saveSettings();
      params.refreshProviderDimming();
      updateGuidance(choice);
    });
  }
  params.addAiRelatedElement(modelPickerSetting.settingEl);
  const anthropicSection = containerEl.createDiv({ cls: "rt-provider-section rt-provider-anthropic" });
  const geminiSection = containerEl.createDiv({ cls: "rt-provider-section rt-provider-gemini" });
  const openaiSection = containerEl.createDiv({ cls: "rt-provider-section rt-provider-openai" });
  params.setProviderSections({ anthropic: anthropicSection, gemini: geminiSection, openai: openaiSection });
  params.addAiRelatedElement(anthropicSection);
  params.addAiRelatedElement(geminiSection);
  params.addAiRelatedElement(openaiSection);
  const anthropicKeySetting = new import_obsidian42.Setting(anthropicSection).setName("Anthropic API key").setDesc((() => {
    const frag = document.createDocumentFragment();
    const span = document.createElement("span");
    span.textContent = "Your Anthropic API key for using Claude AI features. ";
    const link = document.createElement("a");
    link.href = "https://platform.claude.com";
    link.textContent = "Get key";
    link.target = "_blank";
    link.rel = "noopener";
    frag.appendChild(span);
    frag.appendChild(link);
    return frag;
  })()).addText((text) => {
    text.inputEl.addClass("rt-input-full");
    text.setPlaceholder("Enter your Anthropic API key").setValue(plugin.settings.anthropicApiKey || "");
    text.onChange(() => {
      text.inputEl.removeClass("rt-setting-input-success");
      text.inputEl.removeClass("rt-setting-input-error");
    });
    plugin.registerDomEvent(text.inputEl, "keydown", (evt) => {
      if (evt.key === "Enter") {
        evt.preventDefault();
        text.inputEl.blur();
      }
    });
    const handleBlur = async () => {
      const trimmed = text.getValue().trim();
      plugin.settings.anthropicApiKey = trimmed;
      await plugin.saveSettings();
      params.setKeyInputRef("anthropic", text.inputEl);
      if (trimmed) {
        params.scheduleKeyValidation("anthropic");
      }
    };
    plugin.registerDomEvent(text.inputEl, "blur", () => {
      void handleBlur();
    });
  });
  anthropicKeySetting.settingEl.addClass("rt-setting-full-width-input");
  const geminiKeySetting = new import_obsidian42.Setting(geminiSection).setName("Gemini API key").setDesc((() => {
    const frag = document.createDocumentFragment();
    const span = document.createElement("span");
    span.textContent = "Your Gemini API key for using Google Gemini models. ";
    const link = document.createElement("a");
    link.href = "https://aistudio.google.com";
    link.textContent = "Get key";
    link.target = "_blank";
    link.rel = "noopener";
    frag.appendChild(span);
    frag.appendChild(link);
    return frag;
  })()).addText((text) => {
    text.inputEl.addClass("rt-input-full");
    text.setPlaceholder("Enter your Gemini API key").setValue(plugin.settings.geminiApiKey || "");
    text.onChange(() => {
      text.inputEl.removeClass("rt-setting-input-success");
      text.inputEl.removeClass("rt-setting-input-error");
    });
    plugin.registerDomEvent(text.inputEl, "keydown", (evt) => {
      if (evt.key === "Enter") {
        evt.preventDefault();
        text.inputEl.blur();
      }
    });
    const handleBlur = async () => {
      const trimmed = text.getValue().trim();
      plugin.settings.geminiApiKey = trimmed;
      await plugin.saveSettings();
      params.setKeyInputRef("gemini", text.inputEl);
      if (trimmed) {
        params.scheduleKeyValidation("gemini");
      }
    };
    plugin.registerDomEvent(text.inputEl, "blur", () => {
      void handleBlur();
    });
  });
  geminiKeySetting.settingEl.addClass("rt-setting-full-width-input");
  const openAiKeySetting = new import_obsidian42.Setting(openaiSection).setName("OpenAI API key").setDesc((() => {
    const frag = document.createDocumentFragment();
    const span = document.createElement("span");
    span.textContent = "Your OpenAI API key for using ChatGPT AI features. ";
    const link = document.createElement("a");
    link.href = "https://platform.openai.com";
    link.textContent = "Get key";
    link.target = "_blank";
    link.rel = "noopener";
    frag.appendChild(span);
    frag.appendChild(link);
    return frag;
  })()).addText((text) => {
    text.inputEl.addClass("rt-input-full");
    text.setPlaceholder("Enter your API key").setValue(plugin.settings.openaiApiKey || "");
    text.onChange(() => {
      text.inputEl.removeClass("rt-setting-input-success");
      text.inputEl.removeClass("rt-setting-input-error");
    });
    plugin.registerDomEvent(text.inputEl, "keydown", (evt) => {
      if (evt.key === "Enter") {
        evt.preventDefault();
        text.inputEl.blur();
      }
    });
    const handleBlur = async () => {
      const trimmed = text.getValue().trim();
      plugin.settings.openaiApiKey = trimmed;
      await plugin.saveSettings();
      params.setKeyInputRef("openai", text.inputEl);
      text.inputEl.removeClass("rt-setting-input-success");
      text.inputEl.removeClass("rt-setting-input-error");
      if (trimmed && !trimmed.startsWith("sk-")) {
        text.inputEl.addClass("rt-setting-input-error");
        new import_obsidian42.Notice('This does not look like an OpenAI secret key. Keys start with "sk-".');
      } else if (trimmed) {
        params.scheduleKeyValidation("openai");
      }
    };
    plugin.registerDomEvent(text.inputEl, "blur", () => {
      void handleBlur();
    });
  });
  openAiKeySetting.settingEl.addClass("rt-setting-full-width-input");
  const localSection = containerEl.createDiv({ cls: "rt-provider-section rt-provider-local" });
  params.setProviderSections({ anthropic: anthropicSection, gemini: geminiSection, openai: openaiSection, local: localSection });
  params.addAiRelatedElement(localSection);
  let localModelText = null;
  const localBaseUrlSetting = new import_obsidian42.Setting(localSection).setName("Local LLM Base URL").setDesc('The API endpoint. For Ollama, use "http://localhost:11434/v1". For LM Studio, use "http://localhost:1234/v1".').addText((text) => {
    text.inputEl.addClass("rt-input-full");
    text.setPlaceholder("http://localhost:11434/v1").setValue(plugin.settings.localBaseUrl || "http://localhost:11434/v1");
    text.onChange(() => {
      text.inputEl.removeClass("rt-setting-input-success");
      text.inputEl.removeClass("rt-setting-input-error");
    });
    plugin.registerDomEvent(text.inputEl, "keydown", (evt) => {
      if (evt.key === "Enter") {
        evt.preventDefault();
        text.inputEl.blur();
      }
    });
    const handleBlur = async () => {
      plugin.settings.localBaseUrl = text.getValue().trim();
      await plugin.saveSettings();
      params.scheduleKeyValidation("local");
    };
    plugin.registerDomEvent(text.inputEl, "blur", () => {
      void handleBlur();
    });
    params.setLocalConnectionInputs({ baseInput: text.inputEl });
  });
  localBaseUrlSetting.settingEl.addClass("rt-setting-full-width-input");
  const localWarningSection = localSection.createDiv({ cls: "rt-local-llm-advisory" });
  localWarningSection.createEl("strong", { text: "Advisory Note", cls: "rt-local-llm-advisory-title" });
  const aiOutputFolder = resolveAiOutputFolder(plugin);
  localWarningSection.createSpan({
    text: `By default, no LLM pulses are written to the scene when local transformer is used. Rather it is stored in a RAW AI file in the local logs output folder (${aiOutputFolder}), as the response does not follow directions and breaks the scene hover formatting. You may still write scene hover metadata with local LLM by toggling off the setting "Bypass scene hover metadata yaml writes" below.`
  });
  const localModelSetting = new import_obsidian42.Setting(localSection).setName("Model ID").setDesc('The exact model name your server expects (e.g., "llama3", "mistral-7b", "local-model").').addText((text) => {
    text.inputEl.addClass("rt-input-lg");
    localModelText = text;
    text.setPlaceholder("llama3").setValue(plugin.settings.localModelId || "llama3");
    text.onChange(() => {
      text.inputEl.removeClass("rt-setting-input-success");
      text.inputEl.removeClass("rt-setting-input-error");
    });
    plugin.registerDomEvent(text.inputEl, "keydown", (evt) => {
      if (evt.key === "Enter") {
        evt.preventDefault();
        text.inputEl.blur();
      }
    });
    const handleBlur = async () => {
      plugin.settings.localModelId = text.getValue().trim();
      await plugin.saveSettings();
      params.scheduleKeyValidation("local");
    };
    plugin.registerDomEvent(text.inputEl, "blur", () => {
      void handleBlur();
    });
    params.setLocalConnectionInputs({ modelInput: text.inputEl });
  });
  localModelSetting.addExtraButton((button) => {
    button.setIcon("refresh-ccw").setTooltip("Detect installed models and auto-fill this field").onClick(async () => {
      var _a2, _b, _c;
      const selectedProvider = plugin.settings.defaultAiProvider || "openai";
      if (selectedProvider !== "local") {
        new import_obsidian42.Notice('Select "Local / OpenAI Compatible" above to detect models.');
        return;
      }
      const baseUrl = (_a2 = plugin.settings.localBaseUrl) == null ? void 0 : _a2.trim();
      if (!baseUrl) {
        new import_obsidian42.Notice("Set the Local LLM Base URL first.");
        return;
      }
      button.setDisabled(true);
      button.setIcon("loader-2");
      try {
        const models = await fetchLocalModels(baseUrl, (_b = plugin.settings.localApiKey) == null ? void 0 : _b.trim());
        if (!Array.isArray(models) || models.length === 0) {
          new import_obsidian42.Notice("No models reported by the local server.");
          return;
        }
        const existing = (_c = plugin.settings.localModelId) == null ? void 0 : _c.trim();
        const chosen = existing && models.some((m) => m.id === existing) ? models.find((m) => m.id === existing) : models[0];
        plugin.settings.localModelId = chosen.id;
        await plugin.saveSettings();
        if (localModelText) {
          localModelText.setValue(chosen.id);
        }
        params.scheduleKeyValidation("local");
        const otherModels = models.map((m) => m.id).filter((id) => id !== chosen.id);
        const suffix = otherModels.length ? ` Also found: ${otherModels.join(", ")}.` : "";
        new import_obsidian42.Notice(`Using detected model "${chosen.id}".${suffix}`);
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        new import_obsidian42.Notice(`Unable to detect local models: ${message}`);
      } finally {
        button.setDisabled(false);
        button.setIcon("refresh-ccw");
      }
    });
  });
  const customInstructionsSetting = new import_obsidian42.Setting(localSection).setName("Custom Instructions").setDesc("Additional instructions added to the start of the prompt. Useful for fine-tuning local model behavior.").addTextArea((text) => {
    text.setPlaceholder("e.g. Maintain strict JSON formatting...").setValue(plugin.settings.localLlmInstructions || "").onChange(async (value) => {
      plugin.settings.localLlmInstructions = value;
      await plugin.saveSettings();
    });
    text.inputEl.rows = 4;
  });
  customInstructionsSetting.settingEl.addClass("rt-setting-full-width-input");
  new import_obsidian42.Setting(localSection).setName("Bypass scene hover metadata yaml writes").setDesc("Default is enabled. Local LLM triplet pulse analysis skips writing to the scene note and saves the results in the RAW AI log report instead. Recommended for local models.").addToggle((toggle) => {
    var _a2;
    return toggle.setValue((_a2 = plugin.settings.localSendPulseToAiReport) != null ? _a2 : true).onChange(async (value) => {
      plugin.settings.localSendPulseToAiReport = value;
      await plugin.saveSettings();
    });
  });
  const apiKeySetting = new import_obsidian42.Setting(localSection).setName("API Key (Optional)").setDesc("Required by some servers. For local tools like Ollama, this is usually ignored.").addText((text) => {
    text.inputEl.addClass("rt-input-full");
    text.setPlaceholder("not-needed").setValue(plugin.settings.localApiKey || "");
    text.onChange(() => {
      text.inputEl.removeClass("rt-setting-input-success");
      text.inputEl.removeClass("rt-setting-input-error");
    });
    plugin.registerDomEvent(text.inputEl, "keydown", (evt) => {
      if (evt.key === "Enter") {
        evt.preventDefault();
        text.inputEl.blur();
      }
    });
    const handleBlur = async () => {
      plugin.settings.localApiKey = text.getValue().trim();
      await plugin.saveSettings();
      params.scheduleKeyValidation("local");
    };
    plugin.registerDomEvent(text.inputEl, "blur", () => {
      void handleBlur();
    });
    params.setKeyInputRef("local", text.inputEl);
  });
  apiKeySetting.settingEl.addClass("rt-setting-full-width-input");
  params.refreshProviderDimming();
  const apiLoggingSetting = new import_obsidian42.Setting(containerEl).setName("Log AI interactions to file including sent and received payloads").setDesc('If enabled, create a new note in the "AI" folder for each AI API request/response.').addToggle((toggle) => toggle.setValue(plugin.settings.logApiInteractions).onChange(async (value) => {
    plugin.settings.logApiInteractions = value;
    await plugin.saveSettings();
  }));
  params.addAiRelatedElement(apiLoggingSetting.settingEl);
  params.toggleAiSettingsVisibility((_a = plugin.settings.enableAiSceneAnalysis) != null ? _a : true);
}

// src/utils/releases.ts
var DEFAULT_RELEASES_URL = "https://github.com/EricRhysTaylor/Radial-Timeline/releases";
function parseReleaseVersion(version) {
  if (!version) return null;
  const normalized = version.trim().replace(/^v/i, "");
  const match = normalized.match(/^(\d+)(?:\.(\d+))?(?:\.(\d+))?/);
  if (!match) return null;
  const major = Number.parseInt(match[1], 10);
  const minor = match[2] !== void 0 ? Number.parseInt(match[2], 10) : null;
  const patch = match[3] !== void 0 ? Number.parseInt(match[3], 10) : null;
  const majorLabel = minor !== null ? `${major}.${minor}` : `${major}`;
  const fullLabel = patch !== null ? `${majorLabel}.${patch}` : majorLabel;
  return { major, minor, patch, majorLabel, fullLabel };
}
function compareReleaseVersionsDesc(aVersion, bVersion) {
  var _a, _b, _c, _d;
  const a = parseReleaseVersion(aVersion);
  const b = parseReleaseVersion(bVersion);
  if (!a && !b) return 0;
  if (!a) return 1;
  if (!b) return -1;
  if (a.major !== b.major) return b.major - a.major;
  const aMinor = (_a = a.minor) != null ? _a : 0;
  const bMinor = (_b = b.minor) != null ? _b : 0;
  if (aMinor !== bMinor) return bMinor - aMinor;
  const aPatch = (_c = a.patch) != null ? _c : 0;
  const bPatch = (_d = b.patch) != null ? _d : 0;
  return bPatch - aPatch;
}
function formatPublishedDate(value) {
  if (!value) return null;
  try {
    const date = new Date(value);
    if (Number.isNaN(date.getTime())) return null;
    return date.toLocaleDateString();
  } catch (e) {
    return null;
  }
}

// src/utils/releaseNotesRenderer.ts
var import_obsidian43 = require("obsidian");
async function renderReleaseNotesList(containerEl, entries, featuredEntry, plugin, cssPrefix) {
  var _a, _b;
  for (const entry of entries) {
    const versionLabel = (_b = (_a = parseReleaseVersion(entry.version)) == null ? void 0 : _a.fullLabel) != null ? _b : entry.title || entry.version;
    const details = containerEl.createEl("details", { cls: `${cssPrefix}-details` });
    if (entry.version === featuredEntry.version) {
      details.open = true;
    }
    if (entry.version === featuredEntry.version) {
      details.addClass(`${cssPrefix}-details-major`);
    }
    const summaryEl = details.createEl("summary", { cls: `${cssPrefix}-details-summary` });
    summaryEl.createSpan({
      text: versionLabel,
      cls: `${cssPrefix}-details-summary-label`
    });
    const dateText = formatPublishedDate(entry.publishedAt);
    if (dateText) {
      summaryEl.createSpan({
        text: "\u2022",
        cls: `${cssPrefix}-details-summary-divider`
      });
      summaryEl.createSpan({
        text: dateText,
        cls: `${cssPrefix}-details-summary-date`
      });
    }
    if (entry.version === featuredEntry.version) {
      summaryEl.createSpan({
        text: "Latest",
        cls: `${cssPrefix}-details-summary-badge`
      });
    }
    const entryBody = details.createDiv({ cls: `${cssPrefix}-details-body markdown-preview-view` });
    await import_obsidian43.MarkdownRenderer.renderMarkdown(entry.body, entryBody, "", plugin);
  }
}

// src/settings/sections/ReleaseNotesSection.ts
async function renderReleaseNotesSection({ plugin, containerEl }) {
  var _a;
  const entries = plugin.getReleaseNotesEntries();
  const section = containerEl.createDiv({ cls: "rt-settings-release-notes" });
  section.createEl("h2", { text: "What's New" });
  if (!entries || entries.length === 0) {
    const fallback = section.createEl("p");
    fallback.setText("Release notes are not available in this build. ");
    const link = fallback.createEl("a", { text: "View releases on GitHub.", href: DEFAULT_RELEASES_URL });
    link.setAttr("target", "_blank");
    return;
  }
  const featuredEntry = (_a = entries[0]) != null ? _a : entries[entries.length - 1];
  await renderReleaseNotesList(section, entries, featuredEntry, plugin, "rt-settings-release-notes");
}

// src/settings/sections/PovSection.ts
var import_obsidian44 = require("obsidian");
var POV_MODE_OPTIONS = {
  off: "first listed character (pov)",
  first: "First-person (\xB9)",
  second: "Second-person (You\xB2)",
  third: "Third-person limited (\xB3)",
  omni: "Omni narrator (Omni\xB3)",
  objective: "Objective (Narrator\xB0)"
};
function renderPovSection(params) {
  const { plugin, containerEl } = params;
  const povHeading = new import_obsidian44.Setting(containerEl).setName("Point of view").setHeading();
  addWikiLink(povHeading, "Settings#pov");
  const storedMode = plugin.settings.globalPovMode;
  const currentMode = storedMode && storedMode in POV_MODE_OPTIONS ? storedMode : "off";
  if (storedMode !== currentMode) {
    plugin.settings.globalPovMode = currentMode;
    void plugin.saveSettings();
  }
  new import_obsidian44.Setting(containerEl).setName("Global POV").setDesc("Choose a default mode to apply. Scene level POV will override this global setting.").addDropdown((dropdown) => {
    Object.keys(POV_MODE_OPTIONS).forEach((key) => {
      dropdown.addOption(key, POV_MODE_OPTIONS[key]);
    });
    dropdown.setValue(currentMode);
    dropdown.onChange(async (value) => {
      var _a;
      const next = value || "off";
      plugin.settings.globalPovMode = next;
      await plugin.saveSettings();
      const debounce = (_a = plugin.settings.metadataRefreshDebounceMs) != null ? _a : 1e4;
      plugin.refreshTimelineIfNeeded(null, debounce);
    });
  });
  new import_obsidian44.Setting(containerEl).setName("Scene level YAML overrides").setDesc("Values you can use for YAML field `POV:` first, second, third, omni, objective, or a number such as two, four, count, or all to designate more than one character is carrying the scene POV. If two, for example, then the first two characters in `Character:` YAML list will get a POV mark.");
}

// src/settings/sections/PlanetaryTimeSection.ts
var import_obsidian45 = require("obsidian");
init_planetaryTime();
var DEFAULT_PROFILE = () => ({
  id: `planet-${Math.random().toString(36).slice(2, 8)}`,
  label: "New planet",
  hoursPerDay: 24,
  daysPerWeek: 7,
  daysPerYear: 365,
  epochOffsetDays: 0,
  epochLabel: "",
  monthNames: void 0,
  weekdayNames: void 0
});
var MARS_TEMPLATE_ID = "mars-template";
var MARS_PROFILE = () => ({
  id: MARS_TEMPLATE_ID,
  label: "Mars",
  hoursPerDay: 25,
  daysPerWeek: 7,
  daysPerYear: 668,
  epochOffsetDays: 0,
  epochLabel: "Sol",
  // 24 numbered months (~28 sols each)
  monthNames: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24"],
  // Darian calendar weekday names
  weekdayNames: ["Solis", "Lunae", "Martis", "Mercurii", "Jovis", "Veneris", "Saturni"]
});
function renderPlanetaryTimeSection({ plugin, containerEl }) {
  var _a;
  const profiles = plugin.settings.planetaryProfiles || [];
  if (!plugin.settings.planetaryProfiles) {
    plugin.settings.planetaryProfiles = profiles;
  }
  const headerEl = containerEl.createEl("h3", { text: t("planetary.heading") });
  addWikiLinkToElement(headerEl, "Settings#planetary-time");
  const visibilityTargets = [];
  new import_obsidian45.Setting(containerEl).setName(t("planetary.enable.name")).setDesc("Keep Earth as the planning source, use the profile label to match your planet or setting calendar. Set epoch offset to align Year 1 to a story milestone, and combine with the backdrop notes for complete context.").addToggle((toggle) => {
    toggle.setValue(!!plugin.settings.enablePlanetaryTime);
    toggle.onChange(async (value) => {
      plugin.settings.enablePlanetaryTime = value;
      applyVisibility(value);
      await plugin.saveSettings();
    });
  });
  const bodyEl = containerEl.createDiv({ cls: "rt-planetary-body" });
  visibilityTargets.push(bodyEl);
  let activeProfileId = plugin.settings.activePlanetaryProfileId || ((_a = profiles[0]) == null ? void 0 : _a.id);
  const selectorSetting = new import_obsidian45.Setting(bodyEl).setName(t("planetary.active.name")).setDesc(t("planetary.active.desc"));
  let selector;
  const activeIcon = bodyEl.createDiv({ cls: "rt-planetary-validation-icon" });
  (0, import_obsidian45.setIcon)(activeIcon, "orbit");
  const updateActiveIcon = () => {
    const profile = profiles.find((p) => p.id === activeProfileId);
    if (!profile || !activeProfileId) {
      activeIcon.classList.add("rt-planetary-hidden");
      return;
    }
    activeIcon.classList.remove("rt-planetary-hidden");
    activeIcon.classList.add("rt-valid");
    (0, import_obsidian45.setTooltip)(activeIcon, `${profile.label} Calendar Active`, { placement: "bottom" });
  };
  const renderSelector = () => {
    selectorSetting.clear();
    selectorSetting.setName(t("planetary.active.name"));
    selectorSetting.setDesc(t("planetary.active.desc"));
    selectorSetting.addDropdown((dropdown) => {
      selector = dropdown;
      if (profiles.length === 0 || !activeProfileId) {
        dropdown.addOption("", "\u2014 Make a selection \u2014");
      }
      const hasMars = profiles.some((p) => p.id === MARS_TEMPLATE_ID);
      if (!hasMars) {
        dropdown.addOption(MARS_TEMPLATE_ID, "Mars (template)");
      }
      profiles.forEach((p) => dropdown.addOption(p.id, p.label || "Unnamed"));
      dropdown.setValue(activeProfileId || "");
      dropdown.onChange(async (value) => {
        if (value === MARS_TEMPLATE_ID && !profiles.some((p) => p.id === MARS_TEMPLATE_ID)) {
          const marsProfile = MARS_PROFILE();
          profiles.push(marsProfile);
          activeProfileId = marsProfile.id;
          plugin.settings.activePlanetaryProfileId = activeProfileId;
          await plugin.saveSettings();
          renderSelector();
          renderFields();
          renderPreview();
          return;
        }
        activeProfileId = value;
        plugin.settings.activePlanetaryProfileId = value;
        await plugin.saveSettings();
        renderFields();
        renderPreview();
        updateActiveIcon();
      });
    });
    selectorSetting.addExtraButton((btn) => {
      btn.setIcon("plus");
      btn.setTooltip(t("planetary.actions.add"));
      btn.onClick(async () => {
        const profile = DEFAULT_PROFILE();
        profiles.push(profile);
        activeProfileId = profile.id;
        plugin.settings.activePlanetaryProfileId = activeProfileId;
        await plugin.saveSettings();
        renderSelector();
        renderFields();
        renderPreview();
        updateActiveIcon();
      });
    });
    selectorSetting.addExtraButton((btn) => {
      btn.setIcon("trash");
      btn.setTooltip(t("planetary.actions.delete"));
      btn.setDisabled(profiles.length === 0);
      btn.onClick(async () => {
        var _a2;
        if (!activeProfileId) return;
        const index = profiles.findIndex((p) => p.id === activeProfileId);
        if (index === -1) return;
        profiles.splice(index, 1);
        activeProfileId = (_a2 = profiles[0]) == null ? void 0 : _a2.id;
        plugin.settings.activePlanetaryProfileId = activeProfileId;
        await plugin.saveSettings();
        renderSelector();
        renderFields();
        renderPreview();
      });
    });
    selectorSetting.controlEl.prepend(activeIcon);
    updateActiveIcon();
  };
  renderSelector();
  const fieldsContainer = bodyEl.createDiv({ cls: "rt-planetary-fields" });
  const previewContainer = bodyEl.createDiv({ cls: "rt-planetary-preview" });
  visibilityTargets.push(selectorSetting.settingEl, fieldsContainer, previewContainer);
  const flash = (input, type) => {
    const successClass = "rt-setting-input-success";
    const errorClass = "rt-setting-input-error";
    input.classList.remove(type === "success" ? errorClass : successClass);
    input.classList.add(type === "success" ? successClass : errorClass);
    window.setTimeout(() => input.classList.remove(type === "success" ? successClass : errorClass), type === "success" ? 900 : 1200);
  };
  const saveProfile = async (updated, input) => {
    const result = validatePlanetaryProfile(updated);
    if (!result.ok) {
      if (input) flash(input, "error");
      return;
    }
    const idx = profiles.findIndex((p) => p.id === updated.id);
    if (idx >= 0) profiles[idx] = { ...updated };
    else profiles.push(updated);
    plugin.settings.planetaryProfiles = profiles;
    if (!plugin.settings.activePlanetaryProfileId) {
      plugin.settings.activePlanetaryProfileId = updated.id;
      activeProfileId = updated.id;
    }
    await plugin.saveSettings();
    if (input) flash(input, "success");
    renderPreview();
    updateActiveIcon();
  };
  const getActiveProfile = () => {
    return profiles.find((p) => p.id === activeProfileId) || null;
  };
  const renderFields = () => {
    fieldsContainer.empty();
    const profile = getActiveProfile();
    const hasProfile = !!profile;
    fieldsContainer.classList.toggle("rt-planetary-hidden", !hasProfile);
    previewContainer.classList.toggle("rt-planetary-hidden", !hasProfile);
    if (!hasProfile) return;
    const addNumberField = (label, key, hint) => {
      const setting = new import_obsidian45.Setting(fieldsContainer).setName(label);
      if (hint) setting.setDesc(hint);
      setting.addText((text) => {
        text.inputEl.type = "number";
        text.inputEl.min = "0";
        text.inputEl.addClass("rt-input-xs");
        const current = profile[key];
        const originalValue = current !== void 0 ? String(current) : "";
        text.setValue(originalValue);
        text.inputEl.addEventListener("blur", async () => {
          const value = text.getValue();
          if (value === originalValue) return;
          const num = parseFloat(value);
          if (!Number.isFinite(num)) {
            flash(text.inputEl, "error");
            return;
          }
          profile[key] = num;
          await saveProfile(profile, text.inputEl);
        });
      });
    };
    const addTextField = (label, key, placeholder, onSave, sizeClass = "rt-input-lg") => {
      const setting = new import_obsidian45.Setting(fieldsContainer).setName(label);
      if (placeholder) setting.setDesc(placeholder);
      setting.addText((text) => {
        const current = profile[key];
        const originalValue = current != null ? current : "";
        text.setValue(originalValue);
        text.inputEl.addClass(sizeClass);
        text.inputEl.addEventListener("blur", async () => {
          const value = text.getValue();
          if (value === originalValue) return;
          profile[key] = value;
          await saveProfile(profile, text.inputEl);
          if (onSave) onSave();
        });
      });
    };
    addTextField(t("planetary.fields.profileName"), "label", void 0, renderSelector);
    addNumberField(t("planetary.fields.hoursPerDay"), "hoursPerDay", "Length of a local day in Earth hours (Earth = 24).");
    addNumberField(t("planetary.fields.daysPerWeek"), "daysPerWeek", "Local days in a week (Earth = 7).");
    addNumberField(t("planetary.fields.daysPerYear"), "daysPerYear", "Local days in a year (Earth = 365).");
    addNumberField(
      t("planetary.fields.epochOffset"),
      "epochOffsetDays",
      "Move your calendar's Year 1, Day 1 forward or back. Example: +18,000 starts your story's Year 1 around modern day. Leave at 0 if you don't need a real-world anchor."
    );
    addTextField(t("planetary.fields.epochLabel"), "epochLabel", 'Shown before YEAR (e.g., "AD", "CE", "Sol").');
    new import_obsidian45.Setting(fieldsContainer).setName(t("planetary.fields.monthNames")).setDesc("Optional. Determines how the year is divided. Provide names to set the month count (e.g. 4 names = 4 months). Leave blank for 12 numbered months.").addText((text) => {
      text.inputEl.addClass("rt-input-lg");
      const originalValue = (profile.monthNames || []).join(", ");
      text.setValue(originalValue);
      text.inputEl.addEventListener("blur", async () => {
        const value = text.getValue();
        if (value === originalValue) return;
        profile.monthNames = parseCommaNames(value);
        await saveProfile(profile, text.inputEl);
      });
    });
    new import_obsidian45.Setting(fieldsContainer).setName(t("planetary.fields.weekdayNames")).setDesc("Optional. Sets weekday labels; leave blank for numbered weekdays.").addText((text) => {
      text.inputEl.addClass("rt-input-lg");
      const originalValue = (profile.weekdayNames || []).join(", ");
      text.setValue(originalValue);
      text.inputEl.addEventListener("blur", async () => {
        const value = text.getValue();
        if (value === originalValue) return;
        profile.weekdayNames = parseCommaNames(value);
        await saveProfile(profile, text.inputEl);
      });
    });
  };
  const renderPreview = () => {
    previewContainer.empty();
    const profile = getActiveProfile();
    const hasProfile = !!profile;
    previewContainer.classList.toggle("rt-planetary-hidden", !hasProfile);
    fieldsContainer.classList.toggle("rt-planetary-hidden", !hasProfile);
    if (!hasProfile) return;
    const result = convertFromEarth(/* @__PURE__ */ new Date(), profile);
    const header = previewContainer.createDiv({ cls: "rt-planetary-preview-heading" });
    header.setText(`Quick preview (Earth \u2192 ${profile.label || "local"})`);
    const body = previewContainer.createDiv({ cls: "rt-planetary-preview-body" });
    if (!result) {
      body.setText(t("planetary.preview.invalid"));
      return;
    }
    body.setText(result.formatted);
  };
  const applyVisibility = (enabled) => {
    visibilityTargets.forEach((el) => {
      if (!el) return;
      el.classList.toggle("rt-planetary-hidden", !enabled);
    });
  };
  renderFields();
  renderPreview();
  applyVisibility(!!plugin.settings.enablePlanetaryTime);
}

// src/settings/SettingsTab.ts
var RadialTimelineSettingsTab = class extends import_obsidian46.PluginSettingTab {
  // Store references to AI-related settings
  // TODO: Migrate to Obsidian Keychain API when available (v1.11.0+)
  // Currently storing keys in data.json (plain text) because app.keychain is not yet exposed in the public API types.
  // See: https://obsidian.md/changelog/2025-12-10-desktop-v1.11.0/
  constructor(app, plugin) {
    super(app, plugin);
    this.readmeComponent = null;
    // <<< ADD THIS LINE
    this._providerSections = {};
    this._keyValidateTimers = {};
    this._aiRelatedElements = [];
    this.plugin = plugin;
  }
  // Folder suggest implementation delegated to its own class
  attachFolderSuggest(text) {
    const inputEl = text.inputEl;
    new FolderSuggest(this.app, inputEl, this.plugin, text);
  }
  // Dims non-selected provider sections based on chosen model/provider
  // Also disables input fields in dimmed sections
  refreshProviderDimming() {
    const selected = this.plugin.settings.defaultAiProvider || "openai";
    const map = this._providerSections;
    ["anthropic", "gemini", "openai", "local"].forEach((key) => {
      const el = map[key];
      if (!el) return;
      const isSelected = key === selected;
      if (isSelected) el.classList.remove("dimmed");
      else el.classList.add("dimmed");
      const inputs = el.querySelectorAll("input, textarea, button, select");
      inputs.forEach((input) => {
        if (isSelected) {
          input.removeAttribute("disabled");
        } else {
          input.setAttribute("disabled", "true");
        }
      });
      const clickableIcons = el.querySelectorAll(".clickable-icon");
      clickableIcons.forEach((icon) => {
        const htmlIcon = icon;
        if (isSelected) {
          htmlIcon.removeAttribute("aria-disabled");
          htmlIcon.style.pointerEvents = "";
        } else {
          htmlIcon.setAttribute("aria-disabled", "true");
          htmlIcon.style.pointerEvents = "none";
        }
      });
    });
  }
  // Toggle visibility of AI-related settings
  toggleAiSettingsVisibility(show) {
    this._aiRelatedElements.forEach((el) => {
      if (show) {
        el.classList.remove("rt-settings-hidden");
        el.classList.add("rt-settings-visible");
      } else {
        el.classList.remove("rt-settings-visible");
        el.classList.add("rt-settings-hidden");
      }
    });
  }
  // Debounced API key validation using zero-cost model list endpoints
  scheduleKeyValidation(provider) {
    var _a, _b, _c;
    const prior = this._keyValidateTimers[provider];
    if (prior) window.clearTimeout(prior);
    if (provider === "local") {
      const selectedProvider = this.plugin.settings.defaultAiProvider || "openai";
      if (selectedProvider !== "local") {
        return;
      }
      const baseInput = this._localBaseUrlInput;
      const modelInput = this._localModelIdInput;
      if (!baseInput || !modelInput) return;
      const baseUrl = (_a = baseInput.value) == null ? void 0 : _a.trim();
      const modelId = (_b = modelInput.value) == null ? void 0 : _b.trim();
      if (!baseUrl || !modelId) return;
      this._keyValidateTimers[provider] = window.setTimeout(async () => {
        var _a2;
        delete this._keyValidateTimers[provider];
        const targets = [baseInput, modelInput];
        targets.forEach((el) => {
          el.removeClass("rt-setting-input-success");
          el.removeClass("rt-setting-input-error");
        });
        const result = await validateLocalModelAvailability(
          baseUrl,
          modelId,
          (_a2 = this.plugin.settings.localApiKey) == null ? void 0 : _a2.trim()
        );
        if (result.reachable && result.hasModel) {
          targets.forEach((el) => {
            el.addClass("rt-setting-input-success");
            window.setTimeout(() => el.removeClass("rt-setting-input-success"), 1200);
          });
        } else {
          targets.forEach((el) => {
            el.addClass("rt-setting-input-error");
            window.setTimeout(() => el.removeClass("rt-setting-input-error"), 1400);
          });
          if (result.message) {
            new import_obsidian46.Notice(`Local AI validation failed: ${result.message}`);
          }
        }
      }, 800);
      return;
    }
    const inputEl = provider === "anthropic" ? this._anthropicKeyInput : provider === "gemini" ? this._geminiKeyInput : this._openaiKeyInput;
    if (!inputEl) return;
    const key = (_c = inputEl.value) == null ? void 0 : _c.trim();
    if (!key) return;
    if (key.length < 8) return;
    this._keyValidateTimers[provider] = window.setTimeout(async () => {
      delete this._keyValidateTimers[provider];
      inputEl.removeClass("rt-setting-input-success");
      inputEl.removeClass("rt-setting-input-error");
      try {
        if (provider === "anthropic") {
          await fetchAnthropicModels(key);
        } else if (provider === "gemini") {
          await fetchGeminiModels(key);
        } else {
          await fetchOpenAiModels(key);
        }
        inputEl.addClass("rt-setting-input-success");
        window.setTimeout(() => inputEl.removeClass("rt-setting-input-success"), 1200);
      } catch (e) {
        const msg = e instanceof Error ? e.message : String(e);
        if (/401|unauthorized|invalid/i.test(msg)) {
          inputEl.addClass("rt-setting-input-error");
          window.setTimeout(() => inputEl.removeClass("rt-setting-input-error"), 1400);
        }
      }
    }, 800);
  }
  // Method to show path suggestions
  showPathSuggestions(currentValue, container, textInput) {
    const validPaths = this.plugin.settings.validFolderPaths;
    const filteredPaths = validPaths.filter(
      (path) => path.toLowerCase().includes(currentValue.toLowerCase()) || currentValue === ""
    );
    container.empty();
    if (filteredPaths.length === 0) {
      container.classList.add("hidden");
      return;
    }
    container.classList.remove("hidden");
    filteredPaths.forEach((path) => {
      const suggestionEl = container.createDiv({ cls: "rt-source-path-suggestion-item" });
      suggestionEl.textContent = path;
      this.plugin.registerDomEvent(suggestionEl, "click", async () => {
        textInput.setValue(path);
        const ok = await this.plugin.validateAndRememberPath(path);
        if (ok) {
          this.plugin.settings.sourcePath = path;
          await this.plugin.saveSettings();
          container.classList.add("hidden");
          textInput.inputEl.removeClass("rt-setting-input-error");
          textInput.inputEl.addClass("rt-setting-input-success");
          window.setTimeout(() => {
            textInput.inputEl.removeClass("rt-setting-input-success");
          }, 1e3);
        } else {
          textInput.inputEl.addClass("rt-setting-input-error");
          window.setTimeout(() => textInput.inputEl.removeClass("rt-setting-input-error"), 2e3);
        }
        try {
          textInput.inputEl.focus();
        } catch (e) {
        }
      });
    });
  }
  // Method to update the selected suggestion highlighting
  updateSelectedSuggestion(suggestions, selectedIndex) {
    suggestions.forEach((suggestion, index) => {
      const el = suggestion;
      if (index === selectedIndex) {
        el.classList.add("selected");
      } else {
        el.classList.remove("selected");
      }
    });
  }
  // Helper function to validate hex color
  isValidHex(hex) {
    return /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hex);
  }
  // Render Backup and Safety section (replacing Patreon section)
  renderPatreonSection(containerEl) {
    const patreonContainer = containerEl.createDiv({ cls: "rt-patreon-support" });
    const bgLogo = patreonContainer.createDiv({ cls: "rt-patreon-bg-logo" });
    const bgSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    bgSvg.setAttribute("viewBox", "0 0 1080 1080");
    bgSvg.classList.add("rt-patreon-bg-svg");
    const bgPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
    bgPath.setAttribute("d", "M1033.05,324.45c-0.19-137.9-107.59-250.92-233.6-291.7c-156.48-50.64-362.86-43.3-512.28,27.2 C106.07,145.41,49.18,332.61,47.06,519.31c-1.74,153.5,13.58,557.79,241.62,560.67c169.44,2.15,194.67-216.18,273.07-321.33 c55.78-74.81,127.6-95.94,216.01-117.82C929.71,603.22,1033.27,483.3,1033.05,324.45z");
    bgSvg.appendChild(bgPath);
    bgLogo.appendChild(bgSvg);
    const contentContainer = patreonContainer.createDiv({ cls: "rt-patreon-content" });
    const titleRow = contentContainer.createDiv({ cls: "rt-patreon-title-row" });
    const iconSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    iconSvg.setAttribute("width", "24");
    iconSvg.setAttribute("height", "24");
    iconSvg.setAttribute("viewBox", "0 0 24 24");
    iconSvg.setAttribute("fill", "none");
    iconSvg.setAttribute("stroke", "currentColor");
    iconSvg.setAttribute("stroke-width", "2");
    iconSvg.setAttribute("stroke-linecap", "round");
    iconSvg.setAttribute("stroke-linejoin", "round");
    iconSvg.classList.add("lucide", "lucide-archive-restore", "rt-patreon-title-icon");
    iconSvg.innerHTML = `<rect width="20" height="5" x="2" y="3" rx="1"/><path d="M4 8v11a2 2 0 0 0 2 2h2"/><path d="M20 8v11a2 2 0 0 1-2 2h-2"/><path d="m9 15 3-3 3 3"/><path d="M12 12v9"/>`;
    titleRow.appendChild(iconSvg);
    const title = titleRow.createEl("h3", { cls: "rt-patreon-title" });
    title.createSpan({ text: "Protect Your Work" });
    const description = contentContainer.createEl("p", { cls: "rt-patreon-description" });
    const backupPara = description.createDiv();
    backupPara.createSpan({ text: "It is strongly recommended for you to " });
    backupPara.createEl("a", { text: "automate backups", href: "https://help.obsidian.md/backup" });
    backupPara.createSpan({ text: ". The native " });
    backupPara.createEl("a", { text: "Obsidian Sync", href: "https://obsidian.md/sync" });
    backupPara.createSpan({ text: " service and community favorite " });
    backupPara.createEl("a", { text: "Obsidian Git", href: "https://obsidian.md/plugins?id=obsidian-git" });
    backupPara.createSpan({ text: " are excellent choices." });
    const syncPara = description.createDiv({ cls: "rt-patreon-sync-para" });
    syncPara.createEl("strong", { text: "Sync Conflicts: " });
    syncPara.createSpan({ text: "Avoid mixing sync services. If using iCloud on macOS alongside another sync tool, append " });
    syncPara.createEl("code", { text: ".nosync" });
    syncPara.createSpan({ text: " to the folder name to stop iCloud from syncing the vault. " });
    syncPara.createEl("a", { text: "Read the Obsidian Sync Guide.", href: "https://help.obsidian.md/sync/switch" });
  }
  async fetchPatreonMemberCount() {
    var _a, _b;
    const url = "https://raw.githubusercontent.com/ericrhystaylor/radial-timeline/master/src/data/patreonStats.json";
    try {
      const response = await (0, import_obsidian46.requestUrl)({ url, method: "GET" });
      if (response.status !== 200) {
        return null;
      }
      const data = (_a = response.json) != null ? _a : JSON.parse(response.text);
      return (_b = data.memberCount) != null ? _b : null;
    } catch (error) {
      console.warn("Unable to fetch Patreon member count:", error);
      return null;
    }
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("rt-settings-root");
    this._aiRelatedElements = [];
    this.renderPatreonSection(containerEl);
    renderGeneralSection({ app: this.app, plugin: this.plugin, attachFolderSuggest: (t2) => this.attachFolderSuggest(t2), containerEl });
    renderPublicationSection({ app: this.app, plugin: this.plugin, containerEl });
    renderPovSection({ plugin: this.plugin, containerEl });
    renderChronologueSection({ app: this.app, plugin: this.plugin, containerEl });
    renderStoryBeatsSection({ app: this.app, plugin: this.plugin, containerEl });
    renderPlanetaryTimeSection({ app: this.app, plugin: this.plugin, containerEl });
    renderAiSection({
      app: this.app,
      plugin: this.plugin,
      containerEl,
      addAiRelatedElement: (el) => this._aiRelatedElements.push(el),
      toggleAiSettingsVisibility: (show) => this.toggleAiSettingsVisibility(show),
      refreshProviderDimming: () => this.refreshProviderDimming(),
      scheduleKeyValidation: (p) => this.scheduleKeyValidation(p),
      setProviderSections: (sections) => {
        this._providerSections = sections;
      },
      setKeyInputRef: (provider, input) => {
        if (provider === "anthropic") this._anthropicKeyInput = input;
        if (provider === "gemini") this._geminiKeyInput = input;
        if (provider === "openai") this._openaiKeyInput = input;
        if (provider === "local") this._localKeyInput = input;
      },
      setLocalConnectionInputs: ({ baseInput, modelInput }) => {
        if (baseInput) this._localBaseUrlInput = baseInput;
        if (modelInput) this._localModelIdInput = modelInput;
      }
    });
    renderAdvancedSection({ app: this.app, plugin: this.plugin, containerEl });
    renderColorsSection(containerEl, this.plugin);
    void renderReleaseNotesSection({ plugin: this.plugin, containerEl });
    renderReadmeSection({ app: this.app, containerEl, setComponentRef: (c) => {
      this.readmeComponent = c;
    } });
  }
  hide() {
    if (this.readmeComponent) {
      this.readmeComponent.unload();
      this.readmeComponent = null;
    }
  }
};

// src/main.ts
init_tooltip();

// src/services/ReleaseNotesService.ts
var import_obsidian48 = require("obsidian");

// src/modals/ReleaseNotesModal.ts
var import_obsidian47 = require("obsidian");
var HERO_PREVIEW_LIMIT = 260;
function buildHeroPreview(body) {
  if (!body) {
    return null;
  }
  const candidate = body.split(/\n{2,}/).map((block) => block.trim()).find((block) => block.length > 0 && !/^#+\s+/.test(block));
  if (!candidate) {
    return null;
  }
  const sanitized = candidate.replace(/!\[[^\]]*]\([^)]*\)/g, "").replace(/\[(.*?)\]\([^)]*\)/g, "$1").replace(/^[>*\-\d.]+\s+/gm, "").replace(/[*_`]/g, "").trim();
  if (!sanitized) {
    return null;
  }
  return sanitized.length > HERO_PREVIEW_LIMIT ? `${sanitized.slice(0, HERO_PREVIEW_LIMIT - 1).trimEnd()}\u2026` : sanitized;
}
var ReleaseNotesModal = class extends import_obsidian47.Modal {
  constructor(app, plugin, entries, featuredEntry) {
    super(app);
    this.plugin = plugin;
    this.entries = entries;
    this.featuredEntry = featuredEntry;
  }
  async onOpen() {
    var _a, _b, _c;
    const { contentEl, titleEl, modalEl } = this;
    this.modalEl.addClass("rt-release-notes-modal");
    contentEl.empty();
    if (modalEl) modalEl.classList.add("rt-pulse-modal-shell");
    contentEl.addClass("rt-pulse-modal");
    contentEl.addClass("rt-manuscript-surface");
    titleEl.setText("What's New");
    const versionLabel = (_b = (_a = parseReleaseVersion(this.featuredEntry.version)) == null ? void 0 : _a.fullLabel) != null ? _b : this.featuredEntry.version;
    const releaseDate = formatPublishedDate(this.featuredEntry.publishedAt);
    const heroEl = contentEl.createDiv({ cls: "rt-release-notes-hero" });
    heroEl.createSpan({ text: "Latest release", cls: "rt-release-notes-hero-badge" });
    heroEl.createEl("h3", { text: this.featuredEntry.title || versionLabel, cls: "rt-release-notes-hero-title" });
    const heroMetaEl = heroEl.createDiv({ cls: "rt-release-notes-hero-meta" });
    heroMetaEl.createSpan({ text: versionLabel, cls: "rt-release-notes-hero-version" });
    if (releaseDate) {
      heroMetaEl.createSpan({ text: releaseDate, cls: "rt-release-notes-hero-date" });
    }
    const heroPreview = buildHeroPreview(this.featuredEntry.body);
    if (heroPreview) {
      heroEl.createEl("p", { text: heroPreview, cls: "rt-release-notes-hero-description" });
    }
    const releaseUrl = (_c = this.featuredEntry.url) != null ? _c : DEFAULT_RELEASES_URL;
    const heroActions = heroEl.createDiv({ cls: "rt-release-notes-hero-actions" });
    const changelogLink = heroActions.createEl("a", {
      text: "View full changelog",
      cls: "rt-release-notes-hero-link",
      href: releaseUrl
    });
    changelogLink.setAttr("target", "_blank");
    changelogLink.setAttr("rel", "noopener");
    heroActions.createSpan({
      text: "Scroll to explore the rest of the updates",
      cls: "rt-release-notes-hero-hint"
    });
    const bodyHost = contentEl.createDiv({ cls: "rt-release-notes-modal-body" });
    await renderReleaseNotesList(bodyHost, this.entries, this.featuredEntry, this.plugin, "rt-release-notes-modal");
    const footerEl = contentEl.createDiv({ cls: "rt-release-notes-modal-footer" });
    const closeButton = footerEl.createEl("button", { text: "Close" });
    closeButton.addEventListener("click", () => this.close());
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/data/releaseNotesBundle.json
var releaseNotesBundle_default = {
  entries: [
    {
      version: "5.0.2",
      title: "5.0.2",
      body: "## What's Changed\r\n\r\n### New Features\r\n-  Book Designer Manual mode. Drag to reorder scenes in Preview ([5d3d4f4](https://github.com/EricRhysTaylor/Radial-Timeline/commit/5d3d4f4b5d638481db51fe69fadd2cfcc1958d44))\r\n-- Save templates ([5d3d4f4](https://github.com/EricRhysTaylor/Radial-Timeline/commit/5d3d4f4b5d638481db51fe69fadd2cfcc1958d44))\r\n\r\n### Bug Fixes\r\n- Scoped the settings UI to prevent CSS bleed. ([5d3d4f4](https://github.com/EricRhysTaylor/Radial-Timeline/commit/5d3d4f4b5d638481db51fe69fadd2cfcc1958d44))\r\n",
      url: "https://github.com/EricRhysTaylor/Radial-Timeline/releases/tag/untagged-8f7c47764b76859a8745",
      publishedAt: "2025-12-30T23:29:25.448Z",
      isDraft: true
    },
    {
      version: "5.0.1",
      title: "5.0.1",
      body: "## What's Changed\r\n\r\n### Bug\r\n- Release script allowed the manifest to not update properly with the new release ([4e14615](https://github.com/EricRhysTaylor/Radial-Timeline/commit/4e146158260bc80fe5228b610749c6ad152227f0)) Peventing Obsidian from detecting and updating plugin.\r\n\r\n### Improvements\r\n- New Release Alert in Timeline now shows versions on hover. Large click zone.\r\n- Update and reorganized wiki ([a83d5aa](https://github.com/EricRhysTaylor/Radial-Timeline/commit/a83d5aab00a8514dbca984d3ce96b74057f90844))\r\n\r\n### Documentation\r\n- Settings inline links to related wiki docs ([a83d5aa](https://github.com/EricRhysTaylor/Radial-Timeline/commit/a83d5aab00a8514dbca984d3ce96b74057f90844))",
      url: "https://github.com/EricRhysTaylor/Radial-Timeline/releases/tag/5.0.1",
      publishedAt: "2025-12-29T17:45:53Z",
      isDraft: false
    },
    {
      version: "5.0.0",
      title: "5.0.0",
      body: "## Major Release 5.0: A New World\r\n\r\nThis is a major update focusing on customization, quick setup, templates, and advanced world-building features.\r\n\r\n### New & Improved\r\n- **YAML Remapper**: Tie an existing/legacy project into Radial Timeline's base metadata keys.\r\n- **Advanced YAML editor**: Customize the Advanced YAML template in settings by adding, deleting keys to fit your current system. Then create a new note with this template using the Command `Create advanced note`. Or via Book designer.\r\n- **Story Beat Editor**: Edit the custom story beats in settings. Create new beats. Set the Name, Act placement. Reorder. Create.\r\n- **Alien Planet Calendar**:  Track the time in faraway (inter-planetary) time zones. View it using ALT sub-mode in Chronologue Mode.\r\n- **Act Structure Customization**: Now you can have 5 Acts or 7 or more with custom names via Settings customization.\r\n- **Book Designer**: The new modal (accessible from the new Welcome Screen or Command Palette) will let you setup a new story scaffold quickly with mini preview-timeline. Use basic or advance yaml, adjust time increment, set the Acts and  more.\r\n- **New Welcome Screen**: A redesigned welcome screen for new projects (no scenes), featuring better orientation and direct links to resources and the Book Designer button.\r\n\r\n###  Enhanced & Bugs\r\n- **Restyled Modals**: Every single modal in the plugin has been harmonized with a consistent, polished design.\r\n- **Local LLM**: More options and better integration for working with local AI models. Still a work in progress.\r\n- **Chronologue Backdrop Styling**: Updated styles for Alt and Shift backdrop interactions ([8d627a1](https://github.com/EricRhysTaylor/Radial-Timeline/commit/8d627a1c2f4d5950b386e7decb358a7aabbac3e0)).\r\n- **Backdrop Time Alignment**: Now correctly aligns with corresponding scene time indexes in outer ring ([73e0cc0](https://github.com/EricRhysTaylor/Radial-Timeline/commit/73e0cc0f57d623e8efd686dc4a6491690b0639c1)).\r\n- **Tooltips**: New tooltip styling using Obsidian bubbles ([b21e870](https://github.com/EricRhysTaylor/Radial-Timeline/commit/b21e87031ea519db8618a7a1071a8762a8b677c6)).\r\n\r\n",
      url: "https://github.com/EricRhysTaylor/Radial-Timeline/releases/tag/5.0.0",
      publishedAt: "2025-12-28T23:28:25Z",
      isDraft: false
    }
  ],
  majorVersion: "5.0.0",
  major: {
    version: "5.0.0",
    title: "5.0.0",
    body: "## Major Release 5.0: A New World\r\n\r\nThis is a major update focusing on customization, quick setup, templates, and advanced world-building features.\r\n\r\n### New & Improved\r\n- **YAML Remapper**: Tie an existing/legacy project into Radial Timeline's base metadata keys.\r\n- **Advanced YAML editor**: Customize the Advanced YAML template in settings by adding, deleting keys to fit your current system. Then create a new note with this template using the Command `Create advanced note`. Or via Book designer.\r\n- **Story Beat Editor**: Edit the custom story beats in settings. Create new beats. Set the Name, Act placement. Reorder. Create.\r\n- **Alien Planet Calendar**:  Track the time in faraway (inter-planetary) time zones. View it using ALT sub-mode in Chronologue Mode.\r\n- **Act Structure Customization**: Now you can have 5 Acts or 7 or more with custom names via Settings customization.\r\n- **Book Designer**: The new modal (accessible from the new Welcome Screen or Command Palette) will let you setup a new story scaffold quickly with mini preview-timeline. Use basic or advance yaml, adjust time increment, set the Acts and  more.\r\n- **New Welcome Screen**: A redesigned welcome screen for new projects (no scenes), featuring better orientation and direct links to resources and the Book Designer button.\r\n\r\n###  Enhanced & Bugs\r\n- **Restyled Modals**: Every single modal in the plugin has been harmonized with a consistent, polished design.\r\n- **Local LLM**: More options and better integration for working with local AI models. Still a work in progress.\r\n- **Chronologue Backdrop Styling**: Updated styles for Alt and Shift backdrop interactions ([8d627a1](https://github.com/EricRhysTaylor/Radial-Timeline/commit/8d627a1c2f4d5950b386e7decb358a7aabbac3e0)).\r\n- **Backdrop Time Alignment**: Now correctly aligns with corresponding scene time indexes in outer ring ([73e0cc0](https://github.com/EricRhysTaylor/Radial-Timeline/commit/73e0cc0f57d623e8efd686dc4a6491690b0639c1)).\r\n- **Tooltips**: New tooltip styling using Obsidian bubbles ([b21e870](https://github.com/EricRhysTaylor/Radial-Timeline/commit/b21e87031ea519db8618a7a1071a8762a8b677c6)).\r\n\r\n",
    url: "https://github.com/EricRhysTaylor/Radial-Timeline/releases/tag/5.0.0",
    publishedAt: "2025-12-28T23:28:25Z",
    isDraft: false
  },
  latest: {
    version: "5.0.2",
    title: "5.0.2",
    body: "## What's Changed\r\n\r\n### New Features\r\n-  Book Designer Manual mode. Drag to reorder scenes in Preview ([5d3d4f4](https://github.com/EricRhysTaylor/Radial-Timeline/commit/5d3d4f4b5d638481db51fe69fadd2cfcc1958d44))\r\n-- Save templates ([5d3d4f4](https://github.com/EricRhysTaylor/Radial-Timeline/commit/5d3d4f4b5d638481db51fe69fadd2cfcc1958d44))\r\n\r\n### Bug Fixes\r\n- Scoped the settings UI to prevent CSS bleed. ([5d3d4f4](https://github.com/EricRhysTaylor/Radial-Timeline/commit/5d3d4f4b5d638481db51fe69fadd2cfcc1958d44))\r\n",
    url: "https://github.com/EricRhysTaylor/Radial-Timeline/releases/tag/untagged-8f7c47764b76859a8745",
    publishedAt: "2025-12-30T23:29:25.448Z",
    isDraft: true
  },
  patches: [
    {
      version: "5.0.1",
      title: "5.0.1",
      body: "## What's Changed\r\n\r\n### Bug\r\n- Release script allowed the manifest to not update properly with the new release ([4e14615](https://github.com/EricRhysTaylor/Radial-Timeline/commit/4e146158260bc80fe5228b610749c6ad152227f0)) Peventing Obsidian from detecting and updating plugin.\r\n\r\n### Improvements\r\n- New Release Alert in Timeline now shows versions on hover. Large click zone.\r\n- Update and reorganized wiki ([a83d5aa](https://github.com/EricRhysTaylor/Radial-Timeline/commit/a83d5aab00a8514dbca984d3ce96b74057f90844))\r\n\r\n### Documentation\r\n- Settings inline links to related wiki docs ([a83d5aa](https://github.com/EricRhysTaylor/Radial-Timeline/commit/a83d5aab00a8514dbca984d3ce96b74057f90844))",
      url: "https://github.com/EricRhysTaylor/Radial-Timeline/releases/tag/5.0.1",
      publishedAt: "2025-12-29T17:45:53Z",
      isDraft: false
    }
  ]
};

// src/services/ReleaseNotesService.ts
var ReleaseNotesService = class {
  constructor(settings, saveSettings) {
    this.settings = settings;
    this.saveSettings = saveSettings;
    this.releaseNotesBundle = null;
    this.releaseModalShownThisSession = false;
    this.releaseNotesFetchPromise = null;
  }
  /**
   * Initialize service state by merging embedded release notes with cached settings.
   */
  initializeFromEmbedded() {
    var _a, _b;
    const embedded = this.loadEmbeddedReleaseNotes();
    const cached = (_a = this.settings.cachedReleaseNotes) != null ? _a : null;
    const embeddedLatest = this.extractLatestVersion(embedded);
    const cachedLatest = this.extractLatestVersion(cached);
    const useEmbedded = embedded && (!cachedLatest || embeddedLatest && compareReleaseVersionsDesc(embeddedLatest, cachedLatest) <= 0);
    if (useEmbedded) {
      this.settings.cachedReleaseNotes = embedded;
      void this.saveSettings();
      this.releaseNotesBundle = embedded;
    } else {
      this.releaseNotesBundle = (_b = cached != null ? cached : embedded) != null ? _b : null;
    }
    this.releaseModalShownThisSession = false;
  }
  getBundle() {
    return this.releaseNotesBundle;
  }
  hasShownModalThisSession() {
    return this.releaseModalShownThisSession;
  }
  markModalShown() {
    this.releaseModalShownThisSession = true;
  }
  getLatestVersion() {
    const entries = this.getEntries();
    return entries.length > 0 ? entries[0].version : null;
  }
  async maybeShowReleaseNotesModal(app, plugin) {
    var _a;
    const entries = this.getEntries();
    if (entries.length === 0) {
      throw new Error("Release bundle missing entries");
    }
    const latestEntry = entries[0];
    const latestVersion = latestEntry.version;
    if (!latestVersion) {
      throw new Error("Release bundle missing latest version");
    }
    const latestKey = this.computeEntryKey(latestEntry);
    const seenVersion = (_a = this.settings.lastSeenReleaseNotesVersion) != null ? _a : "";
    const hasSeen = seenVersion === latestKey || seenVersion === latestVersion;
    if (hasSeen || this.releaseModalShownThisSession) return;
    this.releaseModalShownThisSession = true;
    await this.markReleaseNotesSeen(latestKey);
    this.openReleaseNotesModal(app, plugin);
  }
  openReleaseNotesModal(app, plugin) {
    const entries = this.getEntries();
    if (entries.length === 0) {
      throw new Error("Release bundle missing entries");
    }
    const featuredEntry = entries[0];
    const modal = new ReleaseNotesModal(app, plugin, entries, featuredEntry);
    modal.open();
  }
  async markReleaseNotesSeen(versionKey) {
    if (this.settings.lastSeenReleaseNotesVersion === versionKey) return;
    this.settings.lastSeenReleaseNotesVersion = versionKey;
    await this.saveSettings();
  }
  async ensureReleaseNotesFresh(force) {
    if (!force && this.releaseNotesFetchPromise) {
      return this.releaseNotesFetchPromise;
    }
    const task = this.performReleaseNotesFetch(force).finally(() => {
      this.releaseNotesFetchPromise = null;
    });
    this.releaseNotesFetchPromise = task;
    return task;
  }
  getEntries() {
    const bundle = this.releaseNotesBundle;
    if (!bundle) return [];
    return this.extractEntries(bundle);
  }
  getMajorVersion() {
    var _a, _b;
    if (!this.releaseNotesBundle) return null;
    if (this.releaseNotesBundle.majorVersion) return this.releaseNotesBundle.majorVersion;
    if ((_a = this.releaseNotesBundle.major) == null ? void 0 : _a.version) return this.releaseNotesBundle.major.version;
    const entries = this.extractEntries(this.releaseNotesBundle);
    const majorEntry = this.resolveMajorEntry(this.releaseNotesBundle, entries);
    return (_b = majorEntry == null ? void 0 : majorEntry.version) != null ? _b : null;
  }
  loadEmbeddedReleaseNotes() {
    return this.normalizeBundleFromValue(releaseNotesBundle_default);
  }
  requireBundle() {
    if (!this.releaseNotesBundle) {
      throw new Error("Release notes bundle is unavailable");
    }
    return this.releaseNotesBundle;
  }
  async performReleaseNotesFetch(force) {
    const now = Date.now();
    if (!force && this.settings.releaseNotesLastFetched) {
      const last = Date.parse(this.settings.releaseNotesLastFetched);
      if (!Number.isNaN(last) && now - last < 24 * 60 * 60 * 1e3) {
        return false;
      }
    }
    try {
      const bundle = await this.downloadReleaseNotesBundle();
      if (!bundle) {
        return false;
      }
      const embedded = this.loadEmbeddedReleaseNotes();
      const merged = bundle != null ? bundle : embedded;
      if (!merged) {
        throw new Error("Downloaded release bundle is empty");
      }
      this.settings.cachedReleaseNotes = merged;
      this.settings.releaseNotesLastFetched = new Date(now).toISOString();
      await this.saveSettings();
      this.releaseNotesBundle = merged;
      return true;
    } catch (error) {
      console.error("Failed to refresh release notes from GitHub:", error);
      return false;
    }
  }
  async downloadReleaseNotesBundle() {
    var _a;
    const url = "https://raw.githubusercontent.com/ericrhystaylor/radial-timeline/master/src/data/releaseNotesBundle.json";
    try {
      const response = await (0, import_obsidian48.requestUrl)({ url, method: "GET" });
      if (response.status !== 200) {
        console.warn(`[ReleaseNotes] Unexpected response (${response.status}) fetching release bundle`);
        return null;
      }
      const payload = (_a = response.json) != null ? _a : response.text ? JSON.parse(response.text) : null;
      return this.normalizeBundleFromValue(payload);
    } catch (error) {
      console.warn("Unable to fetch release notes bundle:", error);
      return null;
    }
  }
  normalizeBundleFromValue(value) {
    if (!value || typeof value !== "object") {
      throw new Error("Release bundle payload is missing or malformed");
    }
    const normalizeEntry = (entryValue) => {
      if (!entryValue || typeof entryValue !== "object") {
        throw new Error("Release entry is invalid");
      }
      const obj = entryValue;
      const version = obj.version;
      const title = obj.title;
      const body = obj.body;
      if (typeof version !== "string" || typeof title !== "string" || typeof body !== "string") {
        throw new Error("Release entry missing required fields");
      }
      return {
        version,
        title,
        body,
        url: typeof obj.url === "string" ? obj.url : void 0,
        publishedAt: typeof obj.publishedAt === "string" ? obj.publishedAt : void 0
      };
    };
    const bundleObj = value;
    const major = bundleObj.major ? normalizeEntry(bundleObj.major) : null;
    const latest = bundleObj.latest ? normalizeEntry(bundleObj.latest) : null;
    const patches = Array.isArray(bundleObj.patches) ? bundleObj.patches.map(normalizeEntry) : void 0;
    const entries = Array.isArray(bundleObj.entries) ? bundleObj.entries.map(normalizeEntry) : void 0;
    const majorVersion = typeof bundleObj.majorVersion === "string" ? bundleObj.majorVersion : void 0;
    return {
      entries,
      majorVersion,
      major,
      latest,
      patches
    };
  }
  computeEntryKey(entry) {
    var _a;
    const signature = `${entry.version}|${entry.title}|${entry.body}|${(_a = entry.publishedAt) != null ? _a : ""}`;
    let hash = 0;
    for (let i = 0; i < signature.length; i++) {
      hash = hash * 31 + signature.charCodeAt(i) | 0;
    }
    const hashHex = (hash >>> 0).toString(16);
    return `${entry.version}|${hashHex}`;
  }
  extractLatestVersion(bundle) {
    var _a, _b, _c, _d, _e, _f;
    if (!bundle) return null;
    if (Array.isArray(bundle.entries) && bundle.entries.length > 0) {
      return (_b = (_a = bundle.entries[0]) == null ? void 0 : _a.version) != null ? _b : null;
    }
    return (_f = (_e = (_c = bundle.latest) == null ? void 0 : _c.version) != null ? _e : (_d = bundle.major) == null ? void 0 : _d.version) != null ? _f : null;
  }
  extractEntries(bundle) {
    if (Array.isArray(bundle.entries) && bundle.entries.length > 0) {
      return bundle.entries.map((entry) => ({ ...entry }));
    }
    const entries = [];
    const seen = /* @__PURE__ */ new Set();
    const addEntry = (entry) => {
      if (!entry) return;
      if (seen.has(entry.version)) return;
      seen.add(entry.version);
      entries.push(entry);
    };
    addEntry(bundle.latest);
    const bundlePatches = Array.isArray(bundle.patches) ? [...bundle.patches] : [];
    bundlePatches.sort((a, b) => compareReleaseVersionsDesc(a.version, b.version));
    bundlePatches.forEach(addEntry);
    addEntry(bundle.major);
    if (entries.length === 0 && bundle.major) {
      entries.push(bundle.major);
    }
    if (entries.length === 0 && bundle.latest) {
      entries.push(bundle.latest);
    }
    return entries;
  }
  resolveMajorEntry(bundle, entries) {
    var _a, _b, _c;
    if (entries.length === 0) return null;
    const desiredVersions = [];
    if (bundle.majorVersion) desiredVersions.push(bundle.majorVersion);
    if ((_a = bundle.major) == null ? void 0 : _a.version) desiredVersions.push(bundle.major.version);
    for (const version of desiredVersions) {
      const match = entries.find((entry) => entry.version === version);
      if (match) return match;
    }
    const majorCandidate = entries.find((entry) => {
      const info = parseReleaseVersion(entry.version);
      return !!info && info.minor === 0 && info.patch === 0;
    });
    if (majorCandidate) return majorCandidate;
    return (_c = (_b = entries[entries.length - 1]) != null ? _b : entries[0]) != null ? _c : null;
  }
};

// src/services/CommandRegistrar.ts
var import_obsidian54 = require("obsidian");
init_manuscript();
init_GossamerCommands();

// src/modals/ManageSubplotsModal.ts
var import_obsidian50 = require("obsidian");

// src/services/SubplotManagementService.ts
var import_obsidian49 = require("obsidian");
init_frontmatter();
var SubplotManagementService = class {
  constructor(app, sceneDataService) {
    this.app = app;
    this.sceneDataService = sceneDataService;
  }
  /**
   * Get all unique subplots and their scene counts.
   * Uses SceneDataService to ensure consistent filtering/parsing.
   */
  async getSubplotStats() {
    const scenes = await this.sceneDataService.getSceneData({ filterBeatsBySystem: false });
    const counts = /* @__PURE__ */ new Map();
    counts.set("Main Plot", 0);
    for (const scene of scenes) {
      if (scene.itemType !== "Scene") continue;
      const subplot = scene.subplot || "Main Plot";
      counts.set(subplot, (counts.get(subplot) || 0) + 1);
    }
    const result = [];
    for (const [name, count] of counts.entries()) {
      result.push({ name, count });
    }
    return result.sort((a, b) => {
      if (a.name === "Main Plot") return -1;
      if (b.name === "Main Plot") return 1;
      return a.name.localeCompare(b.name);
    });
  }
  /**
   * Delete a subplot from all scenes.
   * If a scene has only this subplot, it defaults to "Main Plot".
   */
  async deleteSubplot(subplotToDelete) {
    if (subplotToDelete === "Main Plot") {
      new import_obsidian49.Notice("Cannot delete Main Plot.");
      return;
    }
    const files = await this.getSceneFiles();
    let modifiedCount = 0;
    for (const file of files) {
      let processed = false;
      await this.app.fileManager.processFrontMatter(file, (fm) => {
        const normalizedFm = normalizeFrontmatterKeys(fm);
        let currentSubplots = [];
        let subplotKey = "Subplot";
        const keys = Object.keys(fm);
        const existingKey = keys.find((k) => k.toLowerCase() === "subplot");
        if (existingKey) {
          subplotKey = existingKey;
          const val = fm[existingKey];
          if (Array.isArray(val)) {
            currentSubplots = [...val];
          } else if (val) {
            currentSubplots = [String(val)];
          }
        }
        if (currentSubplots.includes(subplotToDelete)) {
          const newSubplots = currentSubplots.filter((s) => s !== subplotToDelete);
          if (newSubplots.length === 0) {
            newSubplots.push("Main Plot");
          }
          if (newSubplots.length === 1) {
            fm[subplotKey] = newSubplots[0];
          } else {
            fm[subplotKey] = newSubplots;
          }
          processed = true;
        }
      });
      if (processed) modifiedCount++;
    }
    new import_obsidian49.Notice(`Removed "${subplotToDelete}" from ${modifiedCount} scenes.`);
  }
  /**
   * Rename a subplot in all scenes.
   */
  async renameSubplot(oldName, newName) {
    if (oldName === newName) return;
    if (oldName === "Main Plot") {
    }
    const files = await this.getSceneFiles();
    let modifiedCount = 0;
    for (const file of files) {
      let processed = false;
      await this.app.fileManager.processFrontMatter(file, (fm) => {
        let currentSubplots = [];
        let subplotKey = "Subplot";
        const keys = Object.keys(fm);
        const existingKey = keys.find((k) => k.toLowerCase() === "subplot");
        if (existingKey) {
          subplotKey = existingKey;
          const val = fm[existingKey];
          if (Array.isArray(val)) {
            currentSubplots = [...val];
          } else if (val) {
            currentSubplots = [String(val)];
          }
        }
        if (currentSubplots.includes(oldName)) {
          const newSubplotsSet = new Set(currentSubplots.map((s) => s === oldName ? newName : s));
          const newSubplots = Array.from(newSubplotsSet);
          if (newSubplots.length === 1) {
            fm[subplotKey] = newSubplots[0];
          } else {
            fm[subplotKey] = newSubplots;
          }
          processed = true;
        }
      });
      if (processed) modifiedCount++;
    }
    await this.renameSubplotInSettings(oldName, newName);
    new import_obsidian49.Notice(`Renamed "${oldName}" to "${newName}" in ${modifiedCount} scenes.`);
  }
  /**
   * Rename subplot in settings (Dominant Subplots preference)
   */
  async renameSubplotInSettings(oldName, newName) {
    const settings = this.sceneDataService.settings;
    if (settings && settings.dominantSubplots) {
      let settingsChanged = false;
      const dominantSubplots = settings.dominantSubplots;
      for (const [path, subplot] of Object.entries(dominantSubplots)) {
        if (subplot === oldName) {
          dominantSubplots[path] = newName;
          settingsChanged = true;
        }
      }
      if (settingsChanged) {
      }
    }
  }
  /**
   * Helper to get all scene files (raw TFiles)
   */
  async getSceneFiles() {
    const settings = this.sceneDataService.settings;
    const sourcePath = (settings == null ? void 0 : settings.sourcePath) || "";
    const files = this.app.vault.getMarkdownFiles().filter((file) => {
      if (sourcePath && !file.path.startsWith(sourcePath)) return false;
      return true;
    });
    const sceneFiles = [];
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      const fm = cache == null ? void 0 : cache.frontmatter;
      if (fm && normalizeFrontmatterKeys(fm).Class === "Scene") {
        sceneFiles.push(file);
      }
    }
    return sceneFiles;
  }
};

// src/modals/ManageSubplotsModal.ts
var ERASER_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-eraser-icon lucide-eraser"><path d="M21 21H8a2 2 0 0 1-1.42-.587l-3.994-3.999a2 2 0 0 1 0-2.828l10-10a2 2 0 0 1 2.829 0l5.999 6a2 2 0 0 1 0 2.828L12.834 21"/><path d="m5.082 11.09 8.828 8.828"/></svg>`;
var PENCIL_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil-line-icon lucide-pencil-line"><path d="M13 21h8"/><path d="m15 5 4 4"/><path d="M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z"/></svg>`;
var ManageSubplotsModal = class extends import_obsidian50.Modal {
  constructor(app, plugin) {
    super(app);
    this.subplots = [];
    // UI Elements
    this.statsContainer = null;
    this.listContainer = null;
    this.plugin = plugin;
    this.service = new SubplotManagementService(app, plugin.sceneDataService);
  }
  onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.empty();
    modalEl.classList.add("rt-modal-shell");
    contentEl.addClass("rt-modal-container", "rt-manage-subplots-modal");
    const hero = contentEl.createDiv({ cls: "rt-modal-header" });
    hero.createSpan({ text: "Configuration", cls: "rt-modal-badge" });
    hero.createDiv({ text: "Manage Subplots", cls: "rt-modal-title" });
    hero.createDiv({ text: "Rename or remove subplots across the timeline. Orphaned scenes will be moved to Main Plot.", cls: "rt-modal-subtitle" });
    this.statsContainer = hero.createDiv({ cls: "rt-modal-meta" });
    this.statsContainer.createSpan({ text: "Loading stats...", cls: "rt-modal-meta-item" });
    const card = contentEl.createDiv({ cls: "rt-manage-subplots-card rt-glass-card" });
    this.listContainer = card.createDiv({ cls: "rt-manage-subplots-list" });
    this.loadSubplots();
  }
  async loadSubplots() {
    this.subplots = await this.service.getSubplotStats();
    this.renderList();
  }
  renderList() {
    if (!this.listContainer || !this.statsContainer) return;
    const sorted = [...this.subplots].sort((a, b) => {
      if (a.name === "Main Plot") return -1;
      if (b.name === "Main Plot") return 1;
      if (b.count !== a.count) return b.count - a.count;
      return a.name.localeCompare(b.name);
    });
    this.statsContainer.empty();
    this.statsContainer.createSpan({ text: `Total Subplots: ${this.subplots.length}`, cls: "rt-modal-meta-item" });
    this.listContainer.empty();
    const header = this.listContainer.createDiv({ cls: "rt-manage-subplots-header" });
    header.setText("Active Subplots");
    const scrollArea = this.listContainer.createDiv({ cls: "rt-manage-subplots-scroll" });
    sorted.forEach((subplot) => {
      const row = scrollArea.createDiv({ cls: "rt-manage-subplots-row" });
      const info = row.createDiv({ cls: "rt-manage-subplots-info" });
      const nameEl = info.createDiv({ cls: "rt-manage-subplots-name" });
      nameEl.setText(subplot.name);
      const countEl = info.createDiv({ cls: "rt-manage-subplots-count" });
      countEl.setText(`${subplot.count} scenes`);
      const actions = row.createDiv({ cls: "rt-manage-subplots-actions" });
      const renameBtn = new import_obsidian50.ButtonComponent(actions).setTooltip("Rename").setDisabled(subplot.name === "Main Plot").onClick(() => this.handleRename(subplot.name));
      const pencilIcon = document.createElement("span");
      pencilIcon.innerHTML = PENCIL_ICON;
      renameBtn.buttonEl.appendChild(pencilIcon);
      renameBtn.buttonEl.classList.add("rt-pulse-icon-button", "rt-manage-subplots-btn");
      const isMainPlot = subplot.name === "Main Plot";
      const deleteBtn = new import_obsidian50.ButtonComponent(actions).setTooltip(isMainPlot ? "Main Plot cannot be deleted" : "Delete").setDisabled(isMainPlot).onClick(() => this.handleDelete(subplot.name));
      const eraserIcon = document.createElement("span");
      eraserIcon.innerHTML = ERASER_ICON;
      deleteBtn.buttonEl.appendChild(eraserIcon);
      deleteBtn.buttonEl.classList.add("rt-pulse-icon-button", "rt-manage-subplots-btn", "rt-manage-subplots-delete-btn");
      if (isMainPlot) {
        deleteBtn.buttonEl.classList.add("rt-manage-subplots-disabled");
        renameBtn.buttonEl.classList.add("rt-manage-subplots-disabled");
      }
    });
  }
  async handleRename(oldName) {
    new RenameSubplotModal(this.app, oldName, async (newName) => {
      if (newName && newName !== oldName) {
        await this.service.renameSubplot(oldName, newName);
        await this.loadSubplots();
      }
    }).open();
  }
  async handleDelete(subplotName) {
    new SubplotDeletionConfirmModal(this.app, subplotName, async () => {
      await this.service.deleteSubplot(subplotName);
      await this.loadSubplots();
    }).open();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SubplotDeletionConfirmModal = class extends import_obsidian50.Modal {
  constructor(app, subplotName, onConfirm) {
    super(app);
    this.subplotName = subplotName;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl, modalEl, titleEl } = this;
    contentEl.empty();
    titleEl.setText("");
    if (modalEl) {
      modalEl.classList.add("rt-modal-shell");
      modalEl.style.width = "600px";
      modalEl.style.maxWidth = "92vw";
    }
    contentEl.addClass("rt-modal-container");
    const header = contentEl.createDiv({ cls: "rt-modal-header" });
    header.createSpan({ cls: "rt-modal-badge", text: "Warning" });
    header.createDiv({ cls: "rt-modal-title", text: "Remove subplot?" });
    header.createDiv({ cls: "rt-modal-subtitle", text: "This action cannot be undone." });
    const meta = header.createDiv({ cls: "rt-modal-meta" });
    meta.createSpan({ cls: "rt-modal-meta-item", text: "Scenes in only this subplot will be moved to Main Plot" });
    const card = contentEl.createDiv({ cls: "rt-glass-card" });
    const warningEl = card.createDiv({ cls: "rt-pulse-warning" });
    warningEl.setText(`Are you sure you want to remove "${this.subplotName}" from the timeline?`);
    const buttonRow = contentEl.createDiv({ cls: "rt-modal-actions" });
    new import_obsidian50.ButtonComponent(buttonRow).setButtonText("Remove subplot").setWarning().onClick(async () => {
      await this.onConfirm();
      this.close();
    });
    new import_obsidian50.ButtonComponent(buttonRow).setButtonText("Cancel").onClick(() => this.close());
  }
  onClose() {
    this.contentEl.empty();
  }
};
var RenameSubplotModal = class extends import_obsidian50.Modal {
  constructor(app, oldName, onRename) {
    super(app);
    this.oldName = oldName;
    this.onRename = onRename;
  }
  onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.empty();
    modalEl.classList.add("rt-modal-shell", "rt-rename-subplot-modal");
    contentEl.addClass("rt-modal-container");
    const header = contentEl.createDiv({ cls: "rt-modal-header" });
    header.createSpan({ cls: "rt-modal-badge", text: "Edit" });
    header.createDiv({ cls: "rt-modal-title", text: "Rename Subplot" });
    header.createDiv({ cls: "rt-modal-subtitle", text: `Enter a new name for "${this.oldName}"` });
    const inputContainer = contentEl.createDiv({
      cls: "rt-search-input-container"
    });
    const inputEl = inputContainer.createEl("input", {
      type: "text",
      value: this.oldName,
      cls: "rt-input-full"
    });
    window.setTimeout(() => inputEl.focus(), 50);
    const buttonRow = contentEl.createDiv({ cls: "rt-modal-actions" });
    const save = async () => {
      const val = inputEl.value.trim();
      if (val && val !== this.oldName) {
        await this.onRename(val);
        this.close();
      } else if (val === this.oldName) {
        this.close();
      }
    };
    new import_obsidian50.ButtonComponent(buttonRow).setButtonText("Rename").setCta().onClick(save);
    new import_obsidian50.ButtonComponent(buttonRow).setButtonText("Cancel").onClick(() => this.close());
    inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") save();
      if (e.key === "Escape") this.close();
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/modals/ManuscriptOptionsModal.ts
var import_obsidian51 = require("obsidian");
init_manuscript();
var ManuscriptOptionsModal = class extends import_obsidian51.Modal {
  constructor(app, plugin, onSubmit) {
    super(app);
    this.order = "narrative";
    this.tocMode = "markdown";
    this.subplot = "All Subplots";
    this.sceneTitles = [];
    this.sceneWhenDates = [];
    this.sceneNumbers = [];
    this.totalScenes = 0;
    this.rangeStart = 1;
    this.rangeEnd = 1;
    this.orderPills = [];
    this.activeHandle = null;
    this.plugin = plugin;
    this.onSubmit = onSubmit;
  }
  async onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.empty();
    if (modalEl) {
      modalEl.style.width = "760px";
      modalEl.style.maxWidth = "92vw";
      modalEl.style.maxHeight = "92vh";
      modalEl.classList.add("rt-modal-shell");
    }
    contentEl.classList.add("rt-modal-container", "rt-manuscript-modal");
    this.renderSkeleton(contentEl);
    await this.loadSubplots();
    await this.loadScenesForOrder();
  }
  onClose() {
    this.detachPointerEvents();
    this.contentEl.empty();
  }
  // Layout -----------------------------------------------------------------
  renderSkeleton(container) {
    const hero = container.createDiv({ cls: "rt-modal-header" });
    hero.createSpan({ cls: "rt-modal-badge", text: "Manuscript" });
    hero.createDiv({
      cls: "rt-modal-title",
      text: t("manuscriptModal.title")
    });
    hero.createDiv({
      cls: "rt-modal-subtitle",
      text: t("manuscriptModal.description")
    });
    this.heroMetaEl = hero.createDiv({ cls: "rt-modal-meta" });
    this.renderHeroMeta([t("manuscriptModal.heroLoading")]);
    const tocCard = container.createDiv({ cls: "rt-glass-card rt-sub-card" });
    tocCard.createDiv({ cls: "rt-sub-card-head", text: t("manuscriptModal.tocHeading") });
    const tocActions = tocCard.createDiv({ cls: "rt-manuscript-pill-row" });
    this.createPill(tocActions, t("manuscriptModal.tocMarkdown"), this.tocMode === "markdown", () => {
      this.tocMode = "markdown";
      this.updatePills(tocActions, 0);
    });
    this.createPill(tocActions, t("manuscriptModal.tocPlain"), this.tocMode === "plain", () => {
      this.tocMode = "plain";
      this.updatePills(tocActions, 1);
    });
    this.createPill(tocActions, t("manuscriptModal.tocNone"), this.tocMode === "none", () => {
      this.tocMode = "none";
      this.updatePills(tocActions, 2);
    });
    tocCard.createDiv({
      cls: "rt-sub-card-note",
      text: t("manuscriptModal.tocNote")
    });
    const filterCard = container.createDiv({ cls: "rt-glass-card rt-sub-card" });
    filterCard.createDiv({ cls: "rt-sub-card-head", text: "Subplot filter" });
    const filterContainer = filterCard.createDiv({ cls: "rt-manuscript-input-container" });
    this.subplotDropdown = new import_obsidian51.DropdownComponent(filterContainer).addOption("All Subplots", "All Subplots").setValue("All Subplots").onChange(async (value) => {
      this.subplot = value;
      if (value !== "All Subplots") {
        if (this.isReverseOrder()) {
          this.order = "narrative";
        }
      }
      this.updateOrderPillsState();
      await this.loadScenesForOrder();
    });
    const orderCard = container.createDiv({ cls: "rt-glass-card rt-sub-card" });
    orderCard.createDiv({ cls: "rt-sub-card-head", text: t("manuscriptModal.orderHeading") });
    const orderRow = orderCard.createDiv({ cls: "rt-manuscript-pill-row" });
    this.createOrderPill(orderRow, t("manuscriptModal.orderNarrative"), "narrative");
    this.createOrderPill(orderRow, t("manuscriptModal.orderReverseNarrative"), "reverse-narrative");
    this.createOrderPill(orderRow, t("manuscriptModal.orderChronological"), "chronological");
    this.createOrderPill(orderRow, t("manuscriptModal.orderReverseChronological"), "reverse-chronological");
    orderCard.createDiv({
      cls: "rt-sub-card-note",
      text: t("manuscriptModal.orderNote")
    });
    const rangeCard = container.createDiv({ cls: "rt-glass-card rt-sub-card" });
    rangeCard.createDiv({ cls: "rt-sub-card-head", text: t("manuscriptModal.rangeHeading") });
    this.rangeStatusEl = rangeCard.createDiv({ cls: "rt-manuscript-range-status", text: t("manuscriptModal.rangeLoading") });
    const rangeShell = rangeCard.createDiv({ cls: "rt-manuscript-range-shell" });
    this.rangeCardContainer = rangeShell.createDiv({ cls: "rt-manuscript-range-cards" });
    const trackWrap = rangeShell.createDiv({ cls: "rt-manuscript-range-track-wrap" });
    this.trackEl = trackWrap.createDiv({ cls: "rt-manuscript-range-track" });
    this.rangeFillEl = this.trackEl.createDiv({ cls: "rt-manuscript-range-fill" });
    this.startHandleEl = this.trackEl.createDiv({ cls: "rt-manuscript-range-handle", attr: { "data-handle": "start", "aria-label": "Start of range" } });
    this.endHandleEl = this.trackEl.createDiv({ cls: "rt-manuscript-range-handle", attr: { "data-handle": "end", "aria-label": "End of range" } });
    this.registerPointerEvents();
    this.loadingEl = rangeCard.createDiv({ cls: "rt-manuscript-loading", text: t("manuscriptModal.rangeLoading") });
    const actions = container.createDiv({ cls: "rt-modal-actions" });
    this.actionButton = new import_obsidian51.ButtonComponent(actions).setButtonText(t("manuscriptModal.actionCreate")).setCta().onClick(() => this.submit());
    new import_obsidian51.ButtonComponent(actions).setButtonText(t("manuscriptModal.actionCancel")).onClick(() => this.close());
  }
  renderHeroMeta(items) {
    if (!this.heroMetaEl) return;
    this.heroMetaEl.empty();
    items.forEach((item) => {
      var _a;
      return (_a = this.heroMetaEl) == null ? void 0 : _a.createSpan({ cls: "rt-modal-meta-item", text: item });
    });
  }
  // Interaction helpers ----------------------------------------------------
  createPill(parent, label, active, onClick) {
    const pill = parent.createDiv({ cls: "rt-manuscript-pill" });
    pill.createSpan({ text: label });
    if (active) pill.classList.add("rt-is-active");
    pill.onClickEvent(() => {
      parent.querySelectorAll(".rt-manuscript-pill").forEach((el) => el.removeClass("rt-is-active"));
      pill.classList.add("rt-is-active");
      onClick();
    });
  }
  updatePills(parent, activeIndex) {
    const pills = Array.from(parent.querySelectorAll(".rt-manuscript-pill"));
    pills.forEach((el, idx) => {
      if (idx === activeIndex) {
        el.classList.add("rt-is-active");
      } else {
        el.removeClass("rt-is-active");
      }
    });
  }
  createOrderPill(parent, label, order) {
    const pill = parent.createDiv({ cls: "rt-manuscript-pill" });
    pill.createSpan({ text: label });
    this.orderPills.push({ el: pill, order });
    if (this.order === order) pill.classList.add("rt-is-active");
    pill.onClickEvent(async () => {
      if (pill.hasClass("rt-is-disabled")) return;
      this.orderPills.forEach((p) => p.el.removeClass("rt-is-active"));
      pill.classList.add("rt-is-active");
      this.order = order;
      await this.loadScenesForOrder();
    });
  }
  updateOrderPillsState() {
    const isFiltered = this.subplot !== "All Subplots";
    this.orderPills.forEach((p) => {
      const isReverse = p.order === "reverse-narrative" || p.order === "reverse-chronological";
      if (isFiltered && isReverse) {
        p.el.addClass("rt-is-disabled");
        p.el.removeClass("rt-is-active");
      } else {
        p.el.removeClass("rt-is-disabled");
        if (this.order === p.order) {
          p.el.addClass("rt-is-active");
        }
      }
    });
  }
  registerPointerEvents() {
    if (!this.trackEl || !this.startHandleEl || !this.endHandleEl) return;
    const onPointerMove = (evt) => {
      if (!this.trackEl || !this.activeHandle || this.totalScenes === 0) return;
      const rect = this.trackEl.getBoundingClientRect();
      let ratio = (evt.clientX - rect.left) / rect.width;
      ratio = Math.min(Math.max(ratio, 0), 1);
      const position = this.ratioToIndex(ratio);
      this.updateRangeFromDrag(this.activeHandle, position);
    };
    const onPointerUp = () => {
      this.activeHandle = null;
      window.removeEventListener("pointermove", onPointerMove);
      window.removeEventListener("pointerup", onPointerUp);
    };
    const attach = (handle, handleType) => {
      handle.onpointerdown = (evt) => {
        const effectiveHandle = handleType;
        this.activeHandle = effectiveHandle;
        window.addEventListener("pointermove", onPointerMove);
        window.addEventListener("pointerup", onPointerUp, { once: true });
        evt.preventDefault();
        evt.stopPropagation();
      };
    };
    attach(this.startHandleEl, "start");
    attach(this.endHandleEl, "end");
    this.trackEl.onpointerdown = (evt) => {
      const rect = this.trackEl.getBoundingClientRect();
      let ratio = (evt.clientX - rect.left) / rect.width;
      ratio = Math.min(Math.max(ratio, 0), 1);
      const position = this.ratioToIndex(ratio);
      const distStart = Math.abs(position - this.rangeStart);
      const distEnd = Math.abs(position - this.rangeEnd);
      const target = distStart <= distEnd ? "start" : "end";
      this.updateRangeFromDrag(target, position);
    };
    this.detachEvents = () => {
      window.removeEventListener("pointermove", onPointerMove);
      window.removeEventListener("pointerup", onPointerUp);
    };
  }
  detachPointerEvents() {
    if (this.detachEvents) {
      this.detachEvents();
      this.detachEvents = void 0;
    }
  }
  // Data loading -----------------------------------------------------------
  async loadSubplots() {
    if (!this.subplotDropdown) return;
    try {
      const scenes = await this.plugin.getSceneData();
      const subplotCounts = /* @__PURE__ */ new Map();
      scenes.forEach((scene) => {
        if (scene.itemType !== "Scene") return;
        const sub = scene.subplot && scene.subplot.trim() ? scene.subplot : "Main Plot";
        subplotCounts.set(sub, (subplotCounts.get(sub) || 0) + 1);
      });
      const sortedSubplots = Array.from(subplotCounts.keys()).sort((a, b) => {
        if (a === "Main Plot") return -1;
        if (b === "Main Plot") return 1;
        const countA = subplotCounts.get(a) || 0;
        const countB = subplotCounts.get(b) || 0;
        if (countA !== countB) return countB - countA;
        return a.localeCompare(b);
      });
      this.subplotDropdown.selectEl.textContent = "";
      this.subplotDropdown.addOption("All Subplots", "All Subplots");
      sortedSubplots.forEach((sub) => {
        var _a;
        (_a = this.subplotDropdown) == null ? void 0 : _a.addOption(sub, sub);
      });
      this.subplotDropdown.setValue("All Subplots");
    } catch (e) {
      console.error("Failed to load subplots", e);
    }
  }
  async loadScenesForOrder() {
    var _a, _b;
    try {
      const { titles, whenDates, sceneNumbers } = await getSceneFilesByOrder(this.plugin, this.order, this.subplot);
      this.sceneTitles = titles;
      this.sceneWhenDates = whenDates;
      this.sceneNumbers = sceneNumbers;
      this.totalScenes = titles.length;
      this.rangeStart = 1;
      this.rangeEnd = Math.max(1, this.totalScenes);
      const meta = [`${this.totalScenes} scenes available`];
      if (this.subplot !== "All Subplots") {
        meta.push(`Filtered by: ${this.subplot}`);
      } else {
        meta.push(t("manuscriptModal.heroNarrativeMeta"));
      }
      this.renderHeroMeta(meta);
      (_a = this.loadingEl) == null ? void 0 : _a.remove();
      this.updateRangeUI();
      this.syncRangeAvailability();
    } catch (err) {
      console.error(err);
      (_b = this.loadingEl) == null ? void 0 : _b.setText(t("manuscriptModal.loadError"));
      this.renderHeroMeta([t("manuscriptModal.loadError")]);
    }
  }
  // Range rendering -------------------------------------------------------
  ratioToIndex(ratio) {
    if (this.totalScenes <= 1) return 1;
    const raw = Math.round(ratio * (this.totalScenes - 1)) + 1;
    return Math.min(Math.max(raw, 1), this.totalScenes);
  }
  updateRangeFromDrag(handle, position) {
    if (handle === "start") {
      this.rangeStart = Math.min(position, this.rangeEnd);
    } else if (handle === "end") {
      this.rangeEnd = Math.max(position, this.rangeStart);
    }
    this.updateRangeUI();
  }
  isReverseOrder() {
    return this.order === "reverse-narrative" || this.order === "reverse-chronological";
  }
  isChronologicalOrder() {
    return this.order === "chronological" || this.order === "reverse-chronological";
  }
  getSceneNumberAt(position) {
    var _a;
    const index = Math.max(0, Math.min(position - 1, this.sceneNumbers.length - 1));
    return (_a = this.sceneNumbers[index]) != null ? _a : position;
  }
  syncRangeAvailability() {
    var _a;
    const isReverse = this.isReverseOrder();
    const startSceneNum = this.getSceneNumberAt(this.rangeStart);
    const endSceneNum = this.getSceneNumberAt(this.rangeEnd);
    const displayStart = startSceneNum;
    const displayEnd = endSceneNum;
    (_a = this.rangeStatusEl) == null ? void 0 : _a.setText(
      t("manuscriptModal.rangeStatus", {
        start: displayStart,
        end: displayEnd,
        total: this.totalScenes,
        count: this.rangeEnd - this.rangeStart + 1
      })
    );
  }
  updateRangeUI() {
    if (!this.trackEl || !this.startHandleEl || !this.endHandleEl || !this.rangeFillEl) return;
    if (this.totalScenes === 0) return;
    const startPercent = this.totalScenes === 1 ? 0 : (this.rangeStart - 1) / (this.totalScenes - 1) * 100;
    const endPercent = this.totalScenes === 1 ? 100 : (this.rangeEnd - 1) / (this.totalScenes - 1) * 100;
    this.startHandleEl.style.left = `${startPercent}%`;
    this.endHandleEl.style.left = `${endPercent}%`;
    this.rangeFillEl.style.left = `${startPercent}%`;
    this.rangeFillEl.style.width = `${Math.max(endPercent - startPercent, 1)}%`;
    this.renderRangeCards();
    this.syncRangeAvailability();
  }
  formatCardTitle(index) {
    var _a;
    const title = (_a = this.sceneTitles[index]) != null ? _a : "\u2014";
    if (this.isChronologicalOrder()) {
      const whenDate = this.sceneWhenDates[index];
      return whenDate ? `${title} \xB7 ${whenDate}` : title;
    }
    return title;
  }
  renderRangeCards() {
    if (!this.rangeCardContainer) return;
    this.rangeCardContainer.empty();
    if (this.totalScenes === 0) return;
    const isReverse = this.isReverseOrder();
    const startSceneNum = this.getSceneNumberAt(this.rangeStart);
    const endSceneNum = this.getSceneNumberAt(this.rangeEnd);
    const displayStart = startSceneNum;
    const displayEnd = endSceneNum;
    const firstCard = this.rangeCardContainer.createDiv({ cls: "rt-manuscript-range-card" });
    firstCard.toggleClass("rt-is-muted", this.rangeStart > 1);
    firstCard.createDiv({ cls: "rt-manuscript-range-label", text: t("manuscriptModal.rangeFirst") });
    firstCard.createDiv({ cls: "rt-manuscript-range-title", text: this.formatCardTitle(0) });
    const selectedCard = this.rangeCardContainer.createDiv({ cls: "rt-manuscript-range-card rt-manuscript-range-card-active" });
    const isFullRange = this.rangeStart === 1 && this.rangeEnd === this.totalScenes;
    selectedCard.toggleClass("rt-is-muted", isFullRange);
    const rangeLabel = isFullRange ? t("manuscriptModal.rangeAllLabel") : t("manuscriptModal.rangeSelectedLabel", { start: displayStart, end: displayEnd });
    selectedCard.createDiv({ cls: "rt-manuscript-range-label", text: rangeLabel });
    const middleTitle = this.rangeStart === this.rangeEnd ? this.formatCardTitle(this.rangeStart - 1) : t("manuscriptModal.rangeCountLabel", { count: this.rangeEnd - this.rangeStart + 1 });
    selectedCard.createDiv({ cls: "rt-manuscript-range-title", text: middleTitle });
    const lastCard = this.rangeCardContainer.createDiv({ cls: "rt-manuscript-range-card" });
    lastCard.toggleClass("rt-is-muted", this.rangeEnd < this.totalScenes);
    lastCard.createDiv({ cls: "rt-manuscript-range-label", text: t("manuscriptModal.rangeLast") });
    lastCard.createDiv({ cls: "rt-manuscript-range-title", text: this.formatCardTitle(this.totalScenes - 1) });
  }
  // Submission -------------------------------------------------------------
  async submit() {
    var _a, _b, _c, _d;
    if (this.totalScenes === 0) {
      new import_obsidian51.Notice(t("manuscriptModal.emptyNotice"));
      return;
    }
    (_a = this.actionButton) == null ? void 0 : _a.setDisabled(true);
    (_b = this.actionButton) == null ? void 0 : _b.setButtonText(t("manuscriptModal.actionCreate"));
    try {
      await this.onSubmit({
        order: this.order,
        tocMode: this.tocMode,
        rangeStart: this.rangeStart,
        rangeEnd: this.rangeEnd,
        subplot: this.subplot === "All Subplots" ? void 0 : this.subplot
      });
      this.close();
    } catch (err) {
      console.error(err);
      new import_obsidian51.Notice(t("manuscriptModal.loadError"));
      (_c = this.actionButton) == null ? void 0 : _c.setDisabled(false);
      (_d = this.actionButton) == null ? void 0 : _d.setButtonText(t("manuscriptModal.actionCreate"));
    }
  }
};

// src/modals/PlanetaryTimeModal.ts
var import_obsidian52 = require("obsidian");
init_planetaryTime();
var PlanetaryTimeModal = class extends import_obsidian52.Modal {
  constructor(app, plugin) {
    var _a;
    super(app);
    this.resultEl = null;
    this.resultTextEl = null;
    this.profileDropdown = null;
    this.lastProfile = null;
    this.lastFormatted = null;
    this.plugin = plugin;
    this.profiles = plugin.settings.planetaryProfiles || [];
    this.activeId = plugin.settings.activePlanetaryProfileId || ((_a = this.profiles[0]) == null ? void 0 : _a.id);
    const now = /* @__PURE__ */ new Date();
    this.localDateValue = this.formatDateInput(now);
    this.localTimeValue = this.formatTimeInput(now);
  }
  onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.empty();
    if (modalEl) {
      modalEl.classList.add("rt-modal-shell");
      modalEl.style.width = "720px";
      modalEl.style.maxWidth = "92vw";
    }
    contentEl.addClass("rt-modal-container", "rt-planetary-modal");
    const header = contentEl.createDiv({ cls: "rt-modal-header" });
    header.createSpan({ cls: "rt-modal-badge", text: t("planetary.heading") });
    header.createDiv({ cls: "rt-modal-title", text: t("planetary.modal.title") });
    header.createDiv({ cls: "rt-modal-subtitle", text: t("planetary.modal.datetimeDesc") });
    if (!this.plugin.settings.enablePlanetaryTime) {
      contentEl.createDiv({ text: t("planetary.modal.disabled") });
      return;
    }
    if (!this.profiles.length) {
      contentEl.createDiv({ text: t("planetary.modal.noProfile") });
      return;
    }
    const profileSetting = new import_obsidian52.Setting(contentEl).setName(t("planetary.modal.activeProfile")).setDesc(t("planetary.active.desc"));
    profileSetting.addDropdown((drop) => {
      this.profileDropdown = drop;
      this.profiles.forEach((p) => drop.addOption(p.id, p.label || "Unnamed"));
      drop.setValue(this.activeId || this.profiles[0].id);
      drop.onChange(async (value) => {
        this.activeId = value;
        this.plugin.settings.activePlanetaryProfileId = value;
        await this.plugin.saveSettings();
        this.renderResult();
      });
    });
    const inputSetting = new import_obsidian52.Setting(contentEl).setName(t("planetary.modal.datetimeLabel")).setDesc(t("planetary.modal.datetimeDesc"));
    inputSetting.settingEl.addClass("rt-planetary-datetime-setting");
    inputSetting.addText((text) => {
      text.inputEl.type = "date";
      text.setValue(this.localDateValue);
      text.onChange((value) => {
        this.localDateValue = value;
      });
    });
    inputSetting.addText((text) => {
      text.inputEl.type = "time";
      text.inputEl.step = "60";
      text.setValue(this.localTimeValue);
      text.onChange((value) => {
        this.localTimeValue = value;
      });
    });
    inputSetting.addExtraButton((button) => {
      button.setIcon("clock");
      button.setTooltip(t("planetary.modal.now"));
      button.onClick(() => {
        const now = /* @__PURE__ */ new Date();
        this.localDateValue = this.formatDateInput(now);
        this.localTimeValue = this.formatTimeInput(now);
        const inputs = inputSetting.controlEl.querySelectorAll("input");
        inputs.forEach((input, idx) => {
          input.classList.remove("rt-setting-input-error", "rt-setting-input-success");
          input.value = idx === 0 ? this.localDateValue : this.localTimeValue;
        });
        this.renderResult();
      });
    });
    const actions = contentEl.createDiv({ cls: "rt-modal-actions" });
    const convertBtn = new import_obsidian52.ButtonComponent(actions).setButtonText(t("planetary.modal.convert")).setCta().onClick(() => this.renderResult());
    convertBtn.buttonEl.classList.add("rt-planetary-convert-btn");
    const resultRow = contentEl.createDiv({ cls: "rt-planetary-modal-result-row" });
    this.resultEl = resultRow.createDiv({ cls: "rt-planetary-modal-result" });
    const iconEl = this.resultEl.createDiv({ cls: "rt-planetary-result-icon" });
    (0, import_obsidian52.setIcon)(iconEl, "orbit");
    this.resultTextEl = this.resultEl.createDiv({ cls: "rt-planetary-result-text" });
    new import_obsidian52.ExtraButtonComponent(resultRow).setIcon("copy").setTooltip("Copy YAML").onClick(() => this.copyYaml());
    this.renderResult();
  }
  renderResult() {
    if (!this.resultEl || !this.resultTextEl) return;
    this.lastProfile = null;
    this.lastFormatted = null;
    const profile = this.getActiveProfile();
    if (!profile) {
      this.resultTextEl.setText(t("planetary.modal.noProfile"));
      return;
    }
    let parsed = null;
    try {
      if (!this.localDateValue) {
        parsed = null;
      } else {
        const time = this.localTimeValue || "00:00";
        const maybe = /* @__PURE__ */ new Date(`${this.localDateValue}T${time}`);
        parsed = Number.isNaN(maybe.getTime()) ? null : maybe;
      }
    } catch (e) {
      parsed = null;
    }
    if (!parsed) {
      this.resultTextEl.setText(t("planetary.modal.invalid"));
      return;
    }
    const conversion = convertFromEarth(parsed, profile);
    if (!conversion) {
      this.resultTextEl.setText(t("planetary.preview.invalid"));
      return;
    }
    this.lastProfile = profile;
    this.lastFormatted = conversion.formatted;
    this.resultTextEl.setText(conversion.formatted);
  }
  getActiveProfile() {
    if (!this.profiles.length) return null;
    const match = this.profiles.find((p) => p.id === this.activeId);
    return match || this.profiles[0];
  }
  formatDateInput(d) {
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  }
  formatTimeInput(d) {
    const hours = String(d.getHours()).padStart(2, "0");
    const minutes = String(d.getMinutes()).padStart(2, "0");
    return `${hours}:${minutes}`;
  }
  copyYaml() {
    var _a;
    if (!this.lastProfile || !this.lastFormatted) return;
    const yaml = [
      "Planetary:",
      `  profile: ${this.lastProfile.label || "Unknown"}`,
      `  local: "${this.lastFormatted}"`
    ].join("\n");
    (_a = navigator.clipboard) == null ? void 0 : _a.writeText(yaml).catch(() => {
    });
  }
};

// src/utils/sceneCreation.ts
var import_obsidian53 = require("obsidian");
function sanitizeSourcePath(sourcePath) {
  const p = (sourcePath || "").trim();
  return p ? (0, import_obsidian53.normalizePath)(p) : "";
}
function buildInitialSceneFilename(sanitizedSourcePath, baseName = "1 Test Scene.md") {
  return `${sanitizedSourcePath ? sanitizedSourcePath + "/" : ""}${baseName}`;
}

// src/services/CommandRegistrar.ts
init_defaults();
init_aiOutput();
var CommandRegistrar = class {
  constructor(plugin, app) {
    this.plugin = plugin;
    this.app = app;
  }
  registerAll() {
    this.registerRibbon();
    this.registerCommands();
  }
  registerRibbon() {
    this.plugin.addRibbonIcon("shell", "Radial timeline", () => {
      this.plugin.getTimelineService().activateView();
    });
  }
  registerCommands() {
    this.plugin.addCommand({
      id: "search-timeline",
      name: "Search timeline",
      callback: () => this.plugin.openSearchPrompt()
    });
    this.plugin.addCommand({
      id: "clear-timeline-search",
      name: "Clear search",
      callback: () => this.plugin.clearSearch()
    });
    this.plugin.addCommand({
      id: "manage-subplots",
      name: "Manage subplots",
      callback: () => {
        new ManageSubplotsModal(this.app, this.plugin).open();
      }
    });
    this.plugin.addCommand({
      id: "create-scene-note",
      name: "Create basic scene note",
      callback: () => {
        void this.createSceneTemplateNote();
      }
    });
    this.plugin.addCommand({
      id: "create-advanced-scene-note",
      name: "Create advanced scene note",
      callback: () => {
        void this.createAdvancedSceneTemplateNote();
      }
    });
    this.plugin.addCommand({
      id: "create-backdrop-note",
      name: "Create backdrop note",
      callback: () => {
        void this.createBackdropTemplateNote();
      }
    });
    this.plugin.addCommand({
      id: "book-designer",
      name: "Book designer",
      callback: () => {
        new BookDesignerModal(this.app, this.plugin).open();
      }
    });
    this.plugin.addCommand({
      id: "gossamer-enter-scores",
      name: "Gossamer enter momentum scores",
      callback: async () => {
        try {
          await openGossamerScoreEntry(this.plugin);
        } catch (e) {
          new import_obsidian54.Notice("Failed to open Gossamer score entry.");
          console.error(e);
        }
      }
    });
    const beatSystemLabel = this.getBeatSystemDisplayName();
    this.plugin.addCommand({
      id: "gossamer-run-save-the-cat-analysis",
      name: `Gossamer AI evaluation using ${beatSystemLabel} story beats`,
      checkCallback: (checking) => {
        if (!this.plugin.settings.enableAiSceneAnalysis) return false;
        if (checking) return true;
        (async () => {
          const currentLabel = this.getBeatSystemDisplayName();
          try {
            new import_obsidian54.Notice(`Gossamer AI evaluation using ${currentLabel} story beats...`);
            await runGossamerAiAnalysis(this.plugin);
          } catch (e) {
            new import_obsidian54.Notice(`Failed to run ${currentLabel} beat analysis.`);
            console.error(e);
          }
        })();
        return true;
      }
    });
    this.plugin.addCommand({
      id: "gossamer-generate-manuscript",
      name: "Generate manuscript",
      callback: async () => this.generateManuscript()
    });
    this.plugin.addCommand({
      id: "open-timeline-view",
      name: "Open",
      callback: () => this.plugin.getTimelineService().activateView()
    });
    this.plugin.addCommand({
      id: "open-planetary-time-converter",
      name: "Planetary time converter",
      checkCallback: (checking) => {
        if (!this.plugin.settings.enablePlanetaryTime) return false;
        if (!this.plugin.settings.planetaryProfiles || this.plugin.settings.planetaryProfiles.length === 0) {
          if (!checking) {
            new import_obsidian54.Notice("Add a planetary profile in Settings first.");
          }
          return false;
        }
        if (checking) return true;
        new PlanetaryTimeModal(this.app, this.plugin).open();
        return true;
      }
    });
  }
  async createSceneTemplateNote() {
    var _a, _b, _c, _d;
    try {
      const vault = this.app.vault;
      const sourcePath = sanitizeSourcePath(this.plugin.settings.sourcePath);
      if (sourcePath && !vault.getAbstractFileByPath(sourcePath)) {
        await vault.createFolder(sourcePath);
      }
      const template = ensureClassScene(
        ((_d = (_c = (_a = this.plugin.settings.sceneYamlTemplates) == null ? void 0 : _a.base) != null ? _c : (_b = DEFAULT_SETTINGS.sceneYamlTemplates) == null ? void 0 : _b.base) != null ? _d : "").trim()
      );
      if (!template) {
        new import_obsidian54.Notice("Basic scene template not found. Set a scene template in Settings.");
        return;
      }
      const today = (/* @__PURE__ */ new Date()).toISOString().slice(0, 10);
      const content = generateSceneContent(template, {
        act: 1,
        when: today,
        sceneNumber: 1,
        subplots: ["Main Plot"],
        character: "Hero",
        place: "Unknown",
        characterList: ["Hero"],
        placeList: ["Unknown"]
      });
      const fileBody = `---
${content}
---

Write your scene here...`;
      const initialPath = buildInitialSceneFilename(sourcePath, "1 Template Scene.md");
      const filePath = this.getAvailableFilePath(initialPath);
      const createdFile = await vault.create(filePath, fileBody);
      const leaf = this.app.workspace.getLeaf("tab");
      await leaf.openFile(createdFile);
      new import_obsidian54.Notice(`Template scene created at ${filePath}`);
    } catch (error) {
      console.error("[CreateSceneTemplateNote] Failed to create template scene note:", error);
      new import_obsidian54.Notice("Failed to create template scene note.");
    }
  }
  async createAdvancedSceneTemplateNote() {
    var _a, _b, _c, _d;
    try {
      const vault = this.app.vault;
      const sourcePath = sanitizeSourcePath(this.plugin.settings.sourcePath);
      if (sourcePath && !vault.getAbstractFileByPath(sourcePath)) {
        await vault.createFolder(sourcePath);
      }
      const template = ensureClassScene(
        ((_d = (_c = (_a = this.plugin.settings.sceneYamlTemplates) == null ? void 0 : _a.advanced) != null ? _c : (_b = DEFAULT_SETTINGS.sceneYamlTemplates) == null ? void 0 : _b.advanced) != null ? _d : "").trim()
      );
      if (!template) {
        new import_obsidian54.Notice("Advanced scene template not found. Enable or configure it in Settings.");
        return;
      }
      const today = (/* @__PURE__ */ new Date()).toISOString().slice(0, 10);
      const content = generateSceneContent(template, {
        act: 1,
        when: today,
        sceneNumber: 1,
        subplots: ["Main Plot"],
        character: "Hero",
        place: "Unknown",
        characterList: ["Hero"],
        placeList: ["Unknown"]
      });
      const fileBody = `---
${content}
---

Write your scene here...`;
      const initialPath = buildInitialSceneFilename(sourcePath, "1 Template Scene (Advanced).md");
      const filePath = this.getAvailableFilePath(initialPath);
      const createdFile = await vault.create(filePath, fileBody);
      const leaf = this.app.workspace.getLeaf("tab");
      await leaf.openFile(createdFile);
      new import_obsidian54.Notice(`Advanced template scene created at ${filePath}`);
    } catch (error) {
      console.error("[CreateAdvancedSceneTemplateNote] Failed to create advanced template scene note:", error);
      new import_obsidian54.Notice("Failed to create advanced template scene note.");
    }
  }
  async createBackdropTemplateNote() {
    var _a, _b;
    try {
      const vault = this.app.vault;
      const sourcePath = sanitizeSourcePath(this.plugin.settings.sourcePath);
      if (sourcePath && !vault.getAbstractFileByPath(sourcePath)) {
        await vault.createFolder(sourcePath);
      }
      const template = ((_b = (_a = this.plugin.settings.backdropYamlTemplate) != null ? _a : DEFAULT_SETTINGS.backdropYamlTemplate) != null ? _b : "").trim();
      if (!template) {
        new import_obsidian54.Notice("Backdrop template not found. Add one in Settings.");
        return;
      }
      const start = /* @__PURE__ */ new Date();
      start.setHours(0, 0, 0, 0);
      const end = new Date(start.getTime() + 7 * 24 * 60 * 60 * 1e3);
      const filledTemplate = template.replace(/{{When}}/g, this.formatDateTime(start)).replace(/{{End}}/g, this.formatDateTime(end));
      const fileBody = `---
${filledTemplate}
---

Describe how this backdrop shapes your scenes.`;
      const filePath = this.getAvailableFilePath(`${sourcePath ? `${sourcePath}/` : ""}Backdrop Template.md`);
      const createdFile = await vault.create(filePath, fileBody);
      const leaf = this.app.workspace.getLeaf("tab");
      await leaf.openFile(createdFile);
      new import_obsidian54.Notice(`Backdrop template created at ${filePath}`);
    } catch (error) {
      console.error("[CreateBackdropTemplateNote] Failed to create backdrop template note:", error);
      new import_obsidian54.Notice("Failed to create backdrop template note.");
    }
  }
  getAvailableFilePath(initialPath) {
    const vault = this.app.vault;
    if (!vault.getAbstractFileByPath(initialPath)) return initialPath;
    const dotIndex = initialPath.lastIndexOf(".");
    const base = dotIndex >= 0 ? initialPath.slice(0, dotIndex) : initialPath;
    const ext = dotIndex >= 0 ? initialPath.slice(dotIndex) : "";
    let counter = 2;
    let candidate = `${base} (${counter})${ext}`;
    while (vault.getAbstractFileByPath(candidate)) {
      counter += 1;
      candidate = `${base} (${counter})${ext}`;
    }
    return candidate;
  }
  formatDateTime(date) {
    const pad2 = (n) => n.toString().padStart(2, "0");
    const year = date.getFullYear();
    const month = pad2(date.getMonth() + 1);
    const day = pad2(date.getDate());
    const hours = pad2(date.getHours());
    const minutes = pad2(date.getMinutes());
    return `${year}-${month}-${day}T${hours}:${minutes}:00`;
  }
  getBeatSystemDisplayName() {
    const configured = (this.plugin.settings.beatSystem || "").trim();
    if (!configured) return "Save The Cat";
    return configured;
  }
  async generateManuscript() {
    const modal = new ManuscriptOptionsModal(this.app, this.plugin, async (result) => {
      await this.handleManuscriptSubmission(result);
    });
    modal.open();
  }
  async handleManuscriptSubmission(options) {
    try {
      new import_obsidian54.Notice("Assembling manuscript...");
      const { files, sortOrder } = await getSceneFilesByOrder(this.plugin, options.order, options.subplot);
      if (files.length === 0) {
        new import_obsidian54.Notice("No scenes found in source path.");
        return;
      }
      const orderedFiles = sliceScenesByRange(files, options.rangeStart, options.rangeEnd);
      if (orderedFiles.length === 0) {
        new import_obsidian54.Notice("Selected range is empty.");
        return;
      }
      const hasCustomRange = options.rangeStart && options.rangeEnd && !(options.rangeStart === 1 && options.rangeEnd === files.length);
      const rangeSuffix = hasCustomRange ? ` \xB7 Scenes ${options.rangeStart}-${options.rangeEnd}` : "";
      const subplotSuffix = options.subplot ? ` \xB7 ${options.subplot}` : "";
      const sortLabelWithRange = `${sortOrder}${subplotSuffix}${rangeSuffix}`;
      const includeToc = options.tocMode !== "none";
      const useMarkdownToc = options.tocMode === "markdown";
      const manuscript = await assembleManuscript(
        orderedFiles,
        this.app.vault,
        void 0,
        useMarkdownToc,
        sortLabelWithRange,
        includeToc
      );
      if (!manuscript.text || manuscript.text.trim().length === 0) {
        new import_obsidian54.Notice("Manuscript is empty. Check that your scene files have content.");
        return;
      }
      let orderLabel;
      switch (options.order) {
        case "chronological":
          orderLabel = "Chronological";
          break;
        case "reverse-chronological":
          orderLabel = "Reverse Chronological";
          break;
        case "reverse-narrative":
          orderLabel = "Reverse Narrative";
          break;
        default:
          orderLabel = "Narrative";
      }
      const now = /* @__PURE__ */ new Date();
      const dateStr = now.toLocaleDateString(void 0, { year: "numeric", month: "short", day: "numeric" });
      const timeDisplayStr = now.toLocaleTimeString(void 0, { hour: "numeric", minute: "2-digit", hour12: true });
      const timeFileStr = timeDisplayStr.replace(/:/g, ".");
      const fileSubplotLabel = options.subplot ? ` (${options.subplot})` : "";
      const aiFolderPath = await ensureAiOutputFolder(this.plugin);
      const manuscriptPath = `${aiFolderPath}/Manuscript ${orderLabel}${fileSubplotLabel} ${dateStr} ${timeFileStr}.md`;
      const existing = this.app.vault.getAbstractFileByPath(manuscriptPath);
      if (existing) {
        new import_obsidian54.Notice("Warning: Duplicate title. Please wait 1 minute then try again.");
        return;
      }
      const createdFile = await this.app.vault.create(manuscriptPath, manuscript.text);
      const leaf = this.app.workspace.getLeaf("tab");
      await leaf.openFile(createdFile);
      new import_obsidian54.Notice(`Manuscript generated: ${manuscript.totalScenes} scenes, ${manuscript.totalWords.toLocaleString()} words. Saved to ${manuscriptPath}`);
    } catch (e) {
      const errorMsg = (e == null ? void 0 : e.message) || "Unknown error";
      new import_obsidian54.Notice(`Failed to generate manuscript: ${errorMsg}`);
      console.error(e);
    }
  }
};
function ensureClassScene(template) {
  const lines = template.split("\n");
  const classIdx = lines.findIndex((l) => /^\s*Class\s*:/i.test(l));
  if (classIdx >= 0) {
    if (!/^\s*Class\s*:\s*Scene\b/i.test(lines[classIdx])) {
      lines[classIdx] = "Class: Scene";
    }
    return lines.join("\n");
  }
  return ["Class: Scene", ...lines].join("\n");
}

// src/services/HoverHighlighter.ts
var HoverHighlighter = class {
  constructor(app, plugin, highlighter) {
    this.app = app;
    this.plugin = plugin;
    this.highlighter = highlighter;
    this.currentHoverPath = null;
    this.currentTabHoverPath = null;
    this.lastHighlightedFile = null;
  }
  register() {
    this.plugin.registerDomEvent(document, "mouseover", (evt) => {
      const target = evt.target;
      const fileItem = target.closest(".nav-file-title");
      if (!fileItem) return;
      const navFile = fileItem.closest(".nav-file");
      if (!navFile) return;
      const filePath = navFile.getAttribute("data-path");
      if (!filePath) return;
      if (this.currentHoverPath === filePath) return;
      this.currentHoverPath = filePath;
      if (this.highlighter.isSceneFile(filePath)) {
        this.highlighter.highlight(filePath, true);
      }
    });
    this.plugin.registerDomEvent(document, "mouseout", (evt) => {
      const target = evt.target;
      const fileItem = target.closest(".nav-file-title");
      if (!fileItem) return;
      const navFile = fileItem.closest(".nav-file");
      if (!navFile) return;
      const filePath = navFile.getAttribute("data-path");
      if (!filePath || this.currentHoverPath !== filePath) return;
      this.currentHoverPath = null;
      if (this.highlighter.isSceneFile(filePath)) {
        this.highlighter.highlight(filePath, false);
      }
    });
    this.plugin.registerDomEvent(document, "mouseover", (evt) => {
      var _a;
      const tabHeader = evt.target.closest(".workspace-tab-header");
      if (!tabHeader) return;
      const tabId = tabHeader.getAttribute("data-tab-id");
      if (!tabId) return;
      const leaf = this.app.workspace.getLeafById(tabId);
      if (!leaf) return;
      const state = leaf.getViewState();
      const filePath = (_a = state == null ? void 0 : state.state) == null ? void 0 : _a.file;
      if (!filePath || (state == null ? void 0 : state.type) !== "markdown") return;
      if (this.currentTabHoverPath === filePath) return;
      this.currentTabHoverPath = filePath;
      if (this.highlighter.isSceneFile(filePath)) {
        this.highlighter.highlight(filePath, true);
      }
    });
    this.plugin.registerDomEvent(document, "mouseout", (evt) => {
      var _a;
      const tabHeader = evt.target.closest(".workspace-tab-header");
      if (!tabHeader) return;
      const tabId = tabHeader.getAttribute("data-tab-id");
      if (!tabId) return;
      const leaf = this.app.workspace.getLeafById(tabId);
      if (!leaf) return;
      const state = leaf.getViewState();
      const filePath = (_a = state == null ? void 0 : state.state) == null ? void 0 : _a.file;
      if (!filePath || (state == null ? void 0 : state.type) !== "markdown" || this.currentTabHoverPath !== filePath) return;
      this.currentTabHoverPath = null;
      if (this.highlighter.isSceneFile(filePath)) {
        this.highlighter.highlight(filePath, false);
      }
    });
    this.plugin.registerEvent(this.app.workspace.on("file-open", (file) => {
      if (file) {
        if (this.lastHighlightedFile && this.lastHighlightedFile !== file.path) {
          this.highlighter.highlight(this.lastHighlightedFile, false);
        }
        this.highlighter.highlight(file.path, true);
        this.lastHighlightedFile = file.path;
        if (this.highlighter.isSceneFile(file.path)) {
          this.plugin.openScenePaths.add(file.path);
          this.plugin.refreshTimelineIfNeeded(null);
        }
      } else {
        if (this.lastHighlightedFile) {
          this.highlighter.highlight(this.lastHighlightedFile, false);
          this.lastHighlightedFile = null;
        }
      }
    }));
  }
};

// src/services/SceneHighlighter.ts
var SceneHighlighter = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  highlight(filePath, isHighlighting) {
    if (!filePath) return;
    const views = this.plugin.getTimelineViews();
    if (views.length === 0) return;
    for (const view of views) {
      try {
        const container = view.contentEl.querySelector(".radial-timeline-container");
        if (!container) continue;
        const svgElement = container.querySelector("svg");
        if (!svgElement) continue;
        if (isHighlighting) {
          const allElements = svgElement.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title");
          allElements.forEach((element) => {
            element.classList.remove("rt-selected");
            const currentMode = svgElement.getAttribute("data-mode");
            if (currentMode !== "gossamer") {
              element.classList.remove("rt-non-selected");
            }
          });
        }
        let foundScene = false;
        let encodedPath = encodeURIComponent(filePath);
        let sceneGroup = svgElement.querySelector(`.scene-group[data-path="${encodedPath}"]`);
        if (!sceneGroup && filePath.startsWith("/")) {
          encodedPath = encodeURIComponent(filePath.substring(1));
          sceneGroup = svgElement.querySelector(`.scene-group[data-path="${encodedPath}"]`);
        } else if (!sceneGroup && !filePath.startsWith("/")) {
          encodedPath = encodeURIComponent(`/${filePath}`);
          sceneGroup = svgElement.querySelector(`.scene-group[data-path="${encodedPath}"]`);
        }
        if (sceneGroup) {
          foundScene = true;
          if (isHighlighting) {
            const currentPath = sceneGroup.querySelector(".rt-scene-path");
            if (currentPath) {
              currentPath.classList.add("rt-selected");
              const sceneId = currentPath.id;
              const numberSquare = svgElement.querySelector(`.rt-number-square[data-scene-id="${sceneId}"]`);
              const numberText = svgElement.querySelector(`.rt-number-text[data-scene-id="${sceneId}"]`);
              if (numberSquare) numberSquare.classList.add("rt-selected");
              if (numberText) numberText.classList.add("rt-selected");
              const sceneTitle = sceneGroup.querySelector(".rt-scene-title");
              if (sceneTitle) sceneTitle.classList.add("rt-selected");
              const allScenePaths = svgElement.querySelectorAll(".rt-scene-path:not(.rt-selected)");
              allScenePaths.forEach((element) => element.classList.add("rt-non-selected"));
              const synopsis = svgElement.querySelector(`.rt-scene-info[data-for-scene="${sceneId}"]`);
              if (synopsis) synopsis.classList.add("rt-visible");
            }
          } else {
            const allElements = svgElement.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title");
            allElements.forEach((element) => element.classList.remove("selected", "non-selected"));
            const currentPath = sceneGroup.querySelector(".rt-scene-path");
            if (currentPath) {
              const sceneId = currentPath.id;
              const synopsis = svgElement.querySelector(`.rt-scene-info[data-for-scene="${sceneId}"]`);
              if (synopsis) synopsis.classList.remove("rt-visible");
            }
          }
        }
        if (!foundScene) {
        }
      } catch (e) {
      }
    }
  }
  isSceneFile(filePath) {
    const views = this.plugin.getTimelineViews();
    if (views.length === 0) return false;
    for (const view of views) {
      const scenes = view["sceneData"] || [];
      if (scenes.length > 0) {
        const match = scenes.find((scene) => {
          if (!scene.path) return false;
          if (scene.path === filePath) return true;
          if (scene.path === `/${filePath}`) return true;
          if (`/${scene.path}` === filePath) return true;
          return false;
        });
        if (match) return true;
      } else {
        const container = view.contentEl.querySelector(".radial-timeline-container");
        if (!container) continue;
        const svgElement = container.querySelector("svg");
        if (!svgElement) continue;
        let encodedPath = encodeURIComponent(filePath);
        let sceneGroup = svgElement.querySelector(`.scene-group[data-path="${encodedPath}"]`);
        if (!sceneGroup && filePath.startsWith("/")) {
          encodedPath = encodeURIComponent(filePath.substring(1));
          sceneGroup = svgElement.querySelector(`.scene-group[data-path="${encodedPath}"]`);
        } else if (!sceneGroup && !filePath.startsWith("/")) {
          encodedPath = encodeURIComponent(`/${filePath}`);
          sceneGroup = svgElement.querySelector(`.scene-group[data-path="${encodedPath}"]`);
        }
        if (sceneGroup) return true;
      }
    }
    return false;
  }
};

// src/services/GossamerScoreService.ts
var import_obsidian55 = require("obsidian");
init_frontmatter();
init_sceneHelpers();
init_gossamer();
var GossamerScoreService = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  async saveScores(scores) {
    const sourcePath = this.plugin.settings.sourcePath || "";
    const allFiles = this.app.vault.getMarkdownFiles();
    const files = sourcePath ? allFiles.filter((f) => f.path.startsWith(sourcePath)) : allFiles;
    let updateCount = 0;
    for (const [beatTitle, newScore] of scores) {
      let file = null;
      for (const f of files) {
        const cache = this.app.metadataCache.getFileCache(f);
        const rawFm = cache == null ? void 0 : cache.frontmatter;
        const fm = rawFm ? normalizeFrontmatterKeys(rawFm) : void 0;
        if (fm && isStoryBeat(fm.Class)) {
          const filename = f.basename;
          const titleMatch = filename === beatTitle || filename === beatTitle.replace(/^\d+\s+/, "") || filename.toLowerCase() === beatTitle.toLowerCase() || filename.toLowerCase().replace(/[-\s]/g, "") === beatTitle.toLowerCase().replace(/[-\s]/g, "");
          if (titleMatch) {
            file = f;
            break;
          }
        }
      }
      if (!file) continue;
      try {
        await this.app.fileManager.processFrontMatter(file, (yaml) => {
          const fm = yaml;
          const { nextIndex, updated } = appendGossamerScore(fm);
          Object.assign(fm, updated);
          fm[`Gossamer${nextIndex}`] = newScore;
          delete fm.GossamerLocation;
          delete fm.GossamerNote;
          delete fm.GossamerRuns;
          delete fm.GossamerLatestRun;
        });
        updateCount++;
      } catch (e) {
        console.error(`[Gossamer] Failed to update beat ${beatTitle}:`, e);
      }
    }
    if (updateCount > 0) {
      new import_obsidian55.Notice(`Updated ${updateCount} beat score${updateCount > 1 ? "s" : ""}.`);
    } else {
      new import_obsidian55.Notice("No beats were updated.");
    }
  }
};

// src/services/SceneAnalysisService.ts
var import_obsidian62 = require("obsidian");
init_sceneHelpers();
init_aiDefaults();
var SceneAnalysisService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  registerCommands() {
    this.registerManuscriptCommand();
    this.registerSubplotCommand();
  }
  registerManuscriptCommand() {
    this.plugin.addCommand({
      id: "update-beats-manuscript-order",
      name: "Scene pulse analysis (manuscript order)",
      checkCallback: (checking) => {
        if (!this.plugin.settings.enableAiSceneAnalysis) return false;
        if (checking) return true;
        (async () => {
          if (!this.ensureApiKey()) return;
          try {
            await this.processByManuscriptOrder();
          } catch (error) {
            console.error("Error running manuscript order beat update:", error);
            new import_obsidian62.Notice("Error during manuscript order update.");
          }
        })();
        return true;
      }
    });
  }
  registerSubplotCommand() {
    this.plugin.addCommand({
      id: "update-beats-choose-subplot",
      name: "Scene pulse analysis (subplot order)",
      checkCallback: (checking) => {
        if (!this.plugin.settings.enableAiSceneAnalysis) return false;
        if (checking) return true;
        (async () => {
          if (!this.ensureApiKey()) return;
          const options = await this.getSubplotOptions();
          new SubplotPickerModal(this.plugin.app, this, options).open();
        })();
        return true;
      }
    });
  }
  async getSubplotOptions() {
    const { getDistinctSubplotNames: getDistinctSubplotNames2 } = await Promise.resolve().then(() => (init_SceneAnalysisCommands(), SceneAnalysisCommands_exports));
    const names = await getDistinctSubplotNames2(this.plugin, this.plugin.app.vault);
    if (!Array.isArray(names) || names.length === 0) {
      throw new Error("No subplots found.");
    }
    const stats = await Promise.all(names.map((name) => this.countProcessableScenes(name)));
    return names.map((name, index) => ({ name, stats: stats[index] }));
  }
  ensureApiKey() {
    var _a, _b, _c, _d, _e;
    const provider = this.plugin.settings.defaultAiProvider || "openai";
    let hasKey2 = true;
    if (provider === "anthropic") hasKey2 = !!((_a = this.plugin.settings.anthropicApiKey) == null ? void 0 : _a.trim());
    else if (provider === "gemini") hasKey2 = !!((_b = this.plugin.settings.geminiApiKey) == null ? void 0 : _b.trim());
    else if (provider === "local") {
      const hasUrl = !!((_c = this.plugin.settings.localBaseUrl) == null ? void 0 : _c.trim());
      const hasModel = !!((_d = this.plugin.settings.localModelId) == null ? void 0 : _d.trim());
      if (!hasUrl || !hasModel) {
        new import_obsidian62.Notice("Local AI provider requires Base URL and Model ID.");
        return false;
      }
      return true;
    } else hasKey2 = !!((_e = this.plugin.settings.openaiApiKey) == null ? void 0 : _e.trim());
    if (!hasKey2) {
      const name = provider[0].toUpperCase() + provider.slice(1);
      new import_obsidian62.Notice(`${name} API key is not set in settings.`);
      return false;
    }
    return true;
  }
  async countProcessableScenes(subplotName) {
    const allScenes = await this.plugin.getSceneData();
    if (subplotName) {
      const filtered = allScenes.filter((scene) => {
        const subplots = scene.subplot ? Array.isArray(scene.subplot) ? scene.subplot : [scene.subplot] : [];
        return subplots.includes(subplotName);
      });
      const validScenes = filtered.filter((scene) => {
        var _a;
        const statusValue = Array.isArray(scene.status) ? scene.status[0] : scene.status;
        const pulseFlag = (_a = scene["Pulse Update"]) != null ? _a : scene["Beats Update"];
        return (statusValue === "Working" || statusValue === "Complete") && normalizeBooleanValue(pulseFlag);
      });
      const processableScenes2 = filtered.filter((scene) => {
        const statusValue = Array.isArray(scene.status) ? scene.status[0] : scene.status;
        return statusValue === "Working" || statusValue === "Complete";
      });
      return {
        flagged: validScenes.length,
        processable: processableScenes2.length,
        total: filtered.length
      };
    }
    const processableScenes = allScenes.filter((scene) => {
      const statusValue = Array.isArray(scene.status) ? scene.status[0] : scene.status;
      return statusValue === "Working" || statusValue === "Complete";
    });
    const flaggedCount = processableScenes.filter((scene) => {
      var _a;
      const pulseFlag = (_a = scene["Pulse Update"]) != null ? _a : scene["Beats Update"];
      return normalizeBooleanValue(pulseFlag);
    }).length;
    return {
      flagged: flaggedCount,
      processable: processableScenes.length,
      total: allScenes.length
    };
  }
  getActiveModelName() {
    const provider = this.plugin.settings.defaultAiProvider || "openai";
    if (provider === "anthropic") {
      const modelId2 = this.plugin.settings.anthropicModelId || "claude-sonnet-4-5-20250929";
      return modelId2;
    }
    if (provider === "gemini") {
      const modelId2 = this.plugin.settings.geminiModelId || DEFAULT_GEMINI_MODEL_ID;
      return modelId2;
    }
    if (provider === "local") {
      return this.plugin.settings.localModelId || "local-model";
    }
    const modelId = this.plugin.settings.openaiModelId || "gpt-4o";
    return modelId;
  }
  isLocalReportOnlyMode() {
    var _a;
    const provider = this.plugin.settings.defaultAiProvider || "openai";
    return provider === "local" && ((_a = this.plugin.settings.localSendPulseToAiReport) != null ? _a : true);
  }
  async processByManuscriptOrder() {
    const { processByManuscriptOrder: processByManuscriptOrder2 } = await Promise.resolve().then(() => (init_SceneAnalysisCommands(), SceneAnalysisCommands_exports));
    await processByManuscriptOrder2(this.plugin, this.plugin.app.vault);
  }
  async processBySubplotName(subplotName) {
    const { processBySubplotNameWithModal: processBySubplotNameWithModal2 } = await Promise.resolve().then(() => (init_SceneAnalysisCommands(), SceneAnalysisCommands_exports));
    await processBySubplotNameWithModal2(this.plugin, this.plugin.app.vault, subplotName);
  }
  async processEntireSubplot(subplotName) {
    const { processEntireSubplotWithModal: processEntireSubplotWithModal2 } = await Promise.resolve().then(() => (init_SceneAnalysisCommands(), SceneAnalysisCommands_exports));
    await processEntireSubplotWithModal2(this.plugin, this.plugin.app.vault, subplotName);
  }
  async purgeBeatsForSubplot(subplotName) {
    const { purgeBeatsBySubplotName: purgeBeatsBySubplotName2 } = await Promise.resolve().then(() => (init_SceneAnalysisCommands(), SceneAnalysisCommands_exports));
    await purgeBeatsBySubplotName2(this.plugin, this.plugin.app.vault, subplotName);
  }
};
var SubplotPickerModal = class extends import_obsidian62.Modal {
  constructor(app, service, options) {
    super(app);
    this.service = service;
    this.options = options;
    this.statsEl = null;
    this.dropdown = null;
    this.infoTextEl = null;
    if (!options.length) {
      throw new Error("No subplot options available.");
    }
    this.selectedSubplot = options[0].name;
    this.statsBySubplot = new Map(options.map((opt) => [opt.name, opt.stats]));
  }
  onOpen() {
    const { contentEl, modalEl, titleEl } = this;
    titleEl.setText("");
    contentEl.empty();
    if (modalEl) {
      modalEl.classList.add("rt-modal-shell");
      modalEl.style.width = "720px";
      modalEl.style.maxWidth = "92vw";
      modalEl.style.maxHeight = "92vh";
    }
    contentEl.addClass("rt-modal-container");
    contentEl.addClass("rt-subplot-picker-modal");
    const modelName = this.service.getActiveModelName();
    const hero = contentEl.createDiv({ cls: "rt-modal-header" });
    const badgeText = modelName ? `AI pulse run \xB7 ${modelName}` : "AI pulse run";
    hero.createSpan({ text: badgeText, cls: "rt-subplot-picker-badge" });
    hero.createEl("h2", { text: "Process subplot scenes", cls: "rt-modal-title" });
    hero.createDiv({ cls: "rt-modal-subtitle", text: "Choose a subplot and run pulse updates just for that arc." });
    const heroStats = hero.createDiv({ cls: "rt-subplot-picker-hero-stats" });
    this.heroStats = {
      flagged: this.createHeroStat(heroStats, "Flagged scenes"),
      processable: this.createHeroStat(heroStats, "Processable scenes"),
      total: this.createHeroStat(heroStats, "Total scenes")
    };
    const formCard = contentEl.createDiv({ cls: "rt-subplot-picker-card" });
    const selectContainer = formCard.createDiv({ cls: "rt-subplot-picker-select" });
    selectContainer.createEl("label", { text: "Pick a subplot to process", cls: "rt-subplot-picker-label" });
    this.dropdown = new import_obsidian62.DropdownComponent(selectContainer.createDiv({ cls: "rt-subplot-picker-dropdown" }));
    this.options.forEach((option, index) => {
      var _a;
      const flaggedSuffix = option.stats.flagged > 0 ? ` (${option.stats.flagged})` : "";
      (_a = this.dropdown) == null ? void 0 : _a.addOption(option.name, `${index + 1}. ${option.name}${flaggedSuffix}`);
    });
    this.dropdown.setValue(this.selectedSubplot);
    this.dropdown.onChange((value) => {
      this.selectedSubplot = value;
      this.updateStats(value);
    });
    this.statsEl = formCard.createDiv({ cls: "rt-subplot-picker-stats" });
    this.updateStats(this.selectedSubplot);
    const buttonRow = contentEl.createDiv({ cls: "rt-modal-actions" });
    new import_obsidian62.ButtonComponent(buttonRow).setButtonText("Process flagged scenes").setCta().onClick(async () => {
      this.close();
      await this.service.processBySubplotName(this.selectedSubplot);
    });
    new import_obsidian62.ButtonComponent(buttonRow).setButtonText("Process entire subplot").setCta().onClick(async () => {
      this.close();
      await this.service.processEntireSubplot(this.selectedSubplot);
    });
    new import_obsidian62.ButtonComponent(buttonRow).setButtonText("Purge all pulse").setWarning().onClick(async () => {
      try {
        this.close();
        await this.service.purgeBeatsForSubplot(this.selectedSubplot);
      } catch (error) {
        new import_obsidian62.Notice(`Error: ${error instanceof Error ? error.message : String(error)}`);
      }
    });
    new import_obsidian62.ButtonComponent(buttonRow).setButtonText("Cancel").onClick(() => this.close());
  }
  createHeroStat(container, label) {
    const stat = container.createDiv({ cls: "rt-subplot-picker-hero-stat" });
    stat.createSpan({ cls: "rt-subplot-picker-hero-label", text: label });
    return stat.createSpan({ cls: "rt-subplot-picker-hero-value", text: "\u2014" });
  }
  updateStats(subplotName) {
    if (!this.statsEl) return;
    const stats = this.statsBySubplot.get(subplotName);
    if (!stats) {
      throw new Error(`Unknown subplot selection: ${subplotName}`);
    }
    this.statsEl.empty();
    const summaryLine = `${stats.flagged} flagged \u2022 ${stats.processable} processable \u2022 ${stats.total} total`;
    this.statsEl.createDiv({ cls: "rt-subplot-picker-stats-line", text: summaryLine });
    const isLocalReportOnly = this.service.isLocalReportOnlyMode();
    const infoText = isLocalReportOnly ? "Local LLM mode: Results logged to AI report only (YAML pulse fields not updated)." : "Flagged scenes with processable metadata are sent to the AI along with the manuscript content.";
    this.statsEl.createDiv({
      cls: "rt-subplot-picker-summary",
      text: infoText
    });
    if (this.heroStats) {
      this.heroStats.flagged.setText(String(stats.flagged));
      this.heroStats.processable.setText(String(stats.processable));
      this.heroStats.total.setText(String(stats.total));
    }
  }
  updateInfoText(modelName) {
    if (!this.infoTextEl) return;
    this.infoTextEl.setText(`Process pulse using ${modelName} for the subplot "${this.selectedSubplot}".`);
  }
};

// src/services/StatusBarService.ts
var StatusBarService = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.beatsStatusBarItem = null;
  }
  showBeatsStatus(current, total) {
    if (!this.beatsStatusBarItem) {
      this.beatsStatusBarItem = this.plugin.addStatusBarItem();
      this.beatsStatusBarItem.addClass("rt-pulse-status-bar");
      this.plugin.registerDomEvent(this.beatsStatusBarItem, "click", () => {
        if (this.plugin.activeBeatsModal) {
          this.plugin.activeBeatsModal.open();
        }
      });
      this.beatsStatusBarItem.style.cursor = "pointer";
      this.beatsStatusBarItem.title = "Click to view progress";
    }
    const percentage = total > 0 ? Math.round(current / total * 100) : 0;
    this.beatsStatusBarItem.setText(`Scene beats: ${current}/${total} (${percentage}%)`);
  }
  hideBeatsStatus() {
    if (this.beatsStatusBarItem) {
      this.beatsStatusBarItem.remove();
      this.beatsStatusBarItem = null;
    }
  }
};

// src/services/BeatsProcessingService.ts
var BeatsProcessingService = class {
  constructor(statusBarService) {
    this.statusBarService = statusBarService;
  }
  showStatus(current, total) {
    this.statusBarService.showBeatsStatus(current, total);
  }
  hideStatus() {
    this.statusBarService.hideBeatsStatus();
  }
};

// src/services/ThemeService.ts
init_defaults();
var ThemeService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  applyCssVariables() {
    const root = document.documentElement;
    const { publishStageColors, subplotColors } = this.plugin.settings;
    Object.entries(publishStageColors).forEach(([stage, color]) => {
      root.style.setProperty(`--rt-publishStageColors-${stage}`, color);
      const rgbValues = this.hexToRGB(color);
      if (rgbValues) {
        root.style.setProperty(`--rt-publishStageColors-${stage}-rgb`, rgbValues);
      }
    });
    if (Array.isArray(subplotColors)) {
      for (let i = 0; i < 16; i++) {
        const color = subplotColors[i] || DEFAULT_SETTINGS.subplotColors[i];
        if (color) {
          root.style.setProperty(`--rt-subplot-colors-${i}`, color);
        }
      }
    }
  }
  hexToRGB(hex) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    if (isNaN(r) || isNaN(g) || isNaN(b)) {
      return null;
    }
    return `${r}, ${g}, ${b}`;
  }
};

// src/services/TimelineMetricsService.ts
init_sceneHelpers();
var TimelineMetricsService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  calculateCompletionEstimate(scenes) {
    const sceneNotesOnly = scenes.filter((scene) => !isBeatNote(scene));
    if (sceneNotesOnly.length === 0) return null;
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const allScenesComplete = sceneNotesOnly.every((scene) => {
      var _a, _b;
      const publishStage = ((_a = scene["Publish Stage"]) == null ? void 0 : _a.toString().trim().toLowerCase()) || "";
      const sceneStatus = ((_b = scene.status) == null ? void 0 : _b.toString().trim().toLowerCase()) || "";
      return publishStage === "press" && (sceneStatus === "complete" || sceneStatus === "done");
    });
    if (allScenesComplete) {
      const targetDate = this.plugin.settings.targetCompletionDate ? /* @__PURE__ */ new Date(this.plugin.settings.targetCompletionDate + "T00:00:00") : null;
      this.captureLatestStats(sceneNotesOnly.length, 0, 0);
      return { date: targetDate, total: sceneNotesOnly.length, remaining: 0, rate: 0 };
    }
    const startOfYear = new Date(today.getFullYear(), 0, 1);
    const startOfYearTime = startOfYear.getTime();
    const todayTime = today.getTime();
    const daysPassedThisYear = Math.max(1, Math.round((todayTime - startOfYearTime) / (1e3 * 60 * 60 * 24)));
    let completedThisYear = 0;
    const completedPathsThisYear = /* @__PURE__ */ new Set();
    sceneNotesOnly.forEach((scene) => {
      var _a;
      const dueDateStr = scene.due;
      const scenePath = scene.path;
      const sceneStatus = (_a = scene.status) == null ? void 0 : _a.toString().trim().toLowerCase();
      if (sceneStatus !== "complete" && sceneStatus !== "done") return;
      if (!scenePath || completedPathsThisYear.has(scenePath)) return;
      if (!dueDateStr) return;
      try {
        const dueDate = /* @__PURE__ */ new Date(dueDateStr + "T00:00:00");
        dueDate.setHours(0, 0, 0, 0);
        const dueTime = dueDate.getTime();
        if (!isNaN(dueTime) && dueTime >= startOfYearTime && dueTime < todayTime) {
          completedThisYear++;
          completedPathsThisYear.add(scenePath);
        }
      } catch (e) {
      }
    });
    if (completedThisYear <= 0) {
      this.captureLatestStats(sceneNotesOnly.length, sceneNotesOnly.length, 0);
      return null;
    }
    const scenesPerDay = completedThisYear / daysPassedThisYear;
    const processedPaths = /* @__PURE__ */ new Set();
    const currentStatusCounts = sceneNotesOnly.reduce((acc, scene) => {
      var _a;
      if (!scene.path || processedPaths.has(scene.path)) {
        return acc;
      }
      processedPaths.add(scene.path);
      const normalizedStatus = ((_a = scene.status) == null ? void 0 : _a.toString().trim().toLowerCase()) || "Todo";
      if (normalizedStatus === "complete" || normalizedStatus === "done") {
        acc["Completed"] = (acc["Completed"] || 0) + 1;
      } else if (scene.due) {
        try {
          const dueDate = /* @__PURE__ */ new Date(scene.due + "T00:00:00");
          if (!isNaN(dueDate.getTime()) && dueDate.getTime() < todayTime) {
            acc["Due"] = (acc["Due"] || 0) + 1;
          } else {
            acc[normalizedStatus] = (acc[normalizedStatus] || 0) + 1;
          }
        } catch (e) {
          acc[normalizedStatus] = (acc[normalizedStatus] || 0) + 1;
        }
      } else {
        acc[normalizedStatus] = (acc[normalizedStatus] || 0) + 1;
      }
      return acc;
    }, {});
    this.plugin.latestStatusCounts = currentStatusCounts;
    const completedCount = currentStatusCounts["Completed"] || 0;
    const totalScenes = Object.values(currentStatusCounts).reduce((sum, count) => sum + count, 0);
    const remainingScenes = totalScenes - completedCount;
    if (remainingScenes <= 0) {
      this.captureLatestStats(totalScenes, 0, scenesPerDay * 7);
      return null;
    }
    const daysNeeded = remainingScenes / scenesPerDay;
    if (!isFinite(daysNeeded) || daysNeeded < 0 || scenesPerDay <= 0) {
      this.captureLatestStats(totalScenes, remainingScenes, scenesPerDay * 7);
      return null;
    }
    const scenesPerWeek = scenesPerDay * 7;
    const estimatedDate = new Date(today);
    estimatedDate.setDate(today.getDate() + Math.ceil(daysNeeded));
    this.captureLatestStats(totalScenes, remainingScenes, scenesPerWeek);
    return {
      date: estimatedDate,
      total: totalScenes,
      remaining: remainingScenes,
      rate: parseFloat(scenesPerWeek.toFixed(1))
    };
  }
  captureLatestStats(total, remaining, rate) {
    this.plugin.latestTotalScenes = total;
    this.plugin.latestRemainingScenes = remaining;
    this.plugin.latestScenesPerWeek = rate;
  }
};

// src/migrations/sceneAnalysis.ts
async function migrateSceneAnalysisFields(plugin) {
  try {
    const files = plugin.app.vault.getMarkdownFiles();
    let migratedCount = 0;
    for (const file of files) {
      const cache = plugin.app.metadataCache.getFileCache(file);
      const fm = cache == null ? void 0 : cache.frontmatter;
      if (fm && (fm["1beats"] || fm["2beats"] || fm["3beats"])) {
        const needsMigration = (fm["1beats"] || fm["2beats"] || fm["3beats"]) && !(fm["previousSceneAnalysis"] || fm["currentSceneAnalysis"] || fm["nextSceneAnalysis"]);
        if (needsMigration) {
          await plugin.app.fileManager.processFrontMatter(file, (frontmatter) => {
            const fmObj = frontmatter;
            if (fmObj["1beats"]) {
              fmObj["previousSceneAnalysis"] = fmObj["1beats"];
              delete fmObj["1beats"];
            }
            if (fmObj["2beats"]) {
              fmObj["currentSceneAnalysis"] = fmObj["2beats"];
              delete fmObj["2beats"];
            }
            if (fmObj["3beats"]) {
              fmObj["nextSceneAnalysis"] = fmObj["3beats"];
              delete fmObj["3beats"];
            }
          });
          migratedCount++;
        }
      }
    }
    void migratedCount;
  } catch (error) {
    console.error("[Radial Timeline] Error during migration:", error);
  }
}

// src/services/SettingsService.ts
var import_obsidian63 = require("obsidian");
init_defaults();
var SettingsService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async validateAndRememberPath(path) {
    if (!path || path.trim() === "") return false;
    const normalizedPath = (0, import_obsidian63.normalizePath)(path.trim());
    const file = this.plugin.app.vault.getAbstractFileByPath(normalizedPath);
    const isValid = file instanceof import_obsidian63.TFolder && file.path === normalizedPath;
    if (isValid) {
      const { validFolderPaths } = this.plugin.settings;
      if (!validFolderPaths.includes(normalizedPath)) {
        validFolderPaths.unshift(normalizedPath);
        if (validFolderPaths.length > 10) {
          this.plugin.settings.validFolderPaths = validFolderPaths.slice(0, 10);
        }
        await this.plugin.saveSettings();
      }
      return true;
    }
    return false;
  }
  normalizeModelIds() {
    const defaultGeminiModel = DEFAULT_SETTINGS.geminiModelId || "gemini-3-pro-preview";
    const normalize = (prov, id) => {
      if (!id) return id;
      if (prov === "anthropic") {
        if (id === "claude-4.1-opus" || id === "claude-opus-4-1" || id === "claude-3-opus-20240229" || id === "claude-opus-4-0" || id === "claude-opus-4-1@20250805") return "claude-opus-4-1-20250805";
        if (id === "claude-4-sonnet" || id === "claude-sonnet-4-1" || id === "claude-3-7-sonnet-20250219" || id === "claude-sonnet-4-0" || id === "claude-sonnet-4-1@20250805" || id === "claude-sonnet-4-20250514") return "claude-sonnet-4-5-20250929";
        return id;
      }
      if (prov === "openai") {
        if (id === "gpt-5" || id === "o3" || id === "gpt-4o") return "gpt-4.1";
        return id;
      }
      if (prov === "gemini") {
        let trimmed = id.trim();
        if (trimmed.startsWith("models/")) {
          trimmed = trimmed.slice(7);
        }
        const legacyGeminiIds = /* @__PURE__ */ new Set([
          "gemini-ultra",
          "gemini-creative",
          "gemini-1.0-pro",
          "gemini-1.5-pro",
          "gemini-2.5-pro",
          "gemini-2.0-flash-exp"
        ]);
        if (legacyGeminiIds.has(trimmed)) {
          return defaultGeminiModel;
        }
        return trimmed;
      }
      return id;
    };
    const settings = this.plugin.settings;
    settings.anthropicModelId = normalize("anthropic", settings.anthropicModelId);
    settings.openaiModelId = normalize("openai", settings.openaiModelId);
    settings.geminiModelId = normalize("gemini", settings.geminiModelId);
  }
  async migrateAiContextTemplates() {
    const settings = this.plugin.settings;
    let migrated = false;
    const oldBuiltInIds = /* @__PURE__ */ new Set(["generic-editor", "ya-biopunk-scifi", "adult-thriller", "adult-romance"]);
    const cloneBuiltInTemplates = () => {
      var _a;
      return ((_a = DEFAULT_SETTINGS.aiContextTemplates) != null ? _a : []).map((template) => ({ ...template }));
    };
    if (!settings.aiContextTemplates || settings.aiContextTemplates.length === 0) {
      settings.aiContextTemplates = cloneBuiltInTemplates();
      migrated = true;
    } else {
      const builtInTemplates = cloneBuiltInTemplates();
      settings.aiContextTemplates = settings.aiContextTemplates.filter((template) => !template.isBuiltIn || !oldBuiltInIds.has(template.id));
      const existingIds = new Set(settings.aiContextTemplates.map((t2) => t2.id));
      for (const builtIn of builtInTemplates) {
        if (!existingIds.has(builtIn.id)) {
          settings.aiContextTemplates.push({ ...builtIn });
          migrated = true;
        }
      }
    }
    if (!settings.activeAiContextTemplateId || oldBuiltInIds.has(settings.activeAiContextTemplateId)) {
      settings.activeAiContextTemplateId = DEFAULT_SETTINGS.activeAiContextTemplateId;
      migrated = true;
    }
    return migrated;
  }
};

// src/main.ts
init_aiDefaults();
init_defaults();
var TIMELINE_VIEW_TYPE2 = "radial-timeline";
var RadialTimelinePlugin = class extends import_obsidian66.Plugin {
  constructor() {
    super(...arguments);
    // Do not store persistent references to views (per Obsidian guidelines)
    // Track open scene paths
    this.openScenePaths = /* @__PURE__ */ new Set();
    // Ensure settings tab is only added once per load
    this._settingsTabAdded = false;
    // Search related properties
    this.searchTerm = "";
    this.searchActive = false;
    this.searchResults = /* @__PURE__ */ new Set();
    this.eventBus = new EventTarget();
    this.metadataCacheListener = null;
    // Completion estimate stats
    this.latestTotalScenes = 0;
    this.latestRemainingScenes = 0;
    this.latestScenesPerWeek = 0;
    // Track active scene analysis processing modal and status bar item
    this.activeBeatsModal = null;
  }
  // Helper: get all currently open timeline views
  getTimelineViews() {
    return this.timelineService.getTimelineViews();
  }
  // Helper: get the first open timeline view (if any)
  getFirstTimelineView() {
    const list = this.getTimelineViews();
    return list.length > 0 ? list[0] : null;
  }
  // Settings access helpers
  get aiProvider() {
    return this.settings.defaultAiProvider || "openai";
  }
  getApiKey() {
    const provider = this.aiProvider;
    if (provider === "anthropic") return this.settings.anthropicApiKey;
    if (provider === "gemini") return this.settings.geminiApiKey;
    return this.settings.openaiApiKey;
  }
  getModelId() {
    const provider = this.aiProvider;
    if (provider === "anthropic") return this.settings.anthropicModelId || "claude-sonnet-4-5-20250929";
    if (provider === "gemini") return this.settings.geminiModelId || DEFAULT_GEMINI_MODEL_ID;
    return this.settings.openaiModelId || "gpt-5.1-chat-latest";
  }
  /**
   * Position and curve the text elements in the SVG
   * @param container The container element with the SVG
   */
  getReleaseNotesBundle() {
    var _a, _b;
    return (_b = (_a = this.releaseNotesService) == null ? void 0 : _a.getBundle()) != null ? _b : null;
  }
  getReleaseNotesEntries() {
    var _a, _b;
    return (_b = (_a = this.releaseNotesService) == null ? void 0 : _a.getEntries()) != null ? _b : [];
  }
  getReleaseNotesMajorVersion() {
    var _a, _b;
    return (_b = (_a = this.releaseNotesService) == null ? void 0 : _a.getMajorVersion()) != null ? _b : null;
  }
  async markReleaseNotesSeen(version) {
    var _a;
    await ((_a = this.releaseNotesService) == null ? void 0 : _a.markReleaseNotesSeen(version));
  }
  async maybeShowReleaseNotesModal() {
    var _a;
    await ((_a = this.releaseNotesService) == null ? void 0 : _a.maybeShowReleaseNotesModal(this.app, this));
  }
  openReleaseNotesModal() {
    var _a;
    (_a = this.releaseNotesService) == null ? void 0 : _a.openReleaseNotesModal(this.app, this);
  }
  async onload() {
    this.settingsService = new SettingsService(this);
    await this.loadSettings();
    this.releaseNotesService = new ReleaseNotesService(this.settings, () => this.saveSettings());
    this.releaseNotesService.initializeFromEmbedded();
    void this.releaseNotesService.ensureReleaseNotesFresh(false);
    await migrateSceneAnalysisFields(this);
    this.timelineService = new TimelineService(this.app, this);
    this.sceneDataService = new SceneDataService(this.app, this.settings);
    const { SearchService: SearchService2 } = await Promise.resolve().then(() => (init_SearchService(), SearchService_exports));
    const { FileTrackingService: FileTrackingService2 } = await Promise.resolve().then(() => (init_FileTrackingService(), FileTrackingService_exports));
    this.searchService = new SearchService2(this.app, this);
    this.fileTrackingService = new FileTrackingService2(this);
    this.rendererService = new RendererService(this.app);
    this.synopsisManager = new SynopsisManager(this);
    this.commandRegistrar = new CommandRegistrar(this, this.app);
    this.sceneHighlighter = new SceneHighlighter(this);
    this.gossamerScoreService = new GossamerScoreService(this.app, this);
    this.sceneAnalysisService = new SceneAnalysisService(this);
    this.statusBarService = new StatusBarService(this);
    this.beatsProcessingService = new BeatsProcessingService(this.statusBarService);
    this.themeService = new ThemeService(this);
    this.timelineMetricsService = new TimelineMetricsService(this);
    this.registerView(
      TIMELINE_VIEW_TYPE2,
      (leaf) => {
        return new RadialTimelineView(leaf, this);
      }
    );
    this.commandRegistrar.registerAll();
    this.sceneAnalysisService.registerCommands();
    if (!this._settingsTabAdded) {
      this.addSettingTab(new RadialTimelineSettingsTab(this.app, this));
      this._settingsTabAdded = true;
    }
    this.fileTrackingService.registerWorkspaceListeners();
    new HoverHighlighter(this.app, this, this.sceneHighlighter).register();
    const versionService = initVersionCheckService(this.manifest.version);
    versionService.checkForUpdates().then((hasUpdate) => {
      if (hasUpdate) {
        this.refreshTimelineIfNeeded(null);
      }
    }).catch((err) => {
      console.warn("[RadialTimeline] Version check failed on startup:", err);
    });
  }
  getRendererService() {
    return this.rendererService;
  }
  getTimelineService() {
    return this.timelineService;
  }
  isSceneFile(path) {
    return this.sceneHighlighter.isSceneFile(path);
  }
  async processSceneAnalysisByManuscriptOrder() {
    await this.sceneAnalysisService.processByManuscriptOrder();
  }
  async processSceneAnalysisBySubplotName(subplotName) {
    await this.sceneAnalysisService.processBySubplotName(subplotName);
  }
  async processEntireSubplot(subplotName) {
    await this.sceneAnalysisService.processEntireSubplot(subplotName);
  }
  async getSceneData(options) {
    return this.sceneDataService.getSceneData(options);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if (!this.settings.anthropicModelId) this.settings.anthropicModelId = DEFAULT_SETTINGS.anthropicModelId;
    if (!this.settings.openaiModelId) this.settings.openaiModelId = DEFAULT_SETTINGS.openaiModelId;
    if (!this.settings.geminiModelId) this.settings.geminiModelId = DEFAULT_SETTINGS.geminiModelId;
    if (!this.settings.defaultAiProvider || !["openai", "anthropic", "gemini", "local"].includes(this.settings.defaultAiProvider)) {
      this.settings.defaultAiProvider = DEFAULT_SETTINGS.defaultAiProvider;
    }
    if (typeof this.settings.lastSeenReleaseNotesVersion !== "string") {
      this.settings.lastSeenReleaseNotesVersion = DEFAULT_SETTINGS.lastSeenReleaseNotesVersion;
    }
    if (this.settings.cachedReleaseNotes === void 0) {
      this.settings.cachedReleaseNotes = DEFAULT_SETTINGS.cachedReleaseNotes;
    }
    if (this.settings.releaseNotesLastFetched !== void 0) {
      const parsed = Date.parse(this.settings.releaseNotesLastFetched);
      if (Number.isNaN(parsed)) {
        this.settings.releaseNotesLastFetched = void 0;
      }
    }
    const before = JSON.stringify({
      anthropicModelId: this.settings.anthropicModelId,
      openaiModelId: this.settings.openaiModelId,
      geminiModelId: this.settings.geminiModelId
    });
    if (!this.settingsService) {
      this.settingsService = new SettingsService(this);
    }
    this.settingsService.normalizeModelIds();
    const templatesMigrated = await this.settingsService.migrateAiContextTemplates();
    const after = JSON.stringify({
      anthropicModelId: this.settings.anthropicModelId,
      openaiModelId: this.settings.openaiModelId,
      geminiModelId: this.settings.geminiModelId
    });
    if (before !== after || templatesMigrated) {
      await this.saveSettings();
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // Helper method to validate and remember folder paths
  async validateAndRememberPath(path) {
    return this.settingsService.validateAndRememberPath(path);
  }
  // Remove redundant parseSceneTitle method - use the one from utils/text.ts instead
  // Method to refresh the timeline if the active view exists (with debouncing)
  refreshTimelineIfNeeded(file, delayMs) {
    const effectiveDelay = file === null && delayMs === void 0 ? 0 : delayMs != null ? delayMs : 400;
    this.timelineService.refreshTimelineIfNeeded(file, effectiveDelay);
  }
  // Search related methods
  openSearchPrompt() {
    this.searchService.openSearchPrompt();
  }
  performSearch(term) {
    this.searchService.performSearch(term);
  }
  clearSearch() {
    this.searchService.clearSearch();
  }
  setCSSColorVariables() {
    this.themeService.applyCssVariables();
  }
  // Add helper method to highlight search terms
  // Helper method to convert DocumentFragment to string for backward compatibility
  // --- START: Color Conversion & Desaturation Helpers ---
  // Ensure these are PUBLIC
  desaturateColor(hexColor, amount) {
    const rgb = hexToRgb(hexColor);
    if (!rgb) return hexColor;
    const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
    hsl.s = Math.max(0, hsl.s * (1 - amount));
    const desat = hslToRgb(hsl.h, hsl.s, hsl.l);
    return rgbToHex(desat.r, desat.g, desat.b);
  }
  // --- END: Color Conversion & Desaturation Helpers ---
  // Add this function inside the RadialTimelinePlugin class
  calculateCompletionEstimate(scenes) {
    return this.timelineMetricsService.calculateCompletionEstimate(scenes);
  }
  /**
   * Show status bar item with beats processing progress
   */
  showBeatsStatusBar(current, total) {
    this.beatsProcessingService.showStatus(current, total);
  }
  /**
   * Hide and remove status bar item when processing completes
   */
  hideBeatsStatusBar() {
    var _a;
    (_a = this.beatsProcessingService) == null ? void 0 : _a.hideStatus();
  }
  async saveGossamerScores(scores) {
    await this.gossamerScoreService.saveScores(scores);
  }
  onunload() {
    this.hideBeatsStatusBar();
    cleanupTooltipAnchors();
  }
  dispatch(type, detail) {
    this.eventBus.dispatchEvent(new CustomEvent(type, { detail }));
  }
};
